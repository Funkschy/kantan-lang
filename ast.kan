#include "expr_types.h"
#include "stmt_types.h"

import "std"
import "io" // TODO: only debug
import "ptrvec"
import "span"

extern def binary2str(op: i32): string;

type CompilationUnit struct {
    statements: ptrvec.Vec
}

def cu_create(): CompilationUnit {
    return CompilationUnit { statements: ptrvec.create() };
}

def cu_push(cu: *CompilationUnit, stmt: *Stmt): void {
    ptrvec.push(&cu.statements, stmt as *void);
}

def cu_get(cu: *CompilationUnit, i: i32): *Stmt {
    return ptrvec.get(&cu.statements, i) as *Stmt;
}

def cu_free(cu: *CompilationUnit): void {
    let i = 0;
    while i < cu.statements.len {
        stmt_free(cu_get(cu, i));
        i = i + 1;
    }

    ptrvec.free_v(&cu.statements);
}

/////////// expr stmt ///////////

type ExprStmt struct {
    s: Stmt,
    expr: *Expr
}

def make_expr_stmt(e: *Expr): *Stmt {
    return (new ExprStmt { s: Stmt { tag: STMT_EXPR }, expr: e }) as *Stmt;
}

def is_expr_stmt(s: *Stmt): bool {
    return s.tag == STMT_EXPR;
}

def as_expr_stmt(s: *Stmt): *ExprStmt {
    return s as *ExprStmt;
}

/////////// let stmt ///////////

type LetStmt struct {
    s: Stmt,
    ident: lexer.Token,
    value: *Expr
}

def make_let_stmt(ident: lexer.Token, value: *Expr): *Stmt {
    return (new LetStmt {
        s: Stmt { tag: STMT_LET },
        ident: ident,
        value: value
    }) as *Stmt;
}

def is_let_stmt(s: *Stmt): bool {
    return s.tag == STMT_LET;
}

def as_let_stmt(s: *Stmt): *LetStmt {
    return s as *LetStmt;
}

/////////// base stmt ///////////

type Stmt struct {
    tag: i32
}

def stmt_free(s: *Stmt): void {
    if is_expr_stmt(s) {
        expr_free(as_expr_stmt(s).expr);
    } else if is_let_stmt(s) {
        expr_free(as_let_stmt(s).value);
    }
    delete s;
}

/////////// int expr ///////////

// TODO: hex, oct ...
type IntExpr struct {
    e: Expr,
    len: i32,
    ptr: string
}

def make_int(span: span.Span, len: i32, ptr: string): *Expr {
    return (new IntExpr {
        e: Expr { tag: EXPR_INT, span: span },
        len: len,
        ptr: ptr
    }) as *Expr;
}

def is_int(e: *Expr): bool {
    return e.tag == EXPR_INT;
}

def as_int(e: *Expr): *IntExpr {
    return e as *IntExpr;
}

/////////// binary expr ///////////

type BinaryExpr struct {
    e: Expr,
    left: *Expr,
    right: *Expr,
    ty: i32
}

def make_binary(span: span.Span, ty: i32, left: *Expr, right: *Expr): *Expr {
    return (new BinaryExpr {
        e: Expr { tag: EXPR_BINARY, span: span },
        left: left,
        right: right,
        ty: ty
    }) as *Expr;
}

def is_binary(e: *Expr): bool {
    return e.tag == EXPR_BINARY;
}

def as_binary(e: *Expr): *BinaryExpr {
    return e as *BinaryExpr;
}

/////////// base expr ///////////

type Expr struct {
    tag: i32,
    span: span.Span
}

def expr_free(e: *Expr): void {
    if is_int(e) {
        // nothing to do
    } else if is_binary(e) {
        let b_expr = as_binary(e);
        expr_free(b_expr.left);
        expr_free(b_expr.right);
    }

    delete e;
}

def expr_to_string(e: *Expr): string {
    if is_int(e) {
        let i_expr = as_int(e);
        return std.strndup(i_expr.ptr, i_expr.len);
    } else if is_binary(e) {
        let b_expr = as_binary(e);

        let left = expr_to_string(b_expr.left);
        let right = expr_to_string(b_expr.right);
        let tok_str = binary2str(b_expr.ty);

        let s = std.format_str("%s%s%s", left, tok_str, right);
        delete left;
        delete right;

        return s;
    }

    return null;
}
