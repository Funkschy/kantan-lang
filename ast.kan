#include "expr_types.h"
#include "stmt_types.h"

import "std";
import "span";
import "ident";
import "func";
import "ptrvec"

import "io"; // TODO: only debug

extern def binary2str(op: i32): string;

/////////// expr stmt ///////////

type ExprStmt struct {
    s: Stmt,
    expr: *Expr
}

def make_expr_stmt(e: *Expr): *Stmt {
    return (new ExprStmt { s: Stmt { tag: STMT_EXPR }, expr: e }) as *Stmt;
}

def is_expr_stmt(s: *Stmt): bool {
    return s.tag == STMT_EXPR;
}

def as_expr_stmt(s: *Stmt): *ExprStmt {
    return s as *ExprStmt;
}

/////////// Block stmt ///////////

type BlockStmt struct {
    s: Stmt,
    stmts: ptrvec.Vec
}

def make_block_stmt(statements: ptrvec.Vec): *Stmt {
    return (new BlockStmt{
        s: Stmt { tag: STMT_BLOCK },
        stmts: statements
    }) as *Stmt;
}

def is_block_stmt(s: *Stmt): bool {
    return s.tag == STMT_BLOCK;
}

def as_block_stmt(s: *Stmt): *BlockStmt {
    return s as *BlockStmt;
}

/////////// Func Decl stmt ///////////

type FuncDeclStmt struct {
    s: Stmt,
    decl: func.FuncDef,
    block: *BlockStmt
}

def make_func_decl_stmt(ident: lexer.Token, params: func.ParamList, ret_ty: ident.Ident, block: *BlockStmt): *Stmt {
    return (new FuncDeclStmt {
        s: Stmt { tag: STMT_FUNC_DECL },
        decl: func.create(ident, params, ret_ty),
        block: block
    }) as *Stmt;
}

def is_func_decl_stmt(s: *Stmt): bool {
    return s.tag == STMT_FUNC_DECL;
}

def as_func_decl_stmt(s: *Stmt): *FuncDeclStmt {
    return s as *FuncDeclStmt;
}

/////////// import stmt ///////////

type ImportStmt struct {
    s: Stmt,
    path_span: span.Span,
    mod_path: string
}

def make_import_stmt(span: span.Span, mod_path: string): *Stmt {
    return (new ImportStmt {
        s: Stmt { tag: STMT_IMPORT },
        path_span: span,
        mod_path: mod_path
    }) as *Stmt;
}

def is_import_stmt(s: *Stmt): bool {
    return s.tag == STMT_IMPORT;
}

def as_import_stmt(s: *Stmt): *ImportStmt {
    return s as *ImportStmt;
}

/////////// let stmt ///////////

type LetStmt struct {
    s: Stmt,
    value: *Expr,
    ident: ident.Ident
}

def make_let_stmt(ident: lexer.Token, value: *Expr): *Stmt {
    return (new LetStmt {
        s: Stmt { tag: STMT_LET },
        value: value,
        ident: ident.create(ident)
    }) as *Stmt;
}

def is_let_stmt(s: *Stmt): bool {
    return s.tag == STMT_LET;
}

def as_let_stmt(s: *Stmt): *LetStmt {
    return s as *LetStmt;
}

/////////// base stmt ///////////

type Stmt struct {
    tag: i32
}

def stmt_free(s: *Stmt): void {
    if s == null {
        return;
    }

    if is_expr_stmt(s) {
        expr_free(as_expr_stmt(s).expr);
    } else if is_let_stmt(s) {
        expr_free(as_let_stmt(s).value);
    } else if is_func_decl_stmt(s) {
        let f_decl = as_func_decl_stmt(s);
        let decl = f_decl.decl;
        func.free_f(&decl);
        stmt_free(f_decl.block as *Stmt);
    } else if is_block_stmt(s) {
        let stmts = as_block_stmt(s).stmts;

        let i = 0;
        while i < stmts.len {
            let s = ptrvec.get(&stmts, i);
            if s != null {
                stmt_free(s as *Stmt);
            }
            i = i + 1;
        }

        ptrvec.free_v(&stmts);
    }

    delete s;
}

/////////// ident expr ///////////

type IdentExpr struct {
    e: Expr,
    ident: ident.Ident
}

def make_ident(ident: lexer.Token): *Expr {
    return (new IdentExpr {
        e: Expr { tag: EXPR_IDENT, span: ident.span },
        ident: ident.create(ident)
    }) as *Expr;
}

def is_ident(e: *Expr): bool {
    return e.tag == EXPR_IDENT;
}

def as_ident(e: *Expr): *IdentExpr {
    return e as *IdentExpr;
}

/////////// int expr ///////////

// TODO: hex, oct ...
type IntExpr struct {
    e: Expr,
    ptr: string
}

def make_int(span: span.Span, ptr: string): *Expr {
    return (new IntExpr {
        e: Expr { tag: EXPR_INT, span: span },
        ptr: ptr
    }) as *Expr;
}

def is_int(e: *Expr): bool {
    return e.tag == EXPR_INT;
}

def as_int(e: *Expr): *IntExpr {
    return e as *IntExpr;
}

/////////// string expr ///////////

type StringExpr struct {
    e: Expr,
    ptr: string
}

def make_string(span: span.Span, ptr: string): *Expr {
    return (new StringExpr {
        e: Expr { tag: EXPR_STRING, span: span },
        ptr: ptr
    }) as *Expr;
}

def is_string(e: *Expr): bool {
    return e.tag == EXPR_STRING;
}

def as_string(e: *Expr): *StringExpr {
    return e as *StringExpr;
}


/////////// binary expr ///////////

type BinaryExpr struct {
    e: Expr,
    left: *Expr,
    right: *Expr,
    ty: i32
}

def make_binary(span: span.Span, ty: i32, left: *Expr, right: *Expr): *Expr {
    return (new BinaryExpr {
        e: Expr { tag: EXPR_BINARY, span: span },
        left: left,
        right: right,
        ty: ty
    }) as *Expr;
}

def is_binary(e: *Expr): bool {
    return e.tag == EXPR_BINARY;
}

def as_binary(e: *Expr): *BinaryExpr {
    return e as *BinaryExpr;
}

/////////// base expr ///////////

type Expr struct {
    tag: i32,
    span: span.Span
}

def expr_free(e: *Expr): void {
    if is_binary(e) {
        let b_expr = as_binary(e);
        expr_free(b_expr.left);
        expr_free(b_expr.right);
    }

    delete e;
}

def expr_to_string(e: *Expr, span_interner: *span.SpanInterner): string {
    if is_int(e) {
        let i_expr = as_int(e);
        let len = span.get(span_interner, e.span).len;
        return std.strndup(i_expr.ptr, len);
    } else if is_string(e) {
        let s_expr = as_string(e);
        let len = span.get(span_interner, e.span).len;
        // include the quotes
        return std.strndup(s_expr.ptr - 1, len + 2);
    } else if is_ident(e) {
        let i_expr = as_ident(e);
        return ident.to_string(&i_expr.ident, span_interner);
    } else if is_binary(e) {
        let b_expr = as_binary(e);

        let left = expr_to_string(b_expr.left, span_interner);
        let right = expr_to_string(b_expr.right, span_interner);
        let tok_str = binary2str(b_expr.ty);

        let s = std.format_str("%s%s%s", left, tok_str, right);
        delete left;
        delete right;

        return s;
    }

    return null;
}
