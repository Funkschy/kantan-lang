#include "expr_types.h"
#include "stmt_types.h"

import "std";
import "span";
import "ident";
import "func";
import "record";
import "ptrvec";
import "tyid";
import "ty";

import "io"; // TODO: only debug

extern def binary2str(op: i32): string;
extern def unary2str(op: i32): string;
extern def expr2str(op: i32): string;

/////////// expr stmt ///////////

type ExprStmt struct {
    s: Stmt,
    expr: *Expr
}

def new_expr_stmt(e: *Expr): *Stmt {
    return (new ExprStmt { s: Stmt { tag: STMT_EXPR }, expr: e }) as *Stmt;
}

def is_expr_stmt(s: *Stmt): bool {
    return s.tag == STMT_EXPR;
}

def as_expr_stmt(s: *Stmt): *ExprStmt {
    return s as *ExprStmt;
}

/////////// Delete stmt ///////////

type DeleteStmt struct {
    s: Stmt,
    expr: *Expr
}

def new_delete_stmt(expr: *Expr): *Stmt {
    return (new DeleteStmt {
        s: Stmt { tag: STMT_DELETE },
        expr: expr
    }) as *Stmt;
}

def is_delete_stmt(s: *Stmt): bool {
    return s.tag == STMT_DELETE;
}

def as_delete_stmt(s: *Stmt): *DeleteStmt {
    return s as *DeleteStmt;
}

/////////// Return stmt ///////////

type ReturnStmt struct {
    s: Stmt,
    expr: *Expr
}

def new_return_stmt(expr: *Expr): *Stmt {
    return (new ReturnStmt {
        s: Stmt { tag: STMT_RETURN },
        expr: expr
    }) as *Stmt;
}

def is_return_stmt(s: *Stmt): bool {
    return s.tag == STMT_RETURN;
}

def as_return_stmt(s: *Stmt): *ReturnStmt {
    return s as *ReturnStmt;
}

/////////// While stmt ///////////

type WhileStmt struct {
    s: Stmt,
    condition: *Expr,
    block: *BlockStmt
}

def new_while_stmt(condition: *Expr, block: *BlockStmt): *Stmt {
    return (new WhileStmt {
        s: Stmt { tag: STMT_WHILE },
        condition: condition,
        block: block
    }) as *Stmt;
}

def is_while_stmt(s: *Stmt): bool {
    return s.tag == STMT_WHILE;
}

def as_while_stmt(s: *Stmt): *WhileStmt {
    return s as *WhileStmt;
}

/////////// If stmt ///////////

type IfStmt struct {
    s: Stmt,
    condition: *Expr,
    block: *BlockStmt,
    else_stmt: *Stmt // either IfStmt or BlockStmt
}

def new_if_stmt(condition: *Expr, block: *BlockStmt, else_stmt: *Stmt): *Stmt {
    return (new IfStmt {
        s: Stmt { tag: STMT_IF },
        condition: condition,
        block: block,
        else_stmt: else_stmt
    }) as *Stmt;
}

def is_if_stmt(s: *Stmt): bool {
    return s.tag == STMT_IF;
}

def as_if_stmt(s: *Stmt): *IfStmt {
    return s as *IfStmt;
}

def else_type(s: *IfStmt): i32 {
    if s.else_stmt == null {
        return type_no_else();
    }

    if is_block_stmt(s.else_stmt) {
        return type_else_block();
    }

    if is_if_stmt(s.else_stmt) {
        return type_else_if();
    }

    return type_no_else();
}

def type_no_else(): i32 {
    return 0;
}

def type_else_block(): i32 {
    return 1;
}

def type_else_if(): i32 {
    return 2;
}

/////////// Block stmt ///////////

type BlockStmt struct {
    s: Stmt,
    stmts: ptrvec.Vec
}

def new_block_stmt(statements: ptrvec.Vec): *Stmt {
    return (new BlockStmt{
        s: Stmt { tag: STMT_BLOCK },
        stmts: statements
    }) as *Stmt;
}

def is_block_stmt(s: *Stmt): bool {
    return s.tag == STMT_BLOCK;
}

def as_block_stmt(s: *Stmt): *BlockStmt {
    return s as *BlockStmt;
}

def stmt_at(b: *BlockStmt, i: i32): *Stmt {
    return ptrvec.get(&b.stmts, i) as *Stmt;
}

/////////// Func Decl stmt ///////////

type FuncDeclStmt struct {
    s: Stmt,
    decl: func.FuncDef,
    block: *BlockStmt
}

def new_func_decl_stmt(
    ident: lexer.Token,
    params: func.ParamList,
    ret_ty: tyid.Type,
    is_extern: bool,
    block: *BlockStmt
): *Stmt {
    return (new FuncDeclStmt {
        s: Stmt { tag: STMT_FUNC_DECL },
        decl: func.create(ident, params, ret_ty, is_extern),
        block: block
    }) as *Stmt;
}

def is_func_decl_stmt(s: *Stmt): bool {
    return s.tag == STMT_FUNC_DECL;
}

def as_func_decl_stmt(s: *Stmt): *FuncDeclStmt {
    return s as *FuncDeclStmt;
}

/////////// Struct Decl stmt ///////////

type StructDeclStmt struct {
    s: Stmt,
    decl: record.StructDecl
}

def new_struct_decl_stmt(si: *span.SpanInterner, name: ident.Ident, fields: vec.Vec): *Stmt {
    return (new StructDeclStmt {
        s: Stmt { tag: STMT_STRUCT_DECL },
        decl: record.create_struct(si, name, fields)
    }) as *Stmt;
}

def is_struct_decl_stmt(s: *Stmt): bool {
    return s.tag == STMT_STRUCT_DECL;
}

def as_struct_decl_stmt(s: *Stmt): *StructDeclStmt {
    return s as *StructDeclStmt;
}

/////////// import stmt ///////////

type ImportStmt struct {
    s: Stmt,
    mod: ident.Ident
}

def new_import_stmt(span: span.Span, mod_path: string): *Stmt {
    return (new ImportStmt {
        s: Stmt { tag: STMT_IMPORT },
        mod: ident.from_str(span, mod_path)
    }) as *Stmt;
}

def is_import_stmt(s: *Stmt): bool {
    return s.tag == STMT_IMPORT;
}

def as_import_stmt(s: *Stmt): *ImportStmt {
    return s as *ImportStmt;
}

/////////// let stmt ///////////

type LetStmt struct {
    s: Stmt,
    value: *Expr,
    ident: ident.Ident,
    ty: tyid.Type
}

def new_let_stmt(ident: lexer.Token, ty: tyid.Type, value: *Expr): *Stmt {
    return (new LetStmt {
        s: Stmt { tag: STMT_LET },
        value: value,
        ident: ident.create(ident),
        ty: ty
    }) as *Stmt;
}

def is_let_stmt(s: *Stmt): bool {
    return s.tag == STMT_LET;
}

def as_let_stmt(s: *Stmt): *LetStmt {
    return s as *LetStmt;
}

def has_type_decl(s: *LetStmt): bool {
    return !tyid.is_empty(&s.ty);
}

/////////// base stmt ///////////

type Stmt struct {
    tag: i32
}

def stmt_free(s: *Stmt): void {
    if s == null {
        return;
    }

    if is_expr_stmt(s) {
        expr_free(as_expr_stmt(s).expr);
    } else if is_let_stmt(s) {
        expr_free(as_let_stmt(s).value);
    } else if is_delete_stmt(s) {
        expr_free(as_delete_stmt(s).expr);
    } else if is_return_stmt(s) {
        expr_free(as_return_stmt(s).expr);
    } else if is_func_decl_stmt(s) {
        let f_decl = as_func_decl_stmt(s);
        let decl = f_decl.decl;
        func.free_f(&decl);
        stmt_free(f_decl.block as *Stmt);
    } else if is_block_stmt(s) {
        let stmts = as_block_stmt(s).stmts;

        let i = 0;
        while i < stmts.len {
            let s = ptrvec.get(&stmts, i);
            if s != null {
                stmt_free(s as *Stmt);
            }
            i = i + 1;
        }

        ptrvec.free_v(&stmts);
    } else if is_if_stmt(s) {
        let if_stmt = as_if_stmt(s);
        expr_free(if_stmt.condition);
        stmt_free(if_stmt.block as *Stmt);
        stmt_free(if_stmt.else_stmt);
    } else if is_while_stmt(s) {
        let while_stmt = as_while_stmt(s);
        expr_free(while_stmt.condition);
        stmt_free(while_stmt.block as *Stmt);
    } else if is_struct_decl_stmt(s) {
        let s_stmt = as_struct_decl_stmt(s);
        record.free_struct(&s_stmt.decl);
    }

    delete s;
}

/////////// access expr ///////////

type AccessExpr struct {
    e: Expr,
    left: *Expr,
    right: *Expr
}

def new_access_expr(span: span.Span, left: *Expr, right: *Expr): *Expr {
    return (new AccessExpr {
        e: create_expr(EXPR_ACCESS, span),
        left: left,
        right: right
    }) as *Expr;
}

def is_access_expr(e: *Expr): bool {
    return e.tag == EXPR_ACCESS;
}

def as_access_expr(e: *Expr): *AccessExpr {
    return e as *AccessExpr;
}

/////////// as expr ///////////

type AsExpr struct {
    e: Expr,
    expr: *Expr,
    ty: tyid.Type
}

def new_as_expr(span: span.Span, expr: *Expr, ty: tyid.Type): *Expr {
    return (new AsExpr {
        e: create_expr(EXPR_AS, span),
        expr: expr,
        ty: ty
    }) as *Expr;
}

def is_as_expr(e: *Expr): bool {
    return e.tag == EXPR_AS;
}

def as_as_expr(e: *Expr): *AsExpr {
    return e as *AsExpr;
}

/////////// new expr ///////////

type NewExpr struct {
    e: Expr,
    expr: *Expr
}

def new_new_expr(span: span.Span, expr: *Expr): *Expr {
    return (new NewExpr {
        e: create_expr(EXPR_NEW, span),
        expr: expr
    }) as *Expr;
}

def is_new_expr(e: *Expr): bool {
    return e.tag == EXPR_NEW;
}

def as_new_expr(e: *Expr): *NewExpr {
    return e as *NewExpr;
}

/////////// call expr ///////////

type CallExpr struct {
    e: Expr,
    callee: *Expr,
    args: ArgList
}

def new_call_expr(span: span.Span, callee: *Expr, args: ArgList): *Expr {
    return (new CallExpr {
        e: create_expr(EXPR_CALL, span),
        callee: callee,
        args: args
    }) as *Expr;
}

def is_call_expr(e: *Expr): bool {
    return e.tag == EXPR_CALL;
}

def as_call_expr(e: *Expr): *CallExpr {
    return e as *CallExpr;
}

/////////// Init expr ///////////

type InitExpr struct {
    e: Expr,
    struct_ty: *Expr,
    inits: InitList
}

def new_init_expr(span: span.Span, struct_ty: *Expr, inits: InitList): *Expr {
    return (new InitExpr {
        e: create_expr(EXPR_INIT, span),
        struct_ty: struct_ty,
        inits: inits
    }) as *Expr;
}

def is_init_expr(e: *Expr): bool {
    return e.tag == EXPR_INIT;
}

def as_init_expr(e: *Expr): *InitExpr {
    return e as *InitExpr;
}

/////////// assign expr ///////////

type AssignExpr struct {
    e: Expr,
    left: *Expr,
    right: *Expr
}

def new_assign_expr(span: span.Span, left: *Expr, right: *Expr): *Expr {
    return (new AssignExpr {
        e: create_expr(EXPR_ASSIGN, span),
        left: left,
        right: right
    }) as *Expr;
}

def is_assign_expr(e: *Expr): bool {
    return e.tag == EXPR_ASSIGN;
}

def as_assign_expr(e: *Expr): *AssignExpr {
    return e as *AssignExpr;
}

/////////// ident expr ///////////

type IdentExpr struct {
    e: Expr,
    ident: ident.Ident
}

def new_ident_expr(ident: lexer.Token): *Expr {
    return (new IdentExpr {
        e: create_expr(EXPR_IDENT, ident.span),
        ident: ident.create(ident)
    }) as *Expr;
}

def is_ident_expr(e: *Expr): bool {
    return e.tag == EXPR_IDENT;
}

def as_ident_expr(e: *Expr): *IdentExpr {
    return e as *IdentExpr;
}

/////////// int expr ///////////

// TODO: hex, oct ...
type IntExpr struct {
    e: Expr,
    ptr: string
}

def new_int_expr(span: span.Span, ptr: string): *Expr {
    return (new IntExpr {
        e: create_expr(EXPR_INT, span),
        ptr: ptr
    }) as *Expr;
}

def is_int_expr(e: *Expr): bool {
    return e.tag == EXPR_INT;
}

def as_int_expr(e: *Expr): *IntExpr {
    return e as *IntExpr;
}

/////////// string expr ///////////

type StringExpr struct {
    e: Expr,
    ptr: string
}

def new_string_expr(span: span.Span, ptr: string): *Expr {
    return (new StringExpr {
        e: create_expr(EXPR_STRING, span),
        ptr: ptr
    }) as *Expr;
}

def is_string_expr(e: *Expr): bool {
    return e.tag == EXPR_STRING;
}

def as_string_expr(e: *Expr): *StringExpr {
    return e as *StringExpr;
}

/////////// char expr ///////////

type CharExpr struct {
    e: Expr,
    ptr: string
}

def new_char_expr(span: span.Span, ptr: string): *Expr {
    return (new CharExpr {
        e: create_expr(EXPR_CHAR, span),
        ptr: ptr
    }) as *Expr;
}

def is_char_expr(e: *Expr): bool {
    return e.tag == EXPR_CHAR;
}

def as_char_expr(e: *Expr): *CharExpr {
    return e as *CharExpr;
}

/////////// binary expr ///////////

type BinaryExpr struct {
    e: Expr,
    left: *Expr,
    right: *Expr,
    kind: i32,
    op_span: span.Span
}

def new_binary_expr(
    span: span.Span,
    kind: i32,
    op_span: span.Span,
    left: *Expr,
    right: *Expr
): *Expr {
    return (new BinaryExpr {
        e: create_expr(EXPR_BINARY, span),
        left: left,
        right: right,
        kind: kind,
        op_span: op_span
    }) as *Expr;
}

def is_binary_expr(e: *Expr): bool {
    return e.tag == EXPR_BINARY;
}

def as_binary_expr(e: *Expr): *BinaryExpr {
    return e as *BinaryExpr;
}

/////////// unaryexpr ///////////

type UnaryExpr struct {
    e: Expr,
    kind: i32,
    right: *Expr
}

def new_unary_expr(span: span.Span, kind: i32, right: *Expr): *Expr {
    return (new UnaryExpr {
        e: create_expr(EXPR_UNARY, span),
        kind: kind,
        right: right
    }) as *Expr;
}

def is_unary_expr(e: *Expr): bool {
    return e.tag == EXPR_UNARY;
}

def as_unary_expr(e: *Expr): *UnaryExpr {
    return e as *UnaryExpr;
}

/////////// base expr ///////////

type Expr struct {
    tag: i32,
    ty: *ty.Type,
    span: span.Span
}

def create_expr(tag: i32, span: span.Span): Expr {
    return Expr { tag: tag, ty: null, span: span };
}

def expr_free(e: *Expr): void {
    if e == null {
        return;
    }

    if is_binary_expr(e) {
        let b_expr = as_binary_expr(e);
        expr_free(b_expr.left);
        expr_free(b_expr.right);
    } else if is_assign_expr(e) {
        let a_expr = as_assign_expr(e);
        expr_free(a_expr.left);
        expr_free(a_expr.right);
    } else if is_access_expr(e) {
        let a_expr = as_access_expr(e);
        expr_free(a_expr.left);
        expr_free(a_expr.right);
    } else if is_call_expr(e) {
        let c_expr = as_call_expr(e);
        expr_free(c_expr.callee);
        free_al(&c_expr.args);
    } else if is_init_expr(e) {
        let i_expr = as_init_expr(e);
        expr_free(i_expr.struct_ty);
        free_il(&i_expr.inits);
    } else if is_unary_expr(e) {
        expr_free(as_unary_expr(e).right);
    } else if is_as_expr(e) {
        expr_free(as_as_expr(e).expr);
    } else if is_new_expr(e) {
        expr_free(as_new_expr(e).expr);
    }

    delete e;
}

def expr_to_string(e: *Expr, span_interner: *span.SpanInterner): string {
    if e == null {
        return std.strdup("(nil)");
    }

    if is_int_expr(e) {
        let i_expr = as_int_expr(e);
        let len = span.get(span_interner, e.span).len;
        return std.strndup(i_expr.ptr, len);
    }

    if is_string_expr(e) {
        let s_expr = as_string_expr(e);
        let len = span.get(span_interner, e.span).len;
        // include the quotes
        return std.strndup(s_expr.ptr - 1, len + 2);
    }

    if is_char_expr(e) {
        let c_expr = as_char_expr(e);
        let len = span.get(span_interner, e.span).len;
        // include the quotes
        return std.strndup(c_expr.ptr - 1, len + 2);
    }

    if is_ident_expr(e) {
        let i_expr = as_ident_expr(e);
        return ident.to_string(&i_expr.ident, span_interner);
    }

    if is_new_expr(e) {
        let n_expr = as_new_expr(e);
        let expr_s = expr_to_string(n_expr.expr, span_interner);
        let s = std.format_str("new %s", expr_s);

        delete expr_s;
        return s;
    }

    if is_as_expr(e) {
        let a_expr = as_as_expr(e);
        let expr_s = expr_to_string(a_expr.expr, span_interner);
        let ty_s = tyid.to_string(&a_expr.ty, span_interner);
        let s = std.format_str("%s as %s", expr_s, ty_s);

        delete expr_s;
        delete ty_s;
        return s;
    }

    if is_assign_expr(e) {
        let a_expr = as_assign_expr(e);

        let left = expr_to_string(a_expr.left, span_interner);
        let right = expr_to_string(a_expr.right, span_interner);

        let s = std.format_str("%s = %s", left, right);
        delete left;
        delete right;

        return s;
    }

    if is_access_expr(e) {
        let a_expr = as_access_expr(e);

        let left = expr_to_string(a_expr.left, span_interner);
        let right = expr_to_string(a_expr.right, span_interner);

        let s = std.format_str("%s.%s", left, right);
        delete left;
        delete right;

        return s;
    }

    if is_unary_expr(e) {
        let u_expr = as_unary_expr(e);
        let right = expr_to_string(u_expr.right, span_interner);
        let tok_str = unary2str(u_expr.kind);

        let s = std.format_str("(%s%s)", tok_str, right);
        delete right;

        return s;
    }

    if is_binary_expr(e) {
        let b_expr = as_binary_expr(e);

        let left = expr_to_string(b_expr.left, span_interner);
        let right = expr_to_string(b_expr.right, span_interner);
        let tok_str = binary2str(b_expr.kind);

        let s = std.format_str("(%s%s%s)", left, tok_str, right);
        delete left;
        delete right;

        return s;
    }

    if is_call_expr(e) {
        let c_expr = as_call_expr(e);

        let ident = expr_to_string(c_expr.callee, span_interner);
        let args = arg_list_to_string(&c_expr.args, span_interner);

        let s = std.format_str("%s(%s)", ident, args);
        delete ident;
        delete args;

        return s;
    }

    if is_init_expr(e) {
        let i_expr = as_init_expr(e);

        let ident = expr_to_string(i_expr.struct_ty, span_interner);
        let inits = init_list_to_string(&i_expr.inits, span_interner);

        let s = std.format_str("%s{%s}", ident, inits);
        delete ident;
        delete inits;

        return s;
    }

    return null;
}

/////////// ArgList ///////////
// TODO: should be in own file, but can't because compiler can't handle circular imports

type ArgList struct {
    args: ptrvec.Vec
}

def create_arg_list(): ArgList {
    return ArgList { args: ptrvec.create() };
}

def num_args(al: *ArgList): i32 {
    return al.args.len;
}

def get_arg_at(al: *ArgList, i: i32): *ast.Expr {
    return ptrvec.get(&al.args, i) as *ast.Expr;
}

def set_arg_at(al: *ArgList, i: i32, expr: *ast.Expr): void {
    ptrvec.set(&al.args, i, expr as *void);
}

def push_arg(al: *ArgList, arg: *ast.Expr): void {
    ptrvec.push_ptr(&al.args, arg as *void);
}

def free_al(al: *ArgList): void {
    let i = 0;
    while i < al.args.len {
        let e = ptrvec.get(&al.args, i) as *ast.Expr;
        ast.expr_free(e);
        i = i + 1;
    }

    ptrvec.free_v(&al.args);
}

def arg_list_to_string(al: *ArgList, span_interner: *span.SpanInterner): string {
    let args = (new '\0') as string;

    let i = 0;
    while i < al.args.len {
        let a = get_arg_at(al, i);
        let s = expr_to_string(a, span_interner);

        let comma_len = 0;
        if i > 0 {
            comma_len = 2;
        }

        let new_len = std.strlen(args) + std.strlen(s) + 1 + comma_len;
        let new_args = std.malloc(new_len) as string;
        let old_args = args;
        args = std.strcpy(new_args, args);
        delete old_args;

        if comma_len > 0 {
            args = std.strcat(args, ", ");
        }

        args = std.strcat(args, s);
        delete s;

        i = i + 1;
    }

    return args;
}

/////////// InitList ///////////
// TODO: should be in own file, but can't because compiler can'e handle circular imports

type Init struct {
    ident: ident.Ident,
    expr: *Expr
}

def create_init(ident: ident.Ident, expr: *Expr): Init {
    return Init { ident: ident, expr: expr };
}

def empty_init(): Init {
    return Init { ident: ident.empty(), expr: null };
}

type InitList struct {
    inits: vec.Vec
}

def create_init_list(): InitList {
    return InitList { inits: vec.create(sizeof Init) };
}

def num_inits(il: *InitList): i32 {
    return il.inits.len;
}

def get_init_expr_at(il: *InitList, i: i32): *Expr {
    let init = empty_init();
    if !get_init_at(il, i, &init) {
        return null;
    }
    return init.expr;
}

def get_init_at(il: *InitList, i: i32, dest: *Init): bool {
    return vec.get(&il.inits, i, dest as *void);
}

def push_init(il: *InitList, init: Init): void {
    vec.push(&il.inits, &init as *void);
}

def free_il(il: *InitList): void {
    let i = 0;
    while i < il.inits.len {
        let init = empty_init();
        get_init_at(il, i, &init);
        ast.expr_free(init.expr);
        i = i + 1;
    }

    vec.free_v(&il.inits);
}

def init_list_to_string(il: *InitList, span_interner: *span.SpanInterner): string {
    let inits = (new '\0') as string;

    let i = 0;
    while i < il.inits.len {
        let init = empty_init();
        if !get_init_at(il, i, &init) {
            delete inits;
            return null;
        }
        let n = ident.to_string(&init.ident, span_interner);
        let e = expr_to_string(init.expr, span_interner);

        let extra_len = 2; // ': '
        if i > 0 {
            extra_len = 4; // ': ..., '
        }

        let new_len = std.strlen(inits) + std.strlen(n) + std.strlen(e) + 1 + extra_len;
        let new_inits = std.malloc(new_len) as string;
        let old_inits = inits;
        inits = std.strcpy(new_inits, inits);
        delete old_inits;

        if extra_len > 2 {
            inits = std.strcat(inits, ", ");
        }

        inits = std.strcat(inits, n);
        inits = std.strcat(inits, ": ");
        inits = std.strcat(inits, e);
        delete n;
        delete e;

        i = i + 1;
    }

    return inits;
}
