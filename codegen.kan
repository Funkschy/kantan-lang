#include "std.h"

import "io";
import "ty";
import "dbg";
import "mod";
import "mir";
import "map";
import "std";
import "llvm";
import "ident";
import "ptrvec";

// stuff that outlives the ModuleCompiler
type ModuleContext struct {
    ctx: *llvm.Context,
    llmod: *llvm.Module
}

type ModuleCompiler struct {
    context: ModuleContext,
    irmod: *mir.Module,
    builder: *llvm.Builder,
    structs: map.Map, // map.Map<mir.RefName, *llvm.Type>
    functions: map.Map, // map.Map<mir.RefName, *llvm.Type>
    allocated_strings: ptrvec.Vec // ptrvec.Vec<string>
}

def create_compiler(irmod: *mir.Module): ModuleCompiler {
    // since this can run in parallel, but llvm.Context is not threadsafe,
    // we need a separate context per module
    let ctx = llvm.context_create();
    let llmod = llvm.module_create_with_name_in_context(irmod.actual.name.data, ctx);
    let path = mod.get_path(irmod.actual);
    llvm.set_source_file_name(llmod, path.inner, path.len);

    let builder = llvm.create_builder_in_context(ctx);

    return ModuleCompiler {
        context: ModuleContext { ctx: ctx, llmod: llmod },
        irmod: irmod,
        builder: builder,
        structs: map.create(),
        functions: map.create(),
        allocated_strings: ptrvec.create()
    };
}

def free_compiler(c: *ModuleCompiler): void {
    llvm.dispose_builder(c.builder);

    let i = 0;
    while i < c.allocated_strings.len {
        delete ptrvec.get(&c.allocated_strings, i);
        i = i + 1;
    }

    map.free_m(&c.structs);
    map.free_m(&c.functions);
    ptrvec.free_v(&c.allocated_strings);
}

def free_context(ctx: *ModuleContext): void {
    llvm.dispose_module(ctx.llmod);
    llvm.context_dispose(ctx.ctx);
}

def compile_mir_mod(irmod: *mir.Module): ModuleContext {
    let compiler = create_compiler(irmod);

    add_forward_declarations(&compiler);
    compile_functions(&compiler);

    let context = compiler.context;
    free_compiler(&compiler);
    return context;
}

def push_allocated_string(c: *ModuleCompiler, s: string): void {
    ptrvec.push_ptr(&c.allocated_strings, s as *void);
}

def add_forward_declarations(c: *ModuleCompiler): void {
    // add struct declarations
    let s_iter = map.iter(&c.irmod.structs);
    let item = map.iter_next(&s_iter);
    while item != null {
        let s = item.value as *mir.Struct;
        lookup_or_declare_struct(c, s.ty);
        item = map.iter_next(&s_iter);
    }

    // add globals
    let g_iter = map.iter(&c.irmod.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let gc = item.value as *mir.GlobalConst;
        item = map.iter_next(&g_iter);
    }

    // add function declarations
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        lookup_or_declare_function(c, f.ty);
        item = map.iter_next(&f_iter);
    }

}

def lookup_or_declare_function(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    dbg.assert(ty.is_func(t), "non func type passed");
    let f_ty = ty.as_func(t);

    let key = map.create_key(f_ty.mangled_name.len, f_ty.mangled_name.data);
    let func_decl = map.get(&c.functions, key) as *llvm.Type;

    if func_decl == null {
        let num_params = f_ty.params.len;
        let params = ptrvec.with_cap(num_params);

        let i = 0;
        while i < num_params {
            let param = ty.param_at(f_ty, i);

            let param_ty = convert_type(c, param.ty);
            ptrvec.push_ptr(&params, param_ty as *void);

            i = i + 1;
        }

        let ret_ty = convert_type(c, f_ty.ret);

        let param_types = params.elements as **llvm.Type;
        func_decl = llvm.function_type(ret_ty, param_types, num_params, false);
        ptrvec.free_v(&params);

        let name = f_ty.mangled_name.data;
        io.printf("declaring %s\n", name);
        llvm.add_function(c.context.llmod, name, func_decl);
        map.insert(&c.functions, key, func_decl as *void);
    }

    return func_decl;
}

def lookup_or_declare_struct(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    dbg.assert(ty.is_struct(t), "non struct type passed");
    let s_ty = ty.as_struct(t);

    let key = map.create_key(s_ty.mangled_name.len, s_ty.mangled_name.data);
    let struct_decl = map.get(&c.structs, key) as *llvm.Type;

    if struct_decl == null {
        let num_fields = ty.num_fields(s_ty);
        let fields = ptrvec.with_cap(num_fields);

        let name = s_ty.mangled_name.data;
        struct_decl = llvm.struct_create_named(c.context.ctx, name);
        map.insert(&c.structs, key, struct_decl as *void);

        let i = 0;
        while i < num_fields {
            let field = ty.field_at(s_ty, i);

            let field_ty = convert_type(c, field.ty);
            ptrvec.push_ptr(&fields, field_ty as *void);

            i = i + 1;
        }

        let field_types = fields.elements as **llvm.Type;
        llvm.struct_set_body(struct_decl, field_types, num_fields, false);
        ptrvec.free_v(&fields);
    }

    return struct_decl;
}

def convert_type(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    if ty.is_i32(t) {
        return llvm.int32_type_in_context(c.context.ctx);
    }

    if ty.is_void(t) {
        return llvm.void_type_in_context(c.context.ctx);
    }

    if ty.is_f32(t) {
        return llvm.float_type_in_context(c.context.ctx);
    }

    if ty.is_bool(t) {
        return llvm.int1_type_in_context(c.context.ctx);
    }

    if ty.is_char(t) {
        return llvm.int8_type_in_context(c.context.ctx);
    }

    if ty.is_string(t) {
        return llvm.pointer_type(llvm.int8_type_in_context(c.context.ctx), 0);
    }

    if ty.is_struct(t) {
        return lookup_or_declare_struct(c, t);
    }

    if ty.is_ptr(t) {
        let p_ty = ty.as_ptr(t);
        let t: *llvm.Type = null;
        if ty.is_void(p_ty.inner) {
            // llvm does not have a void pointer type
            t = llvm.int8_type_in_context(c.context.ctx);
        } else {
            t = convert_type(c, p_ty.inner);
        }

        let i = 0;
        while i < p_ty.count {
            t = llvm.pointer_type(t, 0);
            i = i + 1;
        }

        return t;
    }

    dbg.assert_fmt(false, "unhandled type %d", t.kind);
    return null;
}

def compile_functions(c: *ModuleCompiler): void {
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        compile_function(c, f);
        item = map.iter_next(&f_iter);
    }
}

def compile_function(c: *ModuleCompiler, func: *mir.Func): void {
    if func.is_extern {
        return;
    }

    let llvm_func_ty = lookup_or_declare_function(c, func.ty);
    dbg.assert_fmt(
        llvm_func_ty != null, "function type not found %s", func.name.data
    );

    let llvm_func = llvm.get_named_function(c.context.llmod, func.name.data);
    dbg.assert_fmt(llvm_func!= null, "function not found %s", func.name.data);

    llvm.append_basic_block_in_context(c.context.ctx, llvm_func, "entry");
}
