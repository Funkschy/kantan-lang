#include "std.h"

import "io";
import "ty";
import "dbg";
import "mod";
import "mir";
import "map";
import "std";
import "llvmc";
import "name";
import "ident";
import "ptrvec";

// stuff that outlives the ModuleCompiler
type ModuleContext struct {
    ctx: *llvmc.Context,
    llmod: *llvmc.Module
}

type ModuleCompiler struct {
    context: ModuleContext,
    irmod: *mir.Module,
    builder: *llvmc.Builder,
    structs: map.Map, // map.Map<mir.RefName, *llvmc.Type>
    functions: map.Map, // map.Map<mir.RefName, *llvmc.Type>
    allocated_strings: ptrvec.Vec // ptrvec.Vec<string>
}

def create_compiler(irmod: *mir.Module, ctx: *llvmc.Context): ModuleCompiler {
    // ctx is only null, if we want to use multiple threads
    if ctx == null {
        // since this can run in parallel, but llvmc.Context is not threadsafe,
        // we need a separate context per module
        ctx = llvmc.context_create();
    }
    let llmod = llvmc.module_create_with_name_in_context(irmod.actual.name.data, ctx);
    let path = mod.get_path(irmod.actual);
    llvmc.set_source_file_name(llmod, path.inner, path.len);

    let builder = llvmc.create_builder_in_context(ctx);

    return ModuleCompiler {
        context: ModuleContext { ctx: ctx, llmod: llmod },
        irmod: irmod,
        builder: builder,
        structs: map.create(),
        functions: map.create(),
        allocated_strings: ptrvec.create()
    };
}

def free_compiler(c: *ModuleCompiler): void {
    llvmc.dispose_builder(c.builder);

    let i = 0;
    while i < c.allocated_strings.len {
        delete ptrvec.get(&c.allocated_strings, i);
        i = i + 1;
    }

    map.free_m(&c.structs);
    map.free_m(&c.functions);
    ptrvec.free_v(&c.allocated_strings);
}

def free_context(ctx: *ModuleContext): void {
    llvmc.dispose_module(ctx.llmod);
    llvmc.context_dispose(ctx.ctx);
}

// if the context is null, a new one will be created for this module
def compile_mir_mod(irmod: *mir.Module, global_ctx: *llvmc.Context): ModuleContext {
    let compiler = create_compiler(irmod, global_ctx);

    add_forward_declarations(&compiler);
    compile_functions(&compiler);

    let context = compiler.context;
    free_compiler(&compiler);
    return context;
}

def push_allocated_string(c: *ModuleCompiler, s: string): void {
    ptrvec.push_ptr(&c.allocated_strings, s as *void);
}

def add_forward_declarations(c: *ModuleCompiler): void {
    // add struct declarations
    let s_iter = map.iter(&c.irmod.structs);
    let item = map.iter_next(&s_iter);
    while item != null {
        let s = item.value as *mir.Struct;
        lookup_or_declare_struct(c, s.ty);
        item = map.iter_next(&s_iter);
    }

    // add globals
    let g_iter = map.iter(&c.irmod.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let gc = item.value as *mir.GlobalConst;
        add_global_const(c, gc);
        item = map.iter_next(&g_iter);
    }

    // add function declarations
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        lookup_or_declare_function(c, f.ty);
        item = map.iter_next(&f_iter);
    }
}

def add_global_const(c: *ModuleCompiler, gc: *mir.GlobalConst): void {
    dbg.assert(ty.is_string(gc.ty), "we currently only support string literals");
    let len = gc.value.len + 1; // 1 for null terminator
    let ty = llvmc.array_type(llvmc.int8_type_in_context(c.context.ctx), len);

    let global_storage = llvmc.add_global(c.context.llmod, ty, gc.name.data);
    llvmc.set_global_constant(global_storage, true);
    let private_linkage = 15;
    llvmc.set_linkage(global_storage, private_linkage);
    // Address of the string is globally insignificant
    let global_unnamed_address = 2;
    llvmc.set_unnamed_address(global_storage, global_unnamed_address);

    let null_terminate = true;
    let const_string = llvmc.const_string_in_context(
        c.context.ctx,
        gc.value.data,
        gc.value.len,
        !null_terminate
    );
    llvmc.set_initializer(global_storage, const_string);
}

def lookup_or_declare_function(c: *ModuleCompiler, t: *ty.Type): *llvmc.Type {
    dbg.assert(ty.is_func(t), "non func type passed");
    let f_ty = ty.as_func(t);

    let key = map.create_key(f_ty.mangled_name.len, f_ty.mangled_name.data);
    let func_decl = map.get(&c.functions, key) as *llvmc.Type;

    if func_decl == null {
        let num_params = f_ty.params.len;
        let params = ptrvec.with_cap(num_params);

        let i = 0;
        while i < num_params {
            let param = ty.param_at(f_ty, i);

            let param_ty = translate_type(c, param.ty);
            ptrvec.push_ptr(&params, param_ty as *void);

            i = i + 1;
        }

        let ret_ty = translate_type(c, f_ty.ret);

        let param_types = params.elements as **llvmc.Type;
        func_decl = llvmc.function_type(
            ret_ty, param_types, num_params, f_ty.is_varargs
        );
        ptrvec.free_v(&params);

        let name = f_ty.mangled_name.data;
        llvmc.add_function(c.context.llmod, name, func_decl);
        map.insert(&c.functions, key, func_decl as *void);
    }

    return func_decl;
}

def lookup_or_declare_struct(c: *ModuleCompiler, t: *ty.Type): *llvmc.Type {
    dbg.assert(ty.is_struct(t), "non struct type passed");
    let s_ty = ty.as_struct(t);

    let key = map.create_key(s_ty.mangled_name.len, s_ty.mangled_name.data);
    let struct_decl = map.get(&c.structs, key) as *llvmc.Type;

    if struct_decl == null {
        let num_fields = ty.num_fields(s_ty);
        let fields = ptrvec.with_cap(num_fields);

        let name = s_ty.mangled_name.data;
        struct_decl = llvmc.struct_create_named(c.context.ctx, name);
        map.insert(&c.structs, key, struct_decl as *void);

        let i = 0;
        while i < num_fields {
            let field = ty.field_at(s_ty, i);

            let field_ty = translate_type(c, field.ty);
            ptrvec.push_ptr(&fields, field_ty as *void);

            i = i + 1;
        }

        let field_types = fields.elements as **llvmc.Type;
        llvmc.struct_set_body(struct_decl, field_types, num_fields, false);
        ptrvec.free_v(&fields);
    }

    return struct_decl;
}

def translate_type(c: *ModuleCompiler, t: *ty.Type): *llvmc.Type {
    if ty.is_i32(t) {
        return llvmc.int32_type_in_context(c.context.ctx);
    }

    if ty.is_void(t) {
        return llvmc.void_type_in_context(c.context.ctx);
    }

    if ty.is_f32(t) {
        return llvmc.float_type_in_context(c.context.ctx);
    }

    if ty.is_bool(t) {
        return llvmc.int1_type_in_context(c.context.ctx);
    }

    if ty.is_char(t) {
        return llvmc.int8_type_in_context(c.context.ctx);
    }

    if ty.is_string(t) {
        return llvmc.pointer_type(llvmc.int8_type_in_context(c.context.ctx), 0);
    }

    if ty.is_struct(t) {
        return lookup_or_declare_struct(c, t);
    }

    if ty.is_ptr(t) {
        let p_ty = ty.as_ptr(t);
        let t: *llvmc.Type = null;
        if ty.is_void(p_ty.inner) {
            // llvm does not have a void pointer type
            t = llvmc.int8_type_in_context(c.context.ctx);
        } else {
            t = translate_type(c, p_ty.inner);
        }

        let i = 0;
        while i < p_ty.count {
            t = llvmc.pointer_type(t, 0);
            i = i + 1;
        }

        return t;
    }

    dbg.assert_fmt(false, "unhandled type %d", t.kind);
    return null;
}

def translate_addr(
    c: *ModuleCompiler,
    curr_func: *FunctionData,
    a: *mir.Address
): *llvmc.Value {
    return translate_addr_load(c, curr_func, a, true);
}

def translate_addr_load(
    c: *ModuleCompiler,
    curr_func: *FunctionData,
    a: *mir.Address,
    load: bool
): *llvmc.Value {
    if mir.is_addr_name(a) {
        let addr_name = mir.as_addr_name(a);
        let variable = variable_by_name(curr_func, addr_name.value);

        if load {
            dbg.assert_fmt(
                variable != null, "variable %s was null", addr_name.value.data
            );
            return llvmc.build_load(c.builder, variable, "");
        }

        return variable;
    }

    if mir.is_addr_ref(a) {
        let ref = mir.as_addr_ref(a);
        return variable_by_name(curr_func, ref.name);
    }

    if mir.is_addr_const(a) {
        let constant = mir.as_addr_const(a);
        return translate_literal(c, constant.start, constant.end, a.ty);
    }

    if mir.is_addr_global(a) {
        let name = mir.as_addr_global(a).name;
        let global = llvmc.get_named_global(c.context.llmod, name.data);

        let gep = llvmc.build_gep(c.builder, global, null, 0, "");
        let ty = translate_type(c, a.ty);
        return llvmc.build_pointer_cast(c.builder, gep, ty, "");
    }

    if mir.is_addr_arg(a) {
        let get_arg = mir.as_addr_arg(a);
        return llvmc.get_param(curr_func.llfunc, get_arg.idx);
    }

    if mir.is_addr_null(a) {
        return llvmc.const_null(translate_type(c, a.ty));
    }

    dbg.assert_fmt(false, "invalid address kind %d", a.kind);
    return null;
}

def translate_literal(
    c: *ModuleCompiler,
    start: string,
    end: string,
    t: *ty.Type
): *llvmc.Value {
    let llvm_ty = translate_type(c, t);

    if ty.is_char(t) {
        let int_value = std.char_to_int(*start);
        return llvmc.const_int(llvm_ty, int_value, false);
    }

    if ty.is_bool(t) {
        let int_value = std.char_to_int(*start) - std.char_to_int('0');
        return llvmc.const_int(llvm_ty, int_value, false);
    }

    let copy = std.strndup(start, end - start);
    let llvm_lit: *llvmc.Value = null;

    if ty.is_i32(t) {
        llvm_lit = llvmc.const_int_of_string(llvm_ty, copy, 10);
    }

    if ty.is_f32(t) {
        llvm_lit = llvmc.const_real_of_string(llvm_ty, copy);
    }

    delete copy;
    return llvm_lit;
}

def compile_functions(c: *ModuleCompiler): void {
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        compile_function(c, f);
        item = map.iter_next(&f_iter);
    }
}

type FunctionData struct {
    llfunc: *llvmc.Value,
    irfunc: *mir.Func,
    blocks: map.Map, // map.Map<RefName, *llvmc.BasicBlock>
    locals: map.Map // map.Map<Refname, *llvmc.Value>
}

def create_function_data(
    c: *ModuleCompiler,
    llfunc: *llvmc.Value,
    irfunc: *mir.Func
): FunctionData {
    let num_blocks = mir.bm_num_blocks(&irfunc.blocks);
    let blocks = map.with_cap(num_blocks);

    let entry_block: *llvmc.BasicBlock = null;

    let i = 0;
    while i < num_blocks {
        let mir_bb = mir.bm_get_bb_ptr(&irfunc.blocks, i);
        let bb_name = name.ref(mir_bb.label.name);
        let llvm_bb = llvmc.append_basic_block_in_context(
            c.context.ctx, llfunc, bb_name.data
        );

        if entry_block == null {
            entry_block = llvm_bb;
        }

        let key = map.create_key(bb_name.len, bb_name.data);
        map.insert(&blocks, key, llvm_bb as *void);
        i = i + 1;
    }

    let num_locals = irfunc.blocks.decls.len;
    let locals = map.with_cap(num_locals);

    // compile variable declarations for the entire function
    llvmc.position_builder_at_end(c.builder, entry_block);
    i = 0;
    while i < num_locals {
        let inst_decl = mir.bm_decl_at(&irfunc.blocks, i);
        dbg.assert(mir.is_inst_decl(&inst_decl), "expected a declaration");

        let decl = mir.as_inst_decl(&inst_decl);
        let ty = translate_type(c, decl.ty);

        // taking the name.data should be safe, since this is name.Ref, points
        // to the same string as the corresponding name.Owned inside the
        // NameTable, which has to be null terminated, since it's a name.Owned
        let value_ptr = llvmc.build_alloca(c.builder, ty, decl.name.data);
        let key = map.create_key(decl.name.len, decl.name.data);
        map.insert(&locals, key, value_ptr as *void);

        i = i + 1;
    }

    return FunctionData {
        llfunc: llfunc,
        irfunc: irfunc,
        blocks: blocks,
        locals: locals
    };
}

def free_function_data(f: *FunctionData): void {
    map.free_m(&f.blocks);
    map.free_m(&f.locals);
}

def bb_by_label(f: *FunctionData, label: *mir.Label): *llvmc.BasicBlock {
    let bb_name = mir.label_name(label);
    let key = map.create_key(bb_name.len, bb_name.data);
    return map.get(&f.blocks, key) as *llvmc.BasicBlock;
}

def variable_by_name(f: *FunctionData, var_name: name.Ref): *llvmc.Value {
    let key = map.create_key(var_name.len, var_name.data);
    let value = map.get(&f.locals, key) as *llvmc.Value;
    return value;
}

def add_variable(f: *FunctionData, var_name: name.Ref, value: *llvmc.Value): void {
    let key = map.create_key(var_name.len, var_name.data);
    map.insert(&f.locals, key, value as *void);
}

def compile_function(c: *ModuleCompiler, func: *mir.Func): void {
    let llvm_func_ty = lookup_or_declare_function(c, func.ty);
    dbg.assert_fmt(
        llvm_func_ty != null, "function type not found %s", func.name.data
    );

    if func.is_extern {
        return;
    }

    let llvm_func = llvmc.get_named_function(c.context.llmod, func.name.data);
    dbg.assert_fmt(llvm_func!= null, "function not found %s", func.name.data);

    let func_data = create_function_data(c, llvm_func, func);

    let i = 0;
    while i < func_data.blocks.len {
        let bb = mir.bm_get_bb_ptr(&func.blocks, i);
        compile_bb(c, &func_data, bb);
        i = i + 1;
    }

    free_function_data(&func_data);
}

def compile_bb(c: *ModuleCompiler, func: *FunctionData, bb: *mir.BasicBlock): void {
    let llvm_bb = bb_by_label(func, &bb.label);
    llvmc.position_builder_at_end(c.builder, llvm_bb);

    let i = 0;
    let n = mir.bb_num_instr(bb);
    while i < n {
        let inst = mir.bb_get_instr(bb, i);
        compile_inst(c, func, inst);
        i = i + 1;
    }

    compile_inst(c, func, &bb.terminator);
}

def compile_inst(c: *ModuleCompiler, func: *FunctionData, inst: *mir.Inst): void {
    if mir.is_inst_assign(inst) {
        let assign = mir.as_inst_assign(inst);

        if mir.is_expr_struct_init(&assign.value) {
            compile_struct_init_assign(c, func, assign);
            return;
        }

        let value = compile_expr(c, func, &assign.value);
        dbg.assert(value != null, "value was null");

        if mir.is_addr_empty(&assign.dest) {
            // Only void calls generate empty addresses. The typechecker does
            // not allow them to be assigned or used in any way, but the mir
            // generates assign instructions for every expression, so we return
            // here, to make sure that no actual assign is generated for the
            // result of a void function call
            return;
        }

        let storage = translate_addr_load(c, func, &assign.dest, false);

        // this is only a temporary variable, that does not need stack space
        if storage == null {
            dbg.assert(
                mir.is_addr_name(&assign.dest), "names are the only nullable address"
            );
            let addr_name = mir.as_addr_name(&assign.dest);
            add_variable(func, addr_name.value, value);
            return;
        }

        // this is a declared variable
        llvmc.build_store(c.builder, value, storage);
        return;
    }

    if mir.is_inst_jmp(inst) {
        let jmp = mir.as_inst_jmp(inst);
        let target_bb = bb_by_label(func, &jmp.target);
        llvmc.build_br(c.builder, target_bb);
        return;
    }

    if mir.is_inst_jmpif(inst) {
        let jmp = mir.as_inst_jmpif(inst);

        let if_target_bb = bb_by_label(func, &jmp.if_target);
        let else_target_bb = bb_by_label(func, &jmp.else_target);
        let condition = translate_addr(c, func, &jmp.condition);

        llvmc.build_cond_br(c.builder, condition, if_target_bb, else_target_bb);
        return;
    }

    if mir.is_inst_return(inst) {
        let ret = mir.as_inst_return(inst);
        if mir.is_addr_empty(&ret.value) {
            llvmc.build_ret_void(c.builder);
            return;
        }

        let value = translate_addr(c, func, &ret.value);
        llvmc.build_ret(c.builder, value);
        return;
    }

    if mir.is_inst_delete(inst) {
        let del = mir.as_inst_delete(inst);
        let addr = translate_addr(c, func, &del.addr);
        llvmc.build_free(c.builder, addr);
        return;
    }

    dbg.assert_fmt(false, "invalid instruction kind %d", inst.kind);
}

def compile_struct_init_assign(
    c: *ModuleCompiler,
    func: *FunctionData,
    assign: *mir.InstAssign
): void {
    let init = mir.as_expr_struct_init(&assign.value);

    let dest_ty = translate_type(c, assign.dest.ty);
    let storage = translate_addr_load(c, func, &assign.dest, false);
    dbg.assert(storage != null, "null storage for struct init");

    // I don't really know, if we actually want to do this
    //
    // let zero = llvmc.const_int(llvmc.int8_type_in_context(c.context.ctx), 0, false);
    // let len = llvmc.size_of(dest_ty);
    // let align = llvmc.get_alignment(storage);
    // llvmc.build_mem_set(c.builder, storage, zero, len, align);

    let i = 0;
    while i < init.args.len {
        let arg = mir.init_arg_at(init, i);
        let arg_addr = translate_addr(c, func, arg);

        let field = llvmc.build_struct_gep(c.builder, storage, i, "");
        llvmc.build_store(c.builder, arg_addr, field);

        i = i + 1;
    }
}

def compile_expr(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvmc.Value {
    if mir.is_expr_copy(e) {
        let copy = mir.as_expr_copy(e);
        return translate_addr(c, func, &copy.addr);
    }

    if mir.is_expr_unary(e) {
        return compile_unary(c, func, e);
    }

    if mir.is_expr_binary(e) {
        return compile_binary(c, func, e);
    }

    if mir.is_expr_call(e) {
        return compile_call(c, func, e);
    }

    if mir.is_expr_gep(e) {
        let gep = mir.as_expr_gep(e);
        let addr = translate_addr_load(c, func, &gep.addr, false);
        return llvmc.build_struct_gep(c.builder, addr, gep.idx, "");
    }

    if mir.is_expr_bitcast(e) {
        let cast = mir.as_expr_bitcast(e);
        let addr = translate_addr(c, func, &cast.addr);
        let into = translate_type(c, cast.into);
        return llvmc.build_bit_cast(c.builder, addr, into, "");
    }

    if mir.is_expr_new(e) {
        let new_e = mir.as_expr_new(e);
        let addr = translate_addr_load(c, func, &new_e.addr, false);
        let ty = translate_type(c, new_e.addr.ty);

        let storage = llvmc.build_malloc(c.builder, ty, "");
        let align = llvmc.get_alignment(addr);
        let size = llvmc.size_of(ty);
        llvmc.build_mem_cpy(c.builder, storage, align, addr, align, size);

        return storage;
    }

    if mir.is_expr_sizeof(e) {
        let so = mir.as_expr_sizeof(e);
        let ty = translate_type(c, so.ty);

        // TODO: remove when u64 is supported
        return llvmc.build_int_cast(
            c.builder,
            llvmc.size_of(ty),
            llvmc.int32_type_in_context(c.context.ctx),
            ""
        );
    }

    dbg.assert_fmt(false, "invalid expression kind %d", e.kind);
    return null;
}

def compile_unary(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvmc.Value {
    let unary = mir.as_expr_unary(e);
    let value = translate_addr(c, func, &unary.addr);

    if mir.is_unary_deref(unary) {
        // was already loaded
        return value;
    }

    if mir.is_unary_num_neg(unary) {
        return llvmc.build_neg(c.builder, value, "");
    }

    if mir.is_unary_bool_neg(unary) {
        return llvmc.build_not(c.builder, value, "");
    }

    dbg.assert_fmt(false, "Invalid unary kind: %d", unary.kind);
    return null;
}

#include "mir_types.h"
def compile_binary(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvmc.Value {
    let binary = mir.as_expr_binary(e);

    if ty.is_f32(binary.left.ty) {
        return compile_binary_float(c, func, binary);
    }

    let left = translate_addr(c, func, &binary.left);
    let right = translate_addr(c, func, &binary.right);

    if binary.kind == MIR_BIN_ADD {
        return llvmc.build_add(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_SUB {
        // pointer subtraction (both types have to be equal for MIR_BIN_SUB)
        if ty.is_ptr_type(binary.left.ty) {
            let int64_ty = llvmc.int64_type_in_context(c.context.ctx);
            left = llvmc.build_ptr_to_int(c.builder, left, int64_ty, "");
            right = llvmc.build_ptr_to_int(c.builder, right, int64_ty, "");

            let sub = llvmc.build_sub(c.builder, left, right, "");
            let int32_ty = llvmc.int32_type_in_context(c.context.ctx);
            // we currently only support i32, so we need to cast the result
            // this is safer than casting the pointers separately i think
            return llvmc.build_int_cast(c.builder, sub, int32_ty, "");
        }

        return llvmc.build_sub(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MUL {
        return llvmc.build_mul(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_DIV {
        return llvmc.build_s_div(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MOD {
        // TODO: this is actually a remainder operation, not modulo
        //  same for floats
        return llvmc.build_s_rem(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_ST {
        // TODO: unsigned integer types
        return llvmc.build_i_cmp(c.builder, 40, left, right, "");
    } else if binary.kind == MIR_BIN_SE {
        return llvmc.build_i_cmp(c.builder, 41, left, right, "");
    } else if binary.kind == MIR_BIN_GT {
        return llvmc.build_i_cmp(c.builder, 38, left, right, "");
    } else if binary.kind == MIR_BIN_GE {
        return llvmc.build_i_cmp(c.builder, 39, left, right, "");
    } else if binary.kind == MIR_BIN_EQ {
        return llvmc.build_i_cmp(c.builder, 32, left, right, "");
    } else if binary.kind == MIR_BIN_NE {
        return llvmc.build_i_cmp(c.builder, 33, left, right, "");
    } else if binary.kind == MIR_BIN_BOOL_AND {
        return llvmc.build_and(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_BOOL_OR {
        return llvmc.build_or(c.builder, left, right, "");
    } else {
        let ptr = left;
        let scalar = right;
        if ty.is_ptr_type(binary.right.ty) {
            ptr = right;
            scalar = left;
        }

        // for ptr - scalar, just negate the scalar value
        if binary.kind == MIR_BIN_SUB_SCALAR {
            scalar = llvmc.build_neg(c.builder, scalar, "");
        }

        return llvmc.build_in_bounds_gep(c.builder, ptr, &scalar, 1, "");
    }

    dbg.assert_fmt(false, "Invalid binary kind: %d", binary.kind);
    return null;
}

def compile_binary_float(
    c: *ModuleCompiler,
    func: *FunctionData,
    binary: *mir.ExprBinary
): *llvmc.Value {
    let left = translate_addr(c, func, &binary.left);
    let right = translate_addr(c, func, &binary.right);

    if binary.kind == MIR_BIN_ADD {
        return llvmc.build_f_add(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_SUB {
        return llvmc.build_f_sub(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MUL {
        return llvmc.build_f_mul(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_DIV {
        return llvmc.build_f_div(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MOD {
        return llvmc.build_f_rem(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_ST {
        return llvmc.build_f_cmp(c.builder, 4, left, right, "");
    } else if binary.kind == MIR_BIN_SE {
        return llvmc.build_f_cmp(c.builder, 5, left, right, "");
    } else if binary.kind == MIR_BIN_GT {
        return llvmc.build_f_cmp(c.builder, 2, left, right, "");
    } else if binary.kind == MIR_BIN_GE {
        return llvmc.build_f_cmp(c.builder, 3, left, right, "");
    } else if binary.kind == MIR_BIN_EQ {
        return llvmc.build_f_cmp(c.builder, 1, left, right, "");
    } else if binary.kind == MIR_BIN_NE {
        return llvmc.build_f_cmp(c.builder, 6, left, right, "");
    }

    dbg.assert_fmt(false, "Invalid binary float kind: %d", binary.kind);
    return null;
}

def compile_call(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvmc.Value {
    let call = mir.as_expr_call(e);
    // TODO: we need to change this, when introducing function pointers
    dbg.assert(mir.is_addr_name(&call.callee), "callee should be name");
    let callee_name = mir.as_addr_name(&call.callee).value;
    let llvm_func = llvmc.get_named_function(c.context.llmod, callee_name.data);
    dbg.assert(llvm_func != null, "llvm function not found");

    let num_args = call.args.len;
    let args = ptrvec.with_cap(num_args);
    let i = 0;
    while i < num_args {
        let arg = mir.call_arg_at(call, i);
        let value = translate_addr(c, func, arg);

        if call.varargs {
            // If a float is passed as an argument to a variadic function,
            // it has to be promoted to a double implicitly
            if ty.is_f32(arg.ty) {
                // convert f32 to f64
                let f64_ty = llvmc.double_type_in_context(c.context.ctx);
                value = llvmc.build_fp_ext(c.builder, value, f64_ty, "");
            }
        }

        ptrvec.push_ptr(&args, value as *void);
        i = i + 1;
    }

    let arg_values = args.elements as **llvmc.Value;
    let call = llvmc.build_call(c.builder, llvm_func, arg_values, args.len, "");
    ptrvec.free_v(&args);
    return call;
}
