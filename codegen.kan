import "ty";
import "dbg";
import "mod";
import "mir";
import "map";
import "std";
import "vmap";
import "path";
import "llvm-bindings" as llvm;
import "name";
import "ident";
import "target";
import "ptrvec";

type CompilationOptions struct {
    // if the context is null, a new one will be created for this module
    global_ctx: *llvm.Context,
    std_dir: string,
    target: target.Target,
    debug_info: bool
}

// stuff that outlives the ModuleCompiler
type ModuleContext struct {
    ctx: *llvm.Context,
    llmod: *llvm.Module
}

type LLVMFunction struct {
    ty: *llvm.Type,
    val: *llvm.Value
}

type ModuleCompiler struct {
    context: ModuleContext,
    irmod: *mir.Module,
    builder: *llvm.Builder,
    dbg: *DebugInfo,
    structs: map.Map,  // map.Map<mir.RefName, *llvm.Type>
    functions: vmap.Map // map.Map<mir.RefName, LLVMFunction>
}

def create_compiler(irmod: *mir.Module, ctx: *llvm.Context): ModuleCompiler {
    // ctx is only null, if we want to use multiple threads
    if ctx == null {
        // since this can run in parallel, but llvm.Context is not threadsafe,
        // we need a separate context per module
        ctx = llvm.context_create();
    }
    let llmod = llvm.module_create_with_name_in_context(irmod.actual.name.data, ctx);
    let path = mod.get_path(irmod.actual);
    llvm.set_source_file_name(llmod, path.inner, path.len);

    let builder = llvm.create_builder_in_context(ctx);

    return ModuleCompiler {
        context: ModuleContext { ctx: ctx, llmod: llmod },
        irmod: irmod,
        builder: builder,
        dbg: null,
        structs: map.create(),
        functions: vmap.create(sizeof LLVMFunction)
    };
}

def free_compiler(c: *ModuleCompiler): void {
    llvm.dispose_builder(c.builder);

    map.free_m(&c.structs);
    vmap.free_m(&c.functions);
}

def free_context(ctx: *ModuleContext): void {
    llvm.dispose_module(ctx.llmod);
    llvm.context_dispose(ctx.ctx);
}

def compile_mir_mod(irmod: *mir.Module, options: *CompilationOptions): ModuleContext {
    let compiler = create_compiler(irmod, options.global_ctx);

    let dbg: *DebugInfo = null;
    if options.debug_info {
        let info = create_dbg_info(&compiler, options.std_dir);
        dbg = &info;
        compiler.dbg = dbg; // enable debug information
    }

    add_forward_declarations(&compiler);
    compile_functions(&compiler);

    let t = options.target;
    llvm.set_target(compiler.context.llmod, t.triple_or_error);

    if options.debug_info {
        let module_flag_warning = 1;
        let int_ty = llvm.int32_type_in_context(compiler.context.ctx);
        let dbg_version = llvm.value_as_metadata(llvm.const_int(int_ty, 3, false));
        llvm.add_module_flag(
            compiler.context.llmod, module_flag_warning, "Debug Info Version", 18, dbg_version
        );

        if t.sys == target.Sys.Darwin {
            // Darwin only supports dwarf 2
            let dwarf_version = llvm.value_as_metadata(llvm.const_int(int_ty, 2, false));
            llvm.add_module_flag(
                compiler.context.llmod, module_flag_warning, "Dwarf Version", 13, dwarf_version
            );
        } else {
            let dwarf_version = llvm.value_as_metadata(llvm.const_int(int_ty, 4, false));
            llvm.add_module_flag(
                compiler.context.llmod, module_flag_warning, "Dwarf Version", 13, dwarf_version
            );
        }

        finalize(dbg);
    }

    let context = compiler.context;
    free_compiler(&compiler);

    if options.debug_info {
        free_dbg_info(dbg);
    }

    return context;
}

def add_forward_declarations(c: *ModuleCompiler): void {
    // add struct declarations
    let t_iter = map.iter(&c.irmod.user_defined_types);
    let item = map.iter_next(&t_iter);
    while item != null {
        let t = item.value as *mir.UserDefinedType;
        if ty.is_struct(t.ty) {
            lookup_or_declare_struct(c, t.ty);
        }
        item = map.iter_next(&t_iter);
    }

    // add globals

    // global variables, which reference other globals
    let ref_globals = ptrvec.with_cap(c.irmod.globals.len);

    let g_iter = map.iter(&c.irmod.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let var = item.value as *mir.GlobalVar;

        if var.value.is_name {
            ref_globals.push_ptr(item.value);
        } else {
            let storage = c.add_global(var);
            c.init_global(var, storage);
        }

        item = map.iter_next(&g_iter);
    }

    // TODO: keep global order
    // globals, which reference other globals have to be initialized after the others
    for let i: usize = 0; i < ref_globals.len; i += 1 {
        let var = ref_globals.get(i) as *mir.GlobalVar;
        let storage = c.add_global(var);
        c.init_global(var, storage);
    }
    ref_globals.free();

    // add function declarations
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        lookup_or_declare_function(c, f.ty);
        item = map.iter_next(&f_iter);
    }
}

type ValueTuple struct {
    first: *llvm.Value,
    second: *llvm.Value
}

def (c: *ModuleCompiler) add_global(global: *mir.GlobalVar): *llvm.Value {
    let llty: *llvm.Type = null;
    if global.value.is_name {
        llty = translate_type(c, global.ty);
    } else if ty.is_string(global.ty) {
        let len = global.value.len as u32 + 1; // 1 for null terminator
        llty = llvm.array_type(llvm.int8_type_in_context(c.context.ctx), len);
    } else {
        llty = translate_type(c, global.ty);
    }

    let storage = llvm.add_global(c.context.llmod, llty, global.mangled_name.data);
    let private_linkage = 15;
    llvm.set_linkage(storage, private_linkage);

    return storage;
}

def (c: *ModuleCompiler) init_global(ir: *mir.GlobalVar, storage: *llvm.Value) {
    let value: *llvm.Value = null;

    if ir.value.is_name {
        value = c.get_global(ir.value.as_ref(), true);
    } else {
        // Address of the global is globally insignificant
        let global_unnamed_address = 2;
        llvm.set_unnamed_address(storage, global_unnamed_address);
        value = c.create_global_value(ir);
    }

    llvm.set_initializer(storage, value);
}

def (c: *ModuleCompiler) create_global_value(global: *mir.GlobalVar): *llvm.Value {
    if ty.is_string(global.ty) {
        let null_terminate = true;
        return llvm.const_string_in_context(
            c.context.ctx,
            global.value.data as string,
            global.value.len as u32,
            !null_terminate
        );
    }

    if global.ty.is_integer() {
        let llty = translate_type(c, global.ty);
        return llvm.const_int_of_string_and_size(
            llty, global.value.data as string, global.value.len as u32, 10
        );
    }

    dbg.assert(false, "invalid global type");
    return null;
}

def lookup_or_declare_function(c: *ModuleCompiler, t: *ty.Type): LLVMFunction {
    dbg.assert(ty.is_func(t), "non func type passed");
    let f_ty = ty.as_func(t);

    let key = map.create_key(f_ty.mangled_name.len, f_ty.mangled_name.data);
    let func_ptr = vmap.get_ptr(&c.functions, key) as *LLVMFunction;

    if func_ptr == null {
        let func_type = translate_type(c, t);
        dbg.assert(func_type != null, "could not translate function type");

        let name = f_ty.mangled_name.data;
        let func_val = llvm.add_function(c.context.llmod, name, func_type);
        let func = LLVMFunction { ty: func_type, val: func_val };
        func_ptr = &func;
        vmap.insert(&c.functions, key, func_ptr as *void);
    }

    return *func_ptr;
}

def lookup_or_declare_struct(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    dbg.assert(ty.is_struct(t), "non struct type passed");
    let s_ty = ty.as_struct(t);

    let name = s_ty.super.mangled_name;
    let key = map.create_key(name.len, name.data);
    let struct_decl = map.get(&c.structs, key) as *llvm.Type;

    if struct_decl == null {
        let num_fields = s_ty.num_fields();
        let fields = ptrvec.with_cap(num_fields as usize);

        struct_decl = llvm.struct_create_named(c.context.ctx, name.data);
        map.insert(&c.structs, key, struct_decl as *void);
        for let i: u32 = 0; i < num_fields; i += 1 {
            let field = s_ty.field_at(i);

            let field_ty = translate_type(c, field.ty);
            fields.push_ptr(field_ty as *void);
        }

        let field_types = fields.elements as **llvm.Type;
        llvm.struct_set_body(struct_decl, field_types, num_fields, false);
        fields.free();
    }

    return struct_decl;
}

def translate_type(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    if t.is_integer() {
        return llvm.int_type_in_context(c.context.ctx, t.width_in_bits() as u32);
    }

    if ty.is_void(t) {
        return llvm.void_type_in_context(c.context.ctx);
    }

    if ty.is_f32(t) {
        return llvm.float_type_in_context(c.context.ctx);
    }

    if ty.is_f64(t) {
        return llvm.double_type_in_context(c.context.ctx);
    }

    if ty.is_bool(t) {
        return llvm.int1_type_in_context(c.context.ctx);
    }

    if ty.is_struct(t) {
        return lookup_or_declare_struct(c, t);
    }

    if ty.is_enum(t) {
        return translate_type(c, ty.as_enum(t).base_ty);
    }

    if ty.is_ptr(t) {
        let p_ty = ty.as_ptr(t);
        let t: *llvm.Type = null;
        if ty.is_void(p_ty.inner) {
            // llvm does not have a void pointer type
            t = llvm.int8_type_in_context(c.context.ctx);
        } else {
            t = translate_type(c, p_ty.inner);
        }

        for let i: u32 = 0; i < p_ty.count; i += 1 {
            t = llvm.pointer_type(t, 0);
        }

        return t;
    }

    if ty.is_callable(t) {
        let f_ty = ty.callable_as_func(t);
        let num_params = f_ty.params.len as u32;
        let params = ptrvec.with_cap(num_params as usize);

        for let i: u32 = 0; i < num_params; i += 1 {
            let param = f_ty.param_at(i);

            let param_ty = translate_type(c, param.ty);
            params.push_ptr(param_ty as *void);
        }

        let ret_ty = translate_type(c, f_ty.ret);

        let param_types = params.elements as **llvm.Type;
        let func_type = llvm.function_type(
            ret_ty, param_types, num_params, f_ty.is_varargs
        );
        params.free();

        return func_type;
    }

    dbg.assert_fmt(false, "unhandled type %d", t.kind);
    return null;
}

def translate_addr(
    c: *ModuleCompiler,
    curr_func: *FunctionData,
    a: *mir.Address
): *llvm.Value {
    return translate_addr_load(c, curr_func, a, true);
}

def translate_addr_load(
    c: *ModuleCompiler,
    curr_func: *FunctionData,
    a: *mir.Address,
    load: bool
): *llvm.Value {
    if mir.is_addr_name(a) {
        let addr_name = mir.as_addr_name(a);
        let variable = lookup(c, curr_func, addr_name.value);

        // don't load functions, since they are unsized (we need to load function pointers though)
        if load && !ty.is_func(a.ty) {
            dbg.assert_fmt(
                variable != null, "variable %s was null", addr_name.value.data
            );
            return llvm.build_load(c.builder, variable, "");
        }

        return variable;
    }

    if mir.is_addr_ref(a) {
        let ref = mir.as_addr_ref(a);
        return lookup(c, curr_func, ref.name);
    }

    if mir.is_addr_const(a) {
        let constant = mir.as_addr_const(a);
        return translate_literal(c, constant.start, constant.end, a.ty);
    }

    if mir.is_addr_const_value(a) {
        let llvm_ty = translate_type(c, a.ty);
        let constant = mir.as_addr_const_value(a);
        return llvm.const_int(llvm_ty, constant.value as usize, true);
    }

    if mir.is_addr_global(a) {
        let name = mir.as_addr_global(a).name;
        return c.get_global(name, load);
    }

    if mir.is_addr_arg(a) {
        let get_arg = mir.as_addr_arg(a);
        return llvm.get_param(curr_func.llfunc, get_arg.idx);
    }

    if mir.is_addr_null(a) {
        return llvm.const_null(translate_type(c, a.ty));
    }

    if mir.is_addr_undefined(a) {
        return llvm.get_undef(translate_type(c, a.ty));
    }

    dbg.assert_fmt(false, "invalid address kind %d", a.kind);
    return null;
}

def (c: *ModuleCompiler) get_global(name: name.Ref, load: bool): *llvm.Value {
    let global = llvm.get_named_global(c.context.llmod, name.data);
    let key = map.create_key(name.len, name.data);
    let mir_global = map.get(&c.irmod.globals, key) as *mir.GlobalVar;

    let num_indices: u32 = 1;
    if load {
        if mir_global.value.is_name || !ty.is_ptr(mir_global.ty) {
            return llvm.build_load(c.builder, global, "");
        }

        // deref twice
        num_indices = 2;
    }

    if !ty.is_ptr(mir_global.ty) {
        return global;
    }

    let int_ty = llvm.int32_type_in_context(c.context.ctx);
    let tuple = ValueTuple {
        first: llvm.const_int(int_ty, 0, false),
        second: llvm.const_int(int_ty, 0, false)
    };
    let indices = &tuple as **llvm.Value;

    return llvm.build_in_bounds_gep(c.builder, global, indices, num_indices, "");
}

def translate_literal(
    c: *ModuleCompiler,
    start: string,
    end: string,
    t: *ty.Type
): *llvm.Value {
    let llvm_ty = translate_type(c, t);

    // strings are globals, and therefore not handled here

    if ty.is_bool(t) {
        let int_value = *start - '0';
        return llvm.const_int(llvm_ty, int_value as usize, false);
    }

    let copy = std.strndup(start, (end - start) as usize);
    let llvm_lit: *llvm.Value = null;

    if t.is_integer() {
        llvm_lit = llvm.const_int_of_string(llvm_ty, copy, 10);
    }

    if t.is_float() {
        llvm_lit = llvm.const_real_of_string(llvm_ty, copy);
    }

    delete copy;
    return llvm_lit;
}

def compile_functions(c: *ModuleCompiler): void {
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        compile_function(c, f);
        item = map.iter_next(&f_iter);
    }
}

type FunctionData struct {
    llfunc: *llvm.Value,
    irfunc: *mir.Func,
    blocks: map.Map, // map.Map<RefName, *llvm.BasicBlock>
    locals: map.Map // map.Map<Refname, *llvm.Value>
}

def create_function_data(
    c: *ModuleCompiler,
    llfunc: *llvm.Value,
    irfunc: *mir.Func
): FunctionData {
    let num_blocks = mir.bm_num_blocks(&irfunc.blocks);
    let blocks = map.with_cap(num_blocks);
    let f_ty = ty.as_func(irfunc.ty);

    // unset the location for the prologue emission
    dbg_set_inst_location(c, null);
    let entry_block: *llvm.BasicBlock = null;

    for let i: usize = 0; i < num_blocks; i += 1 {
        let mir_bb = mir.bm_get_bb_ptr(&irfunc.blocks, i);
        let bb_name = name.ref(mir_bb.label.name);
        let llvm_bb = llvm.append_basic_block_in_context(
            c.context.ctx, llfunc, bb_name.data
        );

        if entry_block == null {
            entry_block = llvm_bb;
        }

        let key = map.create_key(bb_name.len, bb_name.data);
        map.insert(&blocks, key, llvm_bb as *void);
    }

    let num_locals = irfunc.blocks.decls.len;
    let locals = map.with_cap(num_locals);

    // compile variable declarations for the entire function
    llvm.position_builder_at_end(c.builder, entry_block);

    for let i: usize = 0; i < num_locals; i += 1 {
        let inst_decl = mir.bm_decl_at(&irfunc.blocks, i);
        dbg.assert(mir.is_inst_decl(&inst_decl), "expected a declaration");
        let decl = mir.as_inst_decl(&inst_decl);
        let ty = translate_type(c, decl.ty);

        // taking the name.data should be safe, since this is name.Ref, points
        // to the same string as the corresponding name.Owned inside the
        // NameTable, which has to be null terminated, since it's a name.Owned
        let value_ptr = llvm.build_alloca(c.builder, ty, decl.name.data);

        let key = map.create_key(decl.name.len, decl.name.data);
        map.insert(&locals, key, value_ptr as *void);
    }

    return FunctionData {
        llfunc: llfunc,
        irfunc: irfunc,
        blocks: blocks,
        locals: locals
    };
}

def free_function_data(f: *FunctionData): void {
    map.free_m(&f.blocks);
    map.free_m(&f.locals);
}

def bb_by_label(f: *FunctionData, label: *mir.Label): *llvm.BasicBlock {
    let bb_name = mir.label_name(label);
    let key = map.create_key(bb_name.len, bb_name.data);
    return map.get(&f.blocks, key) as *llvm.BasicBlock;
}

def lookup(c: *ModuleCompiler, f: *FunctionData, var_name: name.Ref): *llvm.Value {
    let key = map.create_key(var_name.len, var_name.data);
    let value = map.get(&f.locals, key) as *llvm.Value;

    // try to find a function with this name instead
    if value == null {
        let func = vmap.get_ptr(&c.functions, key) as *LLVMFunction;
        if func != null {
            value = func.val;
        }
    }

    if value == null {
        return llvm.get_named_global(c.context.llmod, var_name.data);
    }

    return value;
}

def add_variable(f: *FunctionData, var_name: name.Ref, value: *llvm.Value): void {
    let key = map.create_key(var_name.len, var_name.data);
    map.insert(&f.locals, key, value as *void);
}

def compile_function(c: *ModuleCompiler, func: *mir.Func): void {
    let llvm_func = lookup_or_declare_function(c, func.ty);
    dbg.assert_fmt(
        llvm_func.val != null && llvm_func.ty != null, "function not found '%s'", func.name.data
    );

    if func.is_extern {
        return;
    }

    let llvm_func_ty = llvm_func.ty;
    if c.dbg != null {
        let dbg_f = dbg_create_function(c, func, llvm_func_ty);
        llvm.set_subprogram(llvm_func.val, dbg_f);
    }

    let func_data = create_function_data(c, llvm_func.val, func);

    for let i: usize = 0; i < func_data.blocks.len; i += 1 {
        let bb = mir.bm_get_bb_ptr(&func.blocks, i);
        compile_bb(c, &func_data, bb);
    }

    free_function_data(&func_data);
}

def compile_bb(c: *ModuleCompiler, func: *FunctionData, bb: *mir.BasicBlock) {
    let llvm_bb = bb_by_label(func, &bb.label);
    llvm.position_builder_at_end(c.builder, llvm_bb);

    let n = mir.bb_num_instr(bb);
    for let i: usize = 0; i < n; i += 1 {
        let inst = mir.bb_get_instr(bb, i);
        compile_inst(c, func, inst);
    }

    compile_inst(c, func, &bb.terminator);
}

def compile_inst(c: *ModuleCompiler, func: *FunctionData, inst: *mir.Inst) {
    dbg_set_inst_location(c, inst);

    if mir.is_inst_assign(inst) {
        let assign = mir.as_inst_assign(inst);

        if mir.is_expr_struct_init(&assign.value) {
            compile_struct_init_assign(c, func, inst);
            return;
        }

        let value = compile_expr(c, func, &assign.value);
        dbg.assert(value != null, "value was null");

        // calls should always have debug infos
        if mir.is_expr_call(&assign.value) {
            llvm.set_inst_debug_location(c.builder, value);
        }

        if mir.is_addr_empty(&assign.dest) {
            // Only void calls generate empty addresses. The typechecker does
            // not allow them to be assigned or used in any way, but the mir
            // generates assign instructions for every expression, so we return
            // here, to make sure that no actual assign is generated for the
            // result of a void function call
            return;
        }

        let storage = translate_addr_load(c, func, &assign.dest, false);

        // this is only a temporary variable, that does not need stack space
        if storage == null {
            dbg.assert(
                mir.is_addr_name(&assign.dest), "names are the only nullable address"
            );
            let addr_name = mir.as_addr_name(&assign.dest);
            add_variable(func, addr_name.value, value);
            return;
        }

        let is_param = assign.param_idx >= 0;
        // unset the instruction location for parameters since we want to skip their assignment
        if is_param {
            dbg_set_inst_location(c, null);
        }

        // this is a declared variable
        let store = llvm.build_store(c.builder, value, storage);

        // check if this is a parameter
        if is_param {
            dbg_declare_parameter(c, func, storage, store, inst, assign.param_idx as u32);
        } else {
            llvm.set_inst_debug_location(c.builder, store);

            if mir.assign_has_original_ident(assign) {
                dbg_declare_local(
                    c,
                    storage,
                    store,
                    inst,
                    assign.dest.ty,
                    ident.len(&assign.original_ident),
                    ident.start(&assign.original_ident)
                );
            }
        }

        return;
    }

    if mir.is_inst_jmp(inst) {
        let jmp = mir.as_inst_jmp(inst);
        let target_bb = bb_by_label(func, &jmp.target);
        let br = llvm.build_br(c.builder, target_bb);
        llvm.set_inst_debug_location(c.builder, br);
        return;
    }

    if mir.is_inst_jmpif(inst) {
        let jmp = mir.as_inst_jmpif(inst);

        let if_target_bb = bb_by_label(func, &jmp.if_target);
        let else_target_bb = bb_by_label(func, &jmp.else_target);
        let condition = translate_addr(c, func, &jmp.condition);

        let br = llvm.build_cond_br(c.builder, condition, if_target_bb, else_target_bb);
        llvm.set_inst_debug_location(c.builder, br);
        return;
    }

    if mir.is_inst_return(inst) {
        let ret = mir.as_inst_return(inst);
        if mir.is_addr_empty(&ret.value) {
            let ret = llvm.build_ret_void(c.builder);
            llvm.set_inst_debug_location(c.builder, ret);
            return;
        }

        let value = translate_addr(c, func, &ret.value);
        let ret = llvm.build_ret(c.builder, value);
        llvm.set_inst_debug_location(c.builder, ret);
        return;
    }

    if mir.is_inst_delete(inst) {
        let del = mir.as_inst_delete(inst);
        let addr = translate_addr(c, func, &del.addr);
        let del = llvm.build_free(c.builder, addr);
        llvm.set_inst_debug_location(c.builder, del);
        return;
    }

    dbg.assert_fmt(false, "invalid instruction kind %d", inst.kind);
}

def compile_struct_init_assign(c: *ModuleCompiler, func: *FunctionData, inst: *mir.Inst) {
    let assign = mir.as_inst_assign(inst);
    let init = mir.as_expr_struct_init(&assign.value);

    let dest_ty = translate_type(c, assign.dest.ty);
    let storage = translate_addr_load(c, func, &assign.dest, false);
    dbg.assert(storage != null, "null storage for struct init");

    for let i: u32 = 0; i < init.args.len as u32; i += 1 {
        let arg = mir.init_arg_at(init, i);
        let arg_addr = translate_addr(c, func, arg);

        let field = llvm.build_struct_gep(c.builder, storage, i, "");
        let store = llvm.build_store(c.builder, arg_addr, field);
        llvm.set_inst_debug_location(c.builder, store);
    }

    if mir.assign_has_original_ident(assign) {
        dbg_declare_local(
            c,
            storage,
            storage,
            inst,
            assign.dest.ty,
            ident.len(&assign.original_ident),
            ident.start(&assign.original_ident)
        );
    }
}

def compile_expr(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    if mir.is_expr_copy(e) {
        let copy = mir.as_expr_copy(e);
        return translate_addr(c, func, &copy.addr);
    }

    if mir.is_expr_unary(e) {
        return compile_unary(c, func, e);
    }

    if mir.is_expr_binary(e) {
        return compile_binary(c, func, e);
    }

    if mir.is_expr_call(e) {
        return compile_call(c, func, e);
    }

    if mir.is_expr_gep(e) {
        let gep = mir.as_expr_gep(e);
        let addr = translate_addr_load(c, func, &gep.addr, false);
        return llvm.build_struct_gep(c.builder, addr, gep.idx, "");
    }

    if mir.is_expr_cast(e) {
        let cast = mir.as_expr_cast(e);

        if cast.kind == mir.CastKind.IntNoLoad {
            let addr = translate_addr_load(c, func, &cast.addr, false);
            let into = translate_type(c, cast.into);
            return llvm.build_int_cast(c.builder, addr, into, "");
        }

        let addr = translate_addr(c, func, &cast.addr);
        let into = translate_type(c, cast.into);

        if cast.kind == mir.CastKind.Bit {
            return llvm.build_bit_cast(c.builder, addr, into, "");
        }

        let from_int = cast.addr.ty.is_integer();
        let into_int = cast.into.is_integer();

        let from_float = cast.addr.ty.is_float();
        let into_float = cast.into.is_float();

        if from_int && into_int {
            return llvm.build_int_cast(c.builder, addr, into, "");
        }

        if from_int && into_float {
            return llvm.build_si_to_fp(c.builder, addr, into, "");
        }

        if from_float && into_int {
            return llvm.build_fp_to_si(c.builder, addr, into, "");
        }

        if from_float && into_float {
            return llvm.build_fp_cast(c.builder, addr, into, "");
        }
    }

    if mir.is_expr_new(e) {
        let new_e = mir.as_expr_new(e);
        let addr = translate_addr_load(c, func, &new_e.addr, false);
        let ty = translate_type(c, new_e.addr.ty);

        let storage = llvm.build_malloc(c.builder, ty, "");
        let align = llvm.get_alignment(addr);
        let size = llvm.size_of(ty);
        llvm.build_mem_cpy(c.builder, storage, align, addr, align, size);

        return storage;
    }

    // TODO: remove codegen for sizeof entirely, when we have a mir interpretation stage
    if mir.is_expr_sizeof(e) {
        let so = mir.as_expr_sizeof(e);
        let ty = translate_type(c, so.ty);

        return llvm.size_of(ty);
    }

    dbg.assert_fmt(false, "invalid expression kind %d", e.kind);
    return null;
}

def compile_unary(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    let unary = mir.as_expr_unary(e);
    let value = translate_addr(c, func, &unary.addr);

    if unary.kind == mir.UnaryKind.Deref {
        // was already loaded
        return value;
    }

    if unary.kind == mir.UnaryKind.NumNeg {
        if unary.addr.ty.is_float() {
            return llvm.build_f_neg(c.builder, value, "");
        }
        return llvm.build_neg(c.builder, value, "");
    }

    if unary.kind == mir.UnaryKind.BoolNeg {
        return llvm.build_not(c.builder, value, "");
    }

    dbg.assert_fmt(false, "Invalid unary kind: %d", unary.kind);
    return null;
}

def compile_binary(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    let binary = mir.as_expr_binary(e);

    if binary.left.ty.is_float() {
        return compile_binary_float(c, func, binary);
    }

    let left = translate_addr(c, func, &binary.left);
    let right = translate_addr(c, func, &binary.right);

    let signed_offset = 0;
    if binary.left.ty.is_unsigned() {
        // the unsiged int predicates are always 4 less, than their signed counterpart
        signed_offset = 4;
    }

    if binary.kind == mir.BinaryKind.Add {
        return llvm.build_add(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Sub {
        // pointer subtraction (both types have to be equal for mir.BinaryKind.Sub)
        if ty.is_ptr(binary.left.ty) {
            let int64_ty = llvm.int64_type_in_context(c.context.ctx);
            left = llvm.build_ptr_to_int(c.builder, left, int64_ty, "");
            right = llvm.build_ptr_to_int(c.builder, right, int64_ty, "");

            let sub = llvm.build_sub(c.builder, left, right, "");
            let int32_ty = llvm.int32_type_in_context(c.context.ctx);
            return sub;
        }

        return llvm.build_sub(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Mul {
        return llvm.build_mul(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Div {
        return llvm.build_s_div(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Mod {
        // TODO(#90): this is actually a remainder operation, not modulo
        //  same for floats
        return llvm.build_s_rem(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.ST {
        return llvm.build_i_cmp(c.builder, 40 - signed_offset, left, right, "");
    } else if binary.kind == mir.BinaryKind.SE {
        return llvm.build_i_cmp(c.builder, 41 - signed_offset, left, right, "");
    } else if binary.kind == mir.BinaryKind.GT {
        return llvm.build_i_cmp(c.builder, 38 - signed_offset, left, right, "");
    } else if binary.kind == mir.BinaryKind.GE {
        return llvm.build_i_cmp(c.builder, 39 - signed_offset, left, right, "");
    } else if binary.kind == mir.BinaryKind.EQ {
        return llvm.build_i_cmp(c.builder, 32, left, right, "");
    } else if binary.kind == mir.BinaryKind.NE {
        return llvm.build_i_cmp(c.builder, 33, left, right, "");
    } else if binary.kind == mir.BinaryKind.BoolAnd || binary.kind == mir.BinaryKind.BitAnd {
        return llvm.build_and(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.BoolOr || binary.kind == mir.BinaryKind.BitOr {
        return llvm.build_or(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.LShift {
        return llvm.build_shl(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.RShift {
        return llvm.build_a_shr(c.builder, left, right, "");
    } else {
        let ptr = left;
        let scalar = right;
        if ty.is_ptr(binary.right.ty) {
            ptr = right;
            scalar = left;
        }

        // for ptr - scalar, just negate the scalar value
        if binary.kind == mir.BinaryKind.SubScalar {
            scalar = llvm.build_neg(c.builder, scalar, "");
        }

        return llvm.build_in_bounds_gep(c.builder, ptr, &scalar, 1, "");
    }

    return null;
}

def compile_binary_float(
    c: *ModuleCompiler,
    func: *FunctionData,
    binary: *mir.ExprBinary
): *llvm.Value {
    let left = translate_addr(c, func, &binary.left);
    let right = translate_addr(c, func, &binary.right);

    if binary.kind == mir.BinaryKind.Add {
        return llvm.build_f_add(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Sub {
        return llvm.build_f_sub(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Mul {
        return llvm.build_f_mul(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Div {
        return llvm.build_f_div(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.Mod {
        return llvm.build_f_rem(c.builder, left, right, "");
    } else if binary.kind == mir.BinaryKind.ST {
        return llvm.build_f_cmp(c.builder, 4, left, right, "");
    } else if binary.kind == mir.BinaryKind.SE {
        return llvm.build_f_cmp(c.builder, 5, left, right, "");
    } else if binary.kind == mir.BinaryKind.GT {
        return llvm.build_f_cmp(c.builder, 2, left, right, "");
    } else if binary.kind == mir.BinaryKind.GE {
        return llvm.build_f_cmp(c.builder, 3, left, right, "");
    } else if binary.kind == mir.BinaryKind.EQ {
        return llvm.build_f_cmp(c.builder, 1, left, right, "");
    } else if binary.kind == mir.BinaryKind.NE {
        return llvm.build_f_cmp(c.builder, 6, left, right, "");
    }

    dbg.assert_fmt(false, "Invalid binary float kind: %d", binary.kind);
    return null;
}

def compile_call(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    let call = mir.as_expr_call(e);

    let num_args = call.args.len;
    let args = ptrvec.with_cap(num_args);
    for let i: u32 = 0; i < num_args as u32; i += 1 {
        let arg = mir.call_arg_at(call, i);
        let value = translate_addr(c, func, arg);

        if call.varargs {
            // If a float is passed as an argument to a variadic function,
            // it has to be promoted to a double implicitly
            if ty.is_f32(arg.ty) {
                // convert f32 to f64
                let f64_ty = llvm.double_type_in_context(c.context.ctx);
                value = llvm.build_fp_ext(c.builder, value, f64_ty, "");
            }
        }

        args.push_ptr(value as *void);
    }

    let arg_values = args.elements as **llvm.Value;

    let call_value: *llvm.Value = null;
    if call.is_intrinsic() {
        let intrinsic = call.get_intrinsic();
        dbg.assert(intrinsic == mir.IntrinsicFunction.MemSet, "invalid intrinsic");
        dbg.assert(num_args == 3, "memset expects 3 arguments");

        call_value = llvm.build_mem_set(
            c.builder,
            args.get(0) as *llvm.Value,
            args.get(1) as *llvm.Value,
            args.get(2) as *llvm.Value,
            0
        );
    } else {
        let llvm_func = translate_addr(c, func, &call.callee);
        dbg.assert(llvm_func != null, "llvm function not found");

        call_value = llvm.build_call(c.builder, llvm_func, arg_values, args.len as u32, "");
    }

    args.free();
    return call_value;
}

type DebugInfo struct {
    builder: *llvm.DbgBuilder,
    scopes: ptrvec.Vec, // ptrvec.Vec<*llvm.MetaData>
    cu: *llvm.MetaData,
    file: *llvm.MetaData,
    std_dir: string,
    types: map.Map, // map.Map<mir.Refname, *llvm.MetaData>
    functions: map.Map // map.Map<mir.Refname, *llvm.MetaData>
}

def create_dbg_info(c: *ModuleCompiler, std_dir: string): DebugInfo {
    let mod_path = mod.get_path(c.irmod.actual);
    let dir = path.parent(&mod_path);
    let file = path.create(mod_path.inner + dir.len, mod_path.len - dir.len);
    let dir_len: usize = 0;

    let builder = llvm.create_di_builder(c.context.llmod);
    if mod.is_std_lib(c.irmod.actual) {
        file = dir;
        dir = path.create(std_dir, std.strlen(std_dir));
        dir_len = dir.len;
    } else {
        dir_len = dir.len - 1; // -1 to remove trailing '/'
    }
    let llfile = llvm.di_builder_create_file(
        builder, file.inner, file.len, dir.inner, dir_len
    );

    let c_lang = 1;
    let cu = llvm.di_builder_create_compile_unit(
        builder, c_lang, llfile,
        "kantanc", 7, // producer
        false,        // optimized
        "", 0,        // flags
        0,            // runtime version
        "", 0,        // split name
        1,            // dwarf emission kind
        0,            // DWOId
        true,         // split debug inlining
        false         // debug info for profiling
    );

    let scopes = ptrvec.with_cap(c.irmod.scopes.count());
    scopes.zero();
    // the scope at index 0 is the file
    scopes.push_ptr(llfile as *void);

    return DebugInfo {
        builder: builder,
        scopes: scopes,
        cu: cu,
        file: llfile,
        std_dir: std_dir,
        types: map.create(),
        functions: map.create()
    };
}

// TODO: this seems to be completely broken for some reason
def dbg_translate_type(c: *ModuleCompiler, t: *ty.Type): *llvm.MetaData {
    dbg.assert(c.dbg != null, "called dbg_translate_type in non-debug mode");

    // TODO: enum
    let dw_ate_address         = 1;
    let dw_ate_boolean         = 2;
    let dw_ate_complex_float   = 3;
    let dw_ate_float           = 4;
    let dw_ate_signed          = 5;
    let dw_ate_signed_char     = 6;
    let dw_ate_unsigned        = 7;
    let dw_ate_unsigned_char   = 8;
    let dw_ate_imaginary_float = 9;
    let dw_ate_packed_decimal  = 10;
    let dw_ate_numeric_string  = 11;
    let dw_ate_edited          = 12;
    let dw_ate_signed_fixed    = 13;
    let dw_ate_unsigned_fixed  = 14;
    let dw_ate_decimal_float   = 15;

    if ty.is_i8(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "i8", 2, 8, dw_ate_signed_char, 0
        );
    }

    if ty.is_i16(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "i16", 3, 16, dw_ate_signed, 0
        );
    }

    if ty.is_i32(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "i32", 3, 32, dw_ate_signed, 0
        );
    }

    if ty.is_i64(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "i64", 3, 64, dw_ate_signed, 0
        );
    }

    if ty.is_isize(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "isize", 5, t.width_in_bits(), dw_ate_signed, 0
        );
    }

    if ty.is_u8(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "u8", 2, 8, dw_ate_unsigned, 0
        );
    }

    if ty.is_u16(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "u16", 3, 16, dw_ate_unsigned, 0
        );
    }

    if ty.is_u32(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "u32", 3, 32, dw_ate_unsigned, 0
        );
    }

    if ty.is_u64(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "u64", 3, 64, dw_ate_unsigned, 0
        );
    }

    if ty.is_usize(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "usize", 5, t.width_in_bits(), dw_ate_unsigned, 0
        );
    }

    if ty.is_void(t) {
        return null;
    }

    if ty.is_f32(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "f32", 3, 32, dw_ate_float, 0
        );
    }

    if ty.is_f64(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "f64", 3, 64, dw_ate_float, 0
        );
    }

    if ty.is_bool(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "bool", 4, 8, dw_ate_boolean, 0
        );
    }

    // pointers have to checked before user_defined, since pointers to user_defined are also
    // user defined, but they need to be translated differently here.
    if ty.is_ptr(t) {
        let ptr = ty.as_ptr(t);
        let inner = dbg_translate_type(c, ptr.inner);
        let inner_name = "";
        let free_inner_name = ty.to_string(ptr.inner, &inner_name);
        let inner_len = std.strlen(inner_name);

        for let i: usize = 0; i < ptr.count as usize; i += 1 {
            let star_count = i + 1;
            let name = std.malloc(star_count + inner_len);
            std.memset(name, '*', star_count);
            std.memcpy(name + star_count, inner_name as *void, inner_len);

            // TODO(#99): determine pointer size based on target pointer width
            inner = llvm.di_builder_create_pointer_type(
                c.dbg.builder,
                inner,
                t.width_in_bits(), t.align_in_bits(),
                0,
                name as string, star_count + inner_len
            );

            delete name;
        }

        if free_inner_name {
            delete inner_name;
        }

        return inner;
    }

    if ty.is_user_defined(t) {
        let type_data = ty.get_user_defined(t);
        let name = type_data.mangled_name;
        let key = map.create_key(name.len, name.data);

        let cached = map.get(&c.dbg.types, key) as *llvm.MetaData;
        if cached != null {
            return cached;
        }

        let definition = map.get(&c.irmod.user_defined_types, key) as *mir.UserDefinedType;
        dbg.assert_fmt(definition != null, "user defined type %s does not exist", name.data);

        let scope: *llvm.MetaData = null;
        let file = c.dbg.file;

        if definition.is_extern {
            let mod_path = mod.get_path(type_data.declared_in);
            let dir = path.parent(&mod_path);
            let filename = path.create(mod_path.inner + dir.len, mod_path.len - dir.len);

            if mod.is_std_lib(type_data.declared_in) {
                filename = dir;
                dir = path.create(c.dbg.std_dir, std.strlen(c.dbg.std_dir));
            }

            file = llvm.di_builder_create_file(
                c.dbg.builder,
                filename.inner, filename.len,
                dir.inner, dir.len - 1 // -1 to remove trailing '/'
            );
            scope = file;
        } else {
            scope = dbg_get_scope(c.dbg, definition.meta);
        }

        if ty.is_struct(t) {
            let s_ty = ty.as_struct(t);
            let tag: u32 = 19; // dwarf_tag_structure_type
            let placeholder = llvm.di_builder_create_forward_decl(
                c.dbg.builder, tag,
                definition.name.data, definition.name.len,
                scope, file, definition.meta.pos.lnr,
                0, t.width_in_bits(), t.align_in_bits(),
                definition.name.data, definition.name.len
            );
            map.insert(&c.dbg.types, key, placeholder as *void);

            let field_types = ptrvec.with_cap(s_ty.num_fields() as usize);
            for let i: u32 = 0; i < s_ty.num_fields(); i += 1 {
                let field = s_ty.field_at(i);
                let width_bits = field.ty.width_in_bits();
                let offset_in_bits = field.offset * 8;

                let member = llvm.di_builder_create_member_type(
                    c.dbg.builder, scope,
                    ident.start(&field.name), ident.len(&field.name),
                    file, definition.meta.pos.lnr, // TODO(#97): line number of field
                    width_bits, field.ty.align_in_bits(), offset_in_bits,
                    0, dbg_translate_type(c, field.ty)
                );

                field_types.push_ptr(member as *void);
            }

            let llvm_struct_ty = llvm.di_builder_create_struct_type(
                c.dbg.builder, scope,
                definition.name.data, definition.name.len,
                file, definition.meta.pos.lnr,
                t.width_in_bits(), t.align_in_bits(), 0, placeholder,
                field_types.elements as **llvm.MetaData, field_types.len as u32,
                0, null,
                definition.name.data, definition.name.len
            );

            field_types.free();
            map.insert(&c.dbg.types, key, llvm_struct_ty as *void);

            return llvm_struct_ty;
        }

        if ty.is_enum(t) {
            let e_ty = ty.as_enum(t);

            let enumerators = ptrvec.with_cap(e_ty.num_values() as usize);
            for let i: u32 = 0; i < e_ty.num_values(); i += 1 {
                let enum_value = ty.value_at(e_ty, i);

                let enumerator = llvm.di_builder_create_enumerator(
                    c.dbg.builder,
                    ident.start(&enum_value.name),
                    ident.len(&enum_value.name),
                    enum_value.value as i64,
                    true // are there signed enum values?
                );

                enumerators.push_ptr(enumerator as *void);
            }

            let enumeration = llvm.di_builder_create_enumeration_type(
                c.dbg.builder,
                scope,
                definition.name.data, definition.name.len,
                file, definition.meta.pos.lnr,
                t.width_in_bits(), t.align_in_bits(),
                enumerators.elements as **llvm.MetaData, enumerators.len as u32,
                null // class ty
            );

            enumerators.free();
            return enumeration;
        }
    }

    if ty.is_callable(t) {
        let f_ty = ty.callable_as_func(t);
        let key = map.create_key(f_ty.mangled_name.len, f_ty.mangled_name.data);

        let cached = map.get(&c.dbg.functions, key) as *llvm.MetaData;
        if cached != null {
            return cached;
        }

        let f_ty = dbg_create_subroutine_type(c, f_ty);
        map.insert(&c.dbg.functions, key, f_ty as *void);
        return f_ty;
    }

    dbg.assert_fmt(false, "unhandled type %d", t.kind);
    return null;
}

def dbg_get_scope(info: *DebugInfo, meta: mir.MetaData): *llvm.MetaData {
    let scope = meta.scope;
    if scope.id < 0 {
        return info.cu;
    }

    let metadata = info.scopes.get(scope.id as usize) as *llvm.MetaData;
    if metadata == null {
        // Empty scopes (scopes without statements) might not have been initialized,
        // so we just look for the next smallest scope for parent
        let parent: *llvm.MetaData = null;
        for let i = scope.parent; parent == null && i >= 0; i -= 1 {
            parent = info.scopes.get(i as usize) as *llvm.MetaData;
        }

        dbg.assert_fmt(
            parent != null,
            "no parent scope with id %d (for %d)",
            scope.parent,
            scope.id
        );

        metadata = llvm.di_builder_create_lexical_block(
            info.builder, parent, info.file, meta.pos.lnr, meta.pos.col
        );

        info.scopes.set(scope.id as usize, metadata as *void);
    }

    return metadata;
}

def dbg_create_subroutine_type(c: *ModuleCompiler, f_ty: *ty.Func): *llvm.MetaData {
    let types = ptrvec.with_cap(f_ty.params.len + 1); // +1 for return type
    for let i: u32 = 0; i < f_ty.num_params(); i += 1 {
        let param = f_ty.param_at(i);
        types.push_ptr(dbg_translate_type(c, param.ty) as *void);
    }
    types.push_ptr(dbg_translate_type(c, f_ty.ret) as *void);

    let ll_ty = llvm.di_builder_create_subroutine_type(
        c.dbg.builder, c.dbg.file, types.elements as **llvm.MetaData, types.len as u32, 0
    );
    types.free();

    return ll_ty;
}

def dbg_create_function(c: *ModuleCompiler, ir_f: *mir.Func, ll_f: *llvm.Type): *llvm.MetaData {
    let surrounding = c.dbg.scopes.get(ir_f.meta.scope.parent as usize) as *llvm.MetaData;

    let f_ty = ty.as_func(ir_f.ty);
    let ll_ty = dbg_create_subroutine_type(c, f_ty);

    let sub_program = llvm.di_builder_create_function(
        c.dbg.builder, surrounding, ir_f.name.data, ir_f.name.len,
        "", 0, // linkage name
        c.dbg.file, ir_f.meta.pos.lnr,
        ll_ty,
        false,           // is local to unit
        !ir_f.is_extern, // is definition
        ir_f.meta.pos.lnr,
        0,               // flags
        false            // is optimized
    );

    let key = map.create_key(f_ty.mangled_name.len, f_ty.mangled_name.data);
    map.insert(&c.dbg.functions, key, ll_ty as *void);

    c.dbg.scopes.set(ir_f.meta.scope.id as usize, sub_program as *void);
    return sub_program;
}

def dbg_set_inst_location(c: *ModuleCompiler, inst: *mir.Inst) {
    if c.dbg == null {
        return;
    }

    if inst == null {
        llvm.set_current_debug_location2(c.builder, null);
        return;
    }

    let loc = dbg_create_location(c, inst);
    llvm.set_current_debug_location2(c.builder, loc);
}

def dbg_create_location(c: *ModuleCompiler, inst: *mir.Inst): *llvm.MetaData {
    let surrounding = dbg_get_scope(c.dbg, inst.meta);

    return llvm.di_builder_create_debug_location(
        c.context.ctx,
        inst.meta.pos.lnr, inst.meta.pos.col,
        surrounding,
        null // inlined at
    );
}

def dbg_declare_local(
    c: *ModuleCompiler,
    storage: *llvm.Value,
    insert_after: *llvm.Value,
    inst: *mir.Inst,
    t: *ty.Type,
    name_len: usize,
    name: string
) {
    if c.dbg == null {
        return;
    }

    let assign = mir.as_inst_assign(inst);
    let var_meta = inst.meta;
    var_meta.scope = assign.var_scope;

    let surrounding = dbg_get_scope(c.dbg, var_meta);
    let loc = llvm.di_builder_create_debug_location(
        c.context.ctx,
        inst.meta.pos.lnr, inst.meta.pos.col,
        surrounding,
        null // inlined at
    );

    let ty = dbg_translate_type(c, t);
    dbg.assert(ty != null, "dbg type was null");

    let dbg_local_var = llvm.di_builder_create_auto_variable(
        c.dbg.builder,
        surrounding,
        name, name_len,
        c.dbg.file,
        inst.meta.pos.lnr,
        ty,
        false,  // always preserve
        0,      // flags
        0       // align
    );

    let expr = llvm.di_builder_create_expression(c.dbg.builder, null, 0);

    llvm.di_builder_insert_declare_before(
        c.dbg.builder, storage, dbg_local_var, expr, loc, insert_after
    );
}


def dbg_declare_parameter(
    c: *ModuleCompiler,
    func: *FunctionData,
    storage: *llvm.Value,
    insert_after: *llvm.Value,
    inst: *mir.Inst,
    param_nr: u32
) {
    if c.dbg == null {
        return;
    }

    let param = ty.as_func(func.irfunc.ty).param_at(param_nr);

    let surrounding = dbg_get_scope(c.dbg, inst.meta);
    let loc = dbg_create_location(c, inst);
    let ty = dbg_translate_type(c, param.ty);
    dbg.assert(ty != null, "dbg type was null");

    let dbg_local_var = llvm.di_builder_create_parameter_variable(
        c.dbg.builder,
        surrounding,
        ident.start(&param.name), ident.len(&param.name),
        param_nr + 1,
        c.dbg.file,
        inst.meta.pos.lnr,
        ty,
        false,  // always preserve
        0       // flags
    );

    let expr = llvm.di_builder_create_expression(c.dbg.builder, null, 0);

    llvm.di_builder_insert_declare_before(
        c.dbg.builder, storage, dbg_local_var, expr, loc, insert_after
    );
}

def finalize(info: *DebugInfo) {
    llvm.di_builder_finalize(info.builder);
}

def free_dbg_info(info: *DebugInfo) {
    llvm.dispose_di_builder(info.builder);
    info.scopes.free();
    map.free_m(&info.types);
    map.free_m(&info.functions);
}
