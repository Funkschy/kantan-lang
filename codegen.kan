import "ty";
import "dbg";
import "mod";
import "mir";
import "map";
import "std";
import "path";
import "llvm";
import "name";
import "ident";
import "target";
import "ptrvec";

type CompilationOptions struct {
    // if the context is null, a new one will be created for this module
    global_ctx: *llvm.Context,
    std_dir: string,
    target: target.Target,
    debug_info: bool
}

// stuff that outlives the ModuleCompiler
type ModuleContext struct {
    ctx: *llvm.Context,
    llmod: *llvm.Module
}

type ModuleCompiler struct {
    context: ModuleContext,
    irmod: *mir.Module,
    builder: *llvm.Builder,
    dbg: *DebugInfo,
    structs: map.Map,  // map.Map<mir.RefName, *llvm.Type>
    functions: map.Map // map.Map<mir.RefName, *llvm.Type>
}

def create_compiler(irmod: *mir.Module, ctx: *llvm.Context): ModuleCompiler {
    // ctx is only null, if we want to use multiple threads
    if ctx == null {
        // since this can run in parallel, but llvm.Context is not threadsafe,
        // we need a separate context per module
        ctx = llvm.context_create();
    }
    let llmod = llvm.module_create_with_name_in_context(irmod.actual.name.data, ctx);
    let path = mod.get_path(irmod.actual);
    llvm.set_source_file_name(llmod, path.inner, path.len);

    let builder = llvm.create_builder_in_context(ctx);

    return ModuleCompiler {
        context: ModuleContext { ctx: ctx, llmod: llmod },
        irmod: irmod,
        builder: builder,
        dbg: null,
        structs: map.create(),
        functions: map.create()
    };
}

def free_compiler(c: *ModuleCompiler): void {
    llvm.dispose_builder(c.builder);

    map.free_m(&c.structs);
    map.free_m(&c.functions);
}

def free_context(ctx: *ModuleContext): void {
    llvm.dispose_module(ctx.llmod);
    llvm.context_dispose(ctx.ctx);
}

def compile_mir_mod(irmod: *mir.Module, options: *CompilationOptions): ModuleContext {
    let compiler = create_compiler(irmod, options.global_ctx);

    let dbg: *DebugInfo = null;
    if options.debug_info {
        let info = create_dbg_info(&compiler, options.std_dir);
        dbg = &info;
        compiler.dbg = dbg; // enable debug information
    }

    add_forward_declarations(&compiler);
    compile_functions(&compiler);

    let t = options.target;
    llvm.set_target(compiler.context.llmod, t.triple_or_error);

    if options.debug_info {
        let module_flag_warning = 1;
        let int_ty = llvm.int32_type_in_context(compiler.context.ctx);
        let dbg_version = llvm.value_as_metadata(llvm.const_int(int_ty, 3, false));
        llvm.add_module_flag(
            compiler.context.llmod, module_flag_warning, "Debug Info Version", 18, dbg_version
        );

        if t.sys.value == target.sys_darwin().value {
            // Darwin only supports dwarf 2
            let dwarf_version = llvm.value_as_metadata(llvm.const_int(int_ty, 2, false));
            llvm.add_module_flag(
                compiler.context.llmod, module_flag_warning, "Dwarf Version", 13, dwarf_version
            );
        } else {
            let dwarf_version = llvm.value_as_metadata(llvm.const_int(int_ty, 4, false));
            llvm.add_module_flag(
                compiler.context.llmod, module_flag_warning, "Dwarf Version", 13, dwarf_version
            );
        }

        finalize(dbg);
    }

    let context = compiler.context;
    free_compiler(&compiler);

    if options.debug_info {
        free_dbg_info(dbg);
    }

    return context;
}

def add_forward_declarations(c: *ModuleCompiler): void {
    // add struct declarations
    let s_iter = map.iter(&c.irmod.structs);
    let item = map.iter_next(&s_iter);
    while item != null {
        let s = item.value as *mir.Struct;
        lookup_or_declare_struct(c, s.ty);
        item = map.iter_next(&s_iter);
    }

    // add globals
    let g_iter = map.iter(&c.irmod.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let gc = item.value as *mir.GlobalConst;
        add_global_const(c, gc);
        item = map.iter_next(&g_iter);
    }

    // add function declarations
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        lookup_or_declare_function(c, f.ty);
        item = map.iter_next(&f_iter);
    }
}

def add_global_const(c: *ModuleCompiler, gc: *mir.GlobalConst): void {
    dbg.assert(ty.is_string(gc.ty), "we currently only support string literals");
    let len = gc.value.len + 1; // 1 for null terminator
    let ty = llvm.array_type(llvm.int8_type_in_context(c.context.ctx), len);

    let global_storage = llvm.add_global(c.context.llmod, ty, gc.name.data);
    llvm.set_global_constant(global_storage, true);
    let private_linkage = 15;
    llvm.set_linkage(global_storage, private_linkage);
    // Address of the string is globally insignificant
    let global_unnamed_address = 2;
    llvm.set_unnamed_address(global_storage, global_unnamed_address);

    let null_terminate = true;
    let const_string = llvm.const_string_in_context(
        c.context.ctx,
        gc.value.data,
        gc.value.len,
        !null_terminate
    );
    llvm.set_initializer(global_storage, const_string);
}

def lookup_or_declare_function(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    dbg.assert(ty.is_func(t), "non func type passed");
    let f_ty = ty.as_func(t);

    let key = map.create_key(f_ty.mangled_name.len, f_ty.mangled_name.data);
    let func_decl = map.get(&c.functions, key) as *llvm.Type;

    if func_decl == null {
        let num_params = f_ty.params.len;
        let params = ptrvec.with_cap(num_params);

        let i = 0;
        while i < num_params {
            let param = ty.param_at(f_ty, i);

            let param_ty = translate_type(c, param.ty);
            ptrvec.push_ptr(&params, param_ty as *void);

            i = i + 1;
        }

        let ret_ty = translate_type(c, f_ty.ret);

        let param_types = params.elements as **llvm.Type;
        func_decl = llvm.function_type(
            ret_ty, param_types, num_params, f_ty.is_varargs
        );
        ptrvec.free_v(&params);

        let name = f_ty.mangled_name.data;
        llvm.add_function(c.context.llmod, name, func_decl);
        map.insert(&c.functions, key, func_decl as *void);
    }

    return func_decl;
}

def lookup_or_declare_struct(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    dbg.assert(ty.is_struct(t), "non struct type passed");
    let s_ty = ty.as_struct(t);

    let key = map.create_key(s_ty.mangled_name.len, s_ty.mangled_name.data);
    let struct_decl = map.get(&c.structs, key) as *llvm.Type;

    if struct_decl == null {
        let num_fields = ty.num_fields(s_ty);
        let fields = ptrvec.with_cap(num_fields);

        let name = s_ty.mangled_name.data;
        struct_decl = llvm.struct_create_named(c.context.ctx, name);
        map.insert(&c.structs, key, struct_decl as *void);

        let i = 0;
        while i < num_fields {
            let field = ty.field_at(s_ty, i);

            let field_ty = translate_type(c, field.ty);
            ptrvec.push_ptr(&fields, field_ty as *void);

            i = i + 1;
        }

        let field_types = fields.elements as **llvm.Type;
        llvm.struct_set_body(struct_decl, field_types, num_fields, false);
        ptrvec.free_v(&fields);
    }

    return struct_decl;
}

def translate_type(c: *ModuleCompiler, t: *ty.Type): *llvm.Type {
    if ty.is_i32(t) {
        return llvm.int32_type_in_context(c.context.ctx);
    }

    if ty.is_void(t) {
        return llvm.void_type_in_context(c.context.ctx);
    }

    if ty.is_f32(t) {
        return llvm.float_type_in_context(c.context.ctx);
    }

    if ty.is_bool(t) {
        return llvm.int1_type_in_context(c.context.ctx);
    }

    if ty.is_char(t) {
        return llvm.int8_type_in_context(c.context.ctx);
    }

    if ty.is_struct(t) {
        return lookup_or_declare_struct(c, t);
    }

    if ty.is_ptr(t) {
        let p_ty = ty.as_ptr(t);
        let t: *llvm.Type = null;
        if ty.is_void(p_ty.inner) {
            // llvm does not have a void pointer type
            t = llvm.int8_type_in_context(c.context.ctx);
        } else {
            t = translate_type(c, p_ty.inner);
        }

        let i = 0;
        while i < p_ty.count {
            t = llvm.pointer_type(t, 0);
            i = i + 1;
        }

        return t;
    }

    dbg.assert_fmt(false, "unhandled type %d", t.kind);
    return null;
}

def translate_addr(
    c: *ModuleCompiler,
    curr_func: *FunctionData,
    a: *mir.Address
): *llvm.Value {
    return translate_addr_load(c, curr_func, a, true);
}

def translate_addr_load(
    c: *ModuleCompiler,
    curr_func: *FunctionData,
    a: *mir.Address,
    load: bool
): *llvm.Value {
    if mir.is_addr_name(a) {
        let addr_name = mir.as_addr_name(a);
        let variable = variable_by_name(curr_func, addr_name.value);

        if load {
            dbg.assert_fmt(
                variable != null, "variable %s was null", addr_name.value.data
            );
            return llvm.build_load(c.builder, variable, "");
        }

        return variable;
    }

    if mir.is_addr_ref(a) {
        let ref = mir.as_addr_ref(a);
        return variable_by_name(curr_func, ref.name);
    }

    if mir.is_addr_const(a) {
        let constant = mir.as_addr_const(a);
        return translate_literal(c, constant.start, constant.end, a.ty);
    }

    if mir.is_addr_global(a) {
        let name = mir.as_addr_global(a).name;
        let global = llvm.get_named_global(c.context.llmod, name.data);

        let gep = llvm.build_gep(c.builder, global, null, 0, "");
        let ty = translate_type(c, a.ty);
        return llvm.build_pointer_cast(c.builder, gep, ty, "");
    }

    if mir.is_addr_arg(a) {
        let get_arg = mir.as_addr_arg(a);
        return llvm.get_param(curr_func.llfunc, get_arg.idx);
    }

    if mir.is_addr_null(a) {
        return llvm.const_null(translate_type(c, a.ty));
    }

    dbg.assert_fmt(false, "invalid address kind %d", a.kind);
    return null;
}

def translate_literal(
    c: *ModuleCompiler,
    start: string,
    end: string,
    t: *ty.Type
): *llvm.Value {
    let llvm_ty = translate_type(c, t);

    if ty.is_char(t) {
        let int_value = std.char_to_int(*start);
        return llvm.const_int(llvm_ty, int_value, false);
    }

    if ty.is_bool(t) {
        let int_value = std.char_to_int(*start) - std.char_to_int('0');
        return llvm.const_int(llvm_ty, int_value, false);
    }

    let copy = std.strndup(start, end - start);
    let llvm_lit: *llvm.Value = null;

    if ty.is_i32(t) {
        llvm_lit = llvm.const_int_of_string(llvm_ty, copy, 10);
    }

    if ty.is_f32(t) {
        llvm_lit = llvm.const_real_of_string(llvm_ty, copy);
    }

    delete copy;
    return llvm_lit;
}

def compile_functions(c: *ModuleCompiler): void {
    let f_iter = map.iter(&c.irmod.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *mir.Func;
        compile_function(c, f);
        item = map.iter_next(&f_iter);
    }
}

type FunctionData struct {
    llfunc: *llvm.Value,
    irfunc: *mir.Func,
    blocks: map.Map, // map.Map<RefName, *llvm.BasicBlock>
    locals: map.Map // map.Map<Refname, *llvm.Value>
}

def create_function_data(
    c: *ModuleCompiler,
    llfunc: *llvm.Value,
    irfunc: *mir.Func
): FunctionData {
    let num_blocks = mir.bm_num_blocks(&irfunc.blocks);
    let blocks = map.with_cap(num_blocks);
    let f_ty = ty.as_func(irfunc.ty);

    // unset the location for the prologue emission
    dbg_set_inst_location(c, null);
    let entry_block: *llvm.BasicBlock = null;

    let i = 0;
    while i < num_blocks {
        let mir_bb = mir.bm_get_bb_ptr(&irfunc.blocks, i);
        let bb_name = name.ref(mir_bb.label.name);
        let llvm_bb = llvm.append_basic_block_in_context(
            c.context.ctx, llfunc, bb_name.data
        );

        if entry_block == null {
            entry_block = llvm_bb;
        }

        let key = map.create_key(bb_name.len, bb_name.data);
        map.insert(&blocks, key, llvm_bb as *void);
        i = i + 1;
    }

    let num_locals = irfunc.blocks.decls.len;
    let locals = map.with_cap(num_locals);

    // compile variable declarations for the entire function
    llvm.position_builder_at_end(c.builder, entry_block);

    for let i = 0; i < num_locals; i = i + 1 {
        let inst_decl = mir.bm_decl_at(&irfunc.blocks, i);
        dbg.assert(mir.is_inst_decl(&inst_decl), "expected a declaration");
        let decl = mir.as_inst_decl(&inst_decl);
        let ty = translate_type(c, decl.ty);

        // taking the name.data should be safe, since this is name.Ref, points
        // to the same string as the corresponding name.Owned inside the
        // NameTable, which has to be null terminated, since it's a name.Owned
        let value_ptr = llvm.build_alloca(c.builder, ty, decl.name.data);

        let key = map.create_key(decl.name.len, decl.name.data);
        map.insert(&locals, key, value_ptr as *void);
    }

    return FunctionData {
        llfunc: llfunc,
        irfunc: irfunc,
        blocks: blocks,
        locals: locals
    };
}

def free_function_data(f: *FunctionData): void {
    map.free_m(&f.blocks);
    map.free_m(&f.locals);
}

def bb_by_label(f: *FunctionData, label: *mir.Label): *llvm.BasicBlock {
    let bb_name = mir.label_name(label);
    let key = map.create_key(bb_name.len, bb_name.data);
    return map.get(&f.blocks, key) as *llvm.BasicBlock;
}

def variable_by_name(f: *FunctionData, var_name: name.Ref): *llvm.Value {
    let key = map.create_key(var_name.len, var_name.data);
    let value = map.get(&f.locals, key) as *llvm.Value;
    return value;
}

def add_variable(f: *FunctionData, var_name: name.Ref, value: *llvm.Value): void {
    let key = map.create_key(var_name.len, var_name.data);
    map.insert(&f.locals, key, value as *void);
}

def compile_function(c: *ModuleCompiler, func: *mir.Func): void {
    let llvm_func_ty = lookup_or_declare_function(c, func.ty);
    dbg.assert_fmt(
        llvm_func_ty != null, "function type not found %s", func.name.data
    );

    if func.is_extern {
        return;
    }

    let llvm_func = llvm.get_named_function(c.context.llmod, func.name.data);
    dbg.assert_fmt(llvm_func!= null, "function not found %s", func.name.data);
    if c.dbg != null {
        let dbg_f = dbg_create_function(c, func, llvm_func_ty);
        llvm.set_subprogram(llvm_func, dbg_f);
    }

    let func_data = create_function_data(c, llvm_func, func);

    for let i = 0; i < func_data.blocks.len; i = i + 1 {
        let bb = mir.bm_get_bb_ptr(&func.blocks, i);
        compile_bb(c, &func_data, bb);
    }

    free_function_data(&func_data);
}

def compile_bb(c: *ModuleCompiler, func: *FunctionData, bb: *mir.BasicBlock): void {
    let llvm_bb = bb_by_label(func, &bb.label);
    llvm.position_builder_at_end(c.builder, llvm_bb);

    let i = 0;
    let n = mir.bb_num_instr(bb);
    while i < n {
        let inst = mir.bb_get_instr(bb, i);
        compile_inst(c, func, inst);
        i = i + 1;
    }

    compile_inst(c, func, &bb.terminator);
}

def compile_inst(c: *ModuleCompiler, func: *FunctionData, inst: *mir.Inst): void {
    dbg_set_inst_location(c, inst);

    if mir.is_inst_assign(inst) {
        let assign = mir.as_inst_assign(inst);

        if mir.is_expr_struct_init(&assign.value) {
            compile_struct_init_assign(c, func, inst);
            return;
        }

        let value = compile_expr(c, func, &assign.value);
        dbg.assert(value != null, "value was null");

        // calls should always have debug infos
        if mir.is_expr_call(&assign.value) {
            llvm.set_inst_debug_location(c.builder, value);
        }

        if mir.is_addr_empty(&assign.dest) {
            // Only void calls generate empty addresses. The typechecker does
            // not allow them to be assigned or used in any way, but the mir
            // generates assign instructions for every expression, so we return
            // here, to make sure that no actual assign is generated for the
            // result of a void function call
            return;
        }

        let storage = translate_addr_load(c, func, &assign.dest, false);

        // this is only a temporary variable, that does not need stack space
        if storage == null {
            dbg.assert(
                mir.is_addr_name(&assign.dest), "names are the only nullable address"
            );
            let addr_name = mir.as_addr_name(&assign.dest);
            add_variable(func, addr_name.value, value);
            return;
        }

        // unset the instruction location for parameters since we want to skip their assignment
        if assign.param_idx >= 0 {
            dbg_set_inst_location(c, null);
        }

        // this is a declared variable
        let store = llvm.build_store(c.builder, value, storage);

        // check if this is a parameter
        if assign.param_idx >= 0 {
            dbg_declare_parameter(c, func, storage, store, inst, assign.param_idx);
        } else {
            llvm.set_inst_debug_location(c.builder, store);

            if mir.assign_has_original_ident(assign) {
                dbg_declare_local(
                    c,
                    storage,
                    store,
                    inst,
                    assign.dest.ty,
                    ident.len(&assign.original_ident),
                    ident.start(&assign.original_ident)
                );
            }
        }

        return;
    }

    if mir.is_inst_jmp(inst) {
        let jmp = mir.as_inst_jmp(inst);
        let target_bb = bb_by_label(func, &jmp.target);
        let br = llvm.build_br(c.builder, target_bb);
        llvm.set_inst_debug_location(c.builder, br);
        return;
    }

    if mir.is_inst_jmpif(inst) {
        let jmp = mir.as_inst_jmpif(inst);

        let if_target_bb = bb_by_label(func, &jmp.if_target);
        let else_target_bb = bb_by_label(func, &jmp.else_target);
        let condition = translate_addr(c, func, &jmp.condition);

        let br = llvm.build_cond_br(c.builder, condition, if_target_bb, else_target_bb);
        llvm.set_inst_debug_location(c.builder, br);
        return;
    }

    if mir.is_inst_return(inst) {
        let ret = mir.as_inst_return(inst);
        if mir.is_addr_empty(&ret.value) {
            let ret = llvm.build_ret_void(c.builder);
            llvm.set_inst_debug_location(c.builder, ret);
            return;
        }

        let value = translate_addr(c, func, &ret.value);
        let ret = llvm.build_ret(c.builder, value);
        llvm.set_inst_debug_location(c.builder, ret);
        return;
    }

    if mir.is_inst_delete(inst) {
        let del = mir.as_inst_delete(inst);
        let addr = translate_addr(c, func, &del.addr);
        let del = llvm.build_free(c.builder, addr);
        llvm.set_inst_debug_location(c.builder, del);
        return;
    }

    dbg.assert_fmt(false, "invalid instruction kind %d", inst.kind);
}

def compile_struct_init_assign(
    c: *ModuleCompiler,
    func: *FunctionData,
    inst: *mir.Inst
): void {
    let assign = mir.as_inst_assign(inst);
    let init = mir.as_expr_struct_init(&assign.value);

    let dest_ty = translate_type(c, assign.dest.ty);
    let storage = translate_addr_load(c, func, &assign.dest, false);
    dbg.assert(storage != null, "null storage for struct init");

    // I don't really know, if we actually want to do this
    //
    // let zero = llvm.const_int(llvm.int8_type_in_context(c.context.ctx), 0, false);
    // let len = llvm.size_of(dest_ty);
    // let align = llvm.get_alignment(storage);
    // llvm.build_mem_set(c.builder, storage, zero, len, align);

    let i = 0;
    while i < init.args.len {
        let arg = mir.init_arg_at(init, i);
        let arg_addr = translate_addr(c, func, arg);

        let field = llvm.build_struct_gep(c.builder, storage, i, "");
        let store = llvm.build_store(c.builder, arg_addr, field);
        llvm.set_inst_debug_location(c.builder, store);

        i = i + 1;
    }

    if mir.assign_has_original_ident(assign) {
        dbg_declare_local(
            c,
            storage,
            storage,
            inst,
            assign.dest.ty,
            ident.len(&assign.original_ident),
            ident.start(&assign.original_ident)
        );
    }
}

def compile_expr(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    if mir.is_expr_copy(e) {
        let copy = mir.as_expr_copy(e);
        return translate_addr(c, func, &copy.addr);
    }

    if mir.is_expr_unary(e) {
        return compile_unary(c, func, e);
    }

    if mir.is_expr_binary(e) {
        return compile_binary(c, func, e);
    }

    if mir.is_expr_call(e) {
        return compile_call(c, func, e);
    }

    if mir.is_expr_gep(e) {
        let gep = mir.as_expr_gep(e);
        let addr = translate_addr_load(c, func, &gep.addr, false);
        return llvm.build_struct_gep(c.builder, addr, gep.idx, "");
    }

    if mir.is_expr_bitcast(e) {
        let cast = mir.as_expr_cast(e);
        let addr = translate_addr(c, func, &cast.addr);
        let into = translate_type(c, cast.into);
        return llvm.build_bit_cast(c.builder, addr, into, "");
    }

    if mir.is_expr_intcast(e) {
        let cast = mir.as_expr_cast(e);
        let addr = translate_addr_load(c, func, &cast.addr, false);
        let into = translate_type(c, cast.into);
        return llvm.build_int_cast(c.builder, addr, into, "");
    }

    if mir.is_expr_new(e) {
        let new_e = mir.as_expr_new(e);
        let addr = translate_addr_load(c, func, &new_e.addr, false);
        let ty = translate_type(c, new_e.addr.ty);

        let storage = llvm.build_malloc(c.builder, ty, "");
        let align = llvm.get_alignment(addr);
        let size = llvm.size_of(ty);
        llvm.build_mem_cpy(c.builder, storage, align, addr, align, size);

        return storage;
    }

    if mir.is_expr_sizeof(e) {
        let so = mir.as_expr_sizeof(e);
        let ty = translate_type(c, so.ty);

        // TODO(#88): remove when u64 is supported
        return llvm.build_int_cast(
            c.builder,
            llvm.size_of(ty),
            llvm.int32_type_in_context(c.context.ctx),
            ""
        );
    }

    dbg.assert_fmt(false, "invalid expression kind %d", e.kind);
    return null;
}

def compile_unary(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    let unary = mir.as_expr_unary(e);
    let value = translate_addr(c, func, &unary.addr);

    if mir.is_unary_deref(unary) {
        // was already loaded
        return value;
    }

    if mir.is_unary_num_neg(unary) {
        return llvm.build_neg(c.builder, value, "");
    }

    if mir.is_unary_bool_neg(unary) {
        return llvm.build_not(c.builder, value, "");
    }

    dbg.assert_fmt(false, "Invalid unary kind: %d", unary.kind);
    return null;
}

#include "mir_types.h"
def compile_binary(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    let binary = mir.as_expr_binary(e);

    if ty.is_f32(binary.left.ty) {
        return compile_binary_float(c, func, binary);
    }

    let left = translate_addr(c, func, &binary.left);
    let right = translate_addr(c, func, &binary.right);

    if binary.kind == MIR_BIN_ADD {
        return llvm.build_add(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_SUB {
        // pointer subtraction (both types have to be equal for MIR_BIN_SUB)
        if ty.is_ptr(binary.left.ty) {
            let int64_ty = llvm.int64_type_in_context(c.context.ctx);
            left = llvm.build_ptr_to_int(c.builder, left, int64_ty, "");
            right = llvm.build_ptr_to_int(c.builder, right, int64_ty, "");

            let sub = llvm.build_sub(c.builder, left, right, "");
            let int32_ty = llvm.int32_type_in_context(c.context.ctx);
            // we currently only support i32, so we need to cast the result
            // this is safer than casting the pointers separately i think
            return llvm.build_int_cast(c.builder, sub, int32_ty, "");
        }

        return llvm.build_sub(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MUL {
        return llvm.build_mul(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_DIV {
        return llvm.build_s_div(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MOD {
        // TODO(#90): this is actually a remainder operation, not modulo
        //  same for floats
        return llvm.build_s_rem(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_ST {
        // TODO(#96): unsigned integer types
        return llvm.build_i_cmp(c.builder, 40, left, right, "");
    } else if binary.kind == MIR_BIN_SE {
        return llvm.build_i_cmp(c.builder, 41, left, right, "");
    } else if binary.kind == MIR_BIN_GT {
        return llvm.build_i_cmp(c.builder, 38, left, right, "");
    } else if binary.kind == MIR_BIN_GE {
        return llvm.build_i_cmp(c.builder, 39, left, right, "");
    } else if binary.kind == MIR_BIN_EQ {
        return llvm.build_i_cmp(c.builder, 32, left, right, "");
    } else if binary.kind == MIR_BIN_NE {
        return llvm.build_i_cmp(c.builder, 33, left, right, "");
    } else if binary.kind == MIR_BIN_BOOL_AND {
        return llvm.build_and(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_BOOL_OR {
        return llvm.build_or(c.builder, left, right, "");
    } else {
        let ptr = left;
        let scalar = right;
        if ty.is_ptr(binary.right.ty) {
            ptr = right;
            scalar = left;
        }

        // for ptr - scalar, just negate the scalar value
        if binary.kind == MIR_BIN_SUB_SCALAR {
            scalar = llvm.build_neg(c.builder, scalar, "");
        }

        return llvm.build_in_bounds_gep(c.builder, ptr, &scalar, 1, "");
    }

    dbg.assert_fmt(false, "Invalid binary kind: %d", binary.kind);
    return null;
}

def compile_binary_float(
    c: *ModuleCompiler,
    func: *FunctionData,
    binary: *mir.ExprBinary
): *llvm.Value {
    let left = translate_addr(c, func, &binary.left);
    let right = translate_addr(c, func, &binary.right);

    if binary.kind == MIR_BIN_ADD {
        return llvm.build_f_add(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_SUB {
        return llvm.build_f_sub(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MUL {
        return llvm.build_f_mul(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_DIV {
        return llvm.build_f_div(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_MOD {
        return llvm.build_f_rem(c.builder, left, right, "");
    } else if binary.kind == MIR_BIN_ST {
        return llvm.build_f_cmp(c.builder, 4, left, right, "");
    } else if binary.kind == MIR_BIN_SE {
        return llvm.build_f_cmp(c.builder, 5, left, right, "");
    } else if binary.kind == MIR_BIN_GT {
        return llvm.build_f_cmp(c.builder, 2, left, right, "");
    } else if binary.kind == MIR_BIN_GE {
        return llvm.build_f_cmp(c.builder, 3, left, right, "");
    } else if binary.kind == MIR_BIN_EQ {
        return llvm.build_f_cmp(c.builder, 1, left, right, "");
    } else if binary.kind == MIR_BIN_NE {
        return llvm.build_f_cmp(c.builder, 6, left, right, "");
    }

    dbg.assert_fmt(false, "Invalid binary float kind: %d", binary.kind);
    return null;
}

def compile_call(
    c: *ModuleCompiler,
    func: *FunctionData,
    e: *mir.Expression
): *llvm.Value {
    let call = mir.as_expr_call(e);
    // TODO(#92): we need to change this, when introducing function pointers
    dbg.assert(mir.is_addr_name(&call.callee), "callee should be name");
    let callee_name = mir.as_addr_name(&call.callee).value;
    let llvm_func = llvm.get_named_function(c.context.llmod, callee_name.data);
    dbg.assert(llvm_func != null, "llvm function not found");

    let num_args = call.args.len;
    let args = ptrvec.with_cap(num_args);
    let i = 0;
    while i < num_args {
        let arg = mir.call_arg_at(call, i);
        let value = translate_addr(c, func, arg);

        if call.varargs {
            // If a float is passed as an argument to a variadic function,
            // it has to be promoted to a double implicitly
            if ty.is_f32(arg.ty) {
                // convert f32 to f64
                let f64_ty = llvm.double_type_in_context(c.context.ctx);
                value = llvm.build_fp_ext(c.builder, value, f64_ty, "");
            }
        }

        ptrvec.push_ptr(&args, value as *void);
        i = i + 1;
    }

    let arg_values = args.elements as **llvm.Value;
    let call = llvm.build_call(c.builder, llvm_func, arg_values, args.len, "");
    ptrvec.free_v(&args);
    return call;
}

type DebugInfo struct {
    builder: *llvm.DbgBuilder,
    scopes: ptrvec.Vec, // ptrvec.Vec<*llvm.MetaData>
    cu: *llvm.MetaData,
    file: *llvm.MetaData,
    std_dir: string,
    structs: map.Map // map.Map<mir.Refname, *llvm.MetaData>
}

def create_dbg_info(c: *ModuleCompiler, std_dir: string): DebugInfo {
    let mod_path = mod.get_path(c.irmod.actual);
    let dir = path.parent(&mod_path);
    let file = path.create(mod_path.inner + dir.len, mod_path.len - dir.len);

    let builder = llvm.create_di_builder(c.context.llmod);
    if mod.is_std_lib(c.irmod.actual) {
        file = dir;
        dir = path.create(std_dir, std.strlen(std_dir));
    }
    let llfile = llvm.di_builder_create_file(
        builder, file.inner, file.len, dir.inner, dir.len - 1 // -1 to remove trailing '/'
    );

    let c_lang = 1;
    let cu = llvm.di_builder_create_compile_unit(
        builder, c_lang, llfile,
        "kantanc", 7, // producer
        false,        // optimized
        "", 0,        // flags
        0,            // runtime version
        "", 0,        // split name
        1,            // dwarf emission kind
        0,            // DWOId
        true,         // split debug inlining
        false         // debug info for profiling
    );

    let scopes = ptrvec.with_cap(c.irmod.scopes.len);
    ptrvec.zero(&scopes);
    // the scope at index 0 is the file
    ptrvec.push_ptr(&scopes, llfile as *void);

    return DebugInfo {
        builder: builder,
        scopes: scopes,
        cu: cu,
        file: llfile,
        std_dir: std_dir,
        structs: map.create()
    };
}

def dbg_translate_type(c: *ModuleCompiler, t: *ty.Type): *llvm.MetaData {
    dbg.assert(c.dbg != null, "called dbg_translate_type in non-debug mode");

    // TODO: enum
    let dw_ate_address         = 1;
    let dw_ate_boolean         = 2;
    let dw_ate_complex_float   = 3;
    let dw_ate_float           = 4;
    let dw_ate_signed          = 5;
    let dw_ate_signed_char     = 6;
    let dw_ate_unsigned        = 7;
    let dw_ate_unsigned_char   = 8;
    let dw_ate_imaginary_float = 9;
    let dw_ate_packed_decimal  = 10;
    let dw_ate_numeric_string  = 11;
    let dw_ate_edited          = 12;
    let dw_ate_signed_fixed    = 13;
    let dw_ate_unsigned_fixed  = 14;
    let dw_ate_decimal_float   = 15;

    if ty.is_i32(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "i32", 3, 32, dw_ate_signed, 0
        );
    }

    if ty.is_void(t) {
        return null;
    }

    if ty.is_f32(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "f32", 3, 32, dw_ate_float, 0
        );
    }

    if ty.is_bool(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "bool", 4, 8, dw_ate_boolean, 0
        );
    }

    if ty.is_char(t) {
        return llvm.di_builder_create_basic_type(
            c.dbg.builder, "char", 4, 8, dw_ate_signed_char, 0
        );
    }

    if ty.is_struct(t) {
        let s_ty = ty.as_struct(t);
        let key = map.create_key(s_ty.mangled_name.len, s_ty.mangled_name.data);

        let cached = map.get(&c.dbg.structs, key) as *llvm.MetaData;
        if cached != null {
            return cached;
        }

        let s = map.get(&c.irmod.structs, key) as *mir.Struct;
        dbg.assert_fmt(s != null, "struct %s does not exist", s_ty.mangled_name.data);

        let scope: *llvm.MetaData = null;
        let file = c.dbg.file;

        if s.is_extern {
            let mod_path = mod.get_path(s_ty.declared_in);
            let dir = path.parent(&mod_path);
            let filename = path.create(mod_path.inner + dir.len, mod_path.len - dir.len);

            if mod.is_std_lib(s_ty.declared_in) {
                filename = dir;
                dir = path.create(c.dbg.std_dir, std.strlen(c.dbg.std_dir));
            }

            file = llvm.di_builder_create_file(
                c.dbg.builder,
                filename.inner, filename.len,
                dir.inner, dir.len - 1 // -1 to remove trailing '/'
            );
            scope = file;
        } else {
            scope = dbg_get_scope(c.dbg, s.meta);
        }

        let tag = 19; // dwarf_tag_structure_type
        let placeholder = llvm.di_builder_create_forward_decl(
            c.dbg.builder, tag,
            s.name.data, s.name.len,
            scope, file, s.meta.pos.lnr,
            0, t.width * 8, t.align * 8,
            s.name.data, s.name.len
        );
        map.insert(&c.dbg.structs, key, placeholder as *void);

        let field_types = ptrvec.with_cap(s_ty.fields.len);
        for let i = 0; i < s_ty.fields.len; i = i + 1 {
            let field = ty.field_at(s_ty, i);
            let width_bits = field.ty.width * 8;
            let offset_in_bits = field.offset * 8;

            let member = llvm.di_builder_create_member_type(
                c.dbg.builder, scope,
                ident.start(&field.name), ident.len(&field.name),
                file, s.meta.pos.lnr, // TODO(#97): line number of field
                width_bits, field.ty.align * 8, offset_in_bits,
                0, dbg_translate_type(c, field.ty)
            );

            ptrvec.push_ptr(&field_types, member as *void);
        }

        let llvm_struct_ty = llvm.di_builder_create_struct_type(
            c.dbg.builder, scope,
            s.name.data, s.name.len,
            file, s.meta.pos.lnr,
            t.width * 8, t.align * 8, 0, placeholder,
            field_types.elements as **llvm.MetaData, field_types.len,
            0, null,
            s.name.data, s.name.len
        );

        ptrvec.free_v(&field_types);
        map.insert(&c.dbg.structs, key, llvm_struct_ty as *void);

        return llvm_struct_ty;
    }

    if ty.is_ptr(t) {
        let ptr = ty.as_ptr(t);
        let inner = dbg_translate_type(c, ptr.inner);
        let inner_name = "";
        let free_inner_name = ty.to_string(ptr.inner, &inner_name);
        let inner_len = std.strlen(inner_name);

        for let i = 0; i < ptr.count; i = i + 1 {
            let star_count = i + 1;
            let name = std.malloc(star_count + inner_len);
            std.memset(name, std.char_to_int('*'), star_count);
            std.memcpy(name + star_count, inner_name as *void, inner_len);

            // TODO(#99): determine pointer size based on target pointer width
            inner = llvm.di_builder_create_pointer_type(
                c.dbg.builder, inner, t.width, t.align, 0, name as string, star_count + inner_len
            );

            delete name;
        }

        if free_inner_name {
            delete inner_name;
        }

        return inner;
    }

    dbg.assert_fmt(false, "unhandled type %d", t.kind);
    return null;
}

def dbg_get_scope(info: *DebugInfo, meta: mir.MetaData): *llvm.MetaData {
    let scope = meta.scope;
    if scope.id < 0 {
        return info.cu;
    }

    let metadata = ptrvec.get(&info.scopes, scope.id) as *llvm.MetaData;
    if metadata == null {
        // Empty scopes (scopes without statements) might not have been initialized,
        // so we just look for the next smallest scope for parent
        let parent: *llvm.MetaData = null;
        for let i = scope.parent; parent == null && i >= 0; i = i - 1 {
            parent = ptrvec.get(&info.scopes, i) as *llvm.MetaData;
        }

        dbg.assert_fmt(
            parent != null,
            "no parent scope with id %d (for %d)",
            scope.parent,
            scope.id
        );

        metadata = llvm.di_builder_create_lexical_block(
            info.builder, parent, info.file, meta.pos.lnr, meta.pos.col
        );

        ptrvec.set(&info.scopes, scope.id, metadata as *void);
    }

    return metadata;
}

def dbg_create_function(c: *ModuleCompiler, ir_f: *mir.Func, ll_f: *llvm.Type): *llvm.MetaData {
    let info = c.dbg;
    let surrounding = ptrvec.get(&info.scopes, ir_f.meta.scope.parent) as *llvm.MetaData;

    let f_ty = ty.as_func(ir_f.ty);
    let types = ptrvec.with_cap(f_ty.params.len + 1); // +1 for return type
    for let i = 0; i < f_ty.params.len; i = i + 1 {
        let param = ty.param_at(f_ty, i);
        ptrvec.push_ptr(&types, dbg_translate_type(c, param.ty) as *void);
    }
    ptrvec.push_ptr(&types, dbg_translate_type(c, f_ty.ret) as *void);

    let ll_ty = llvm.di_builder_create_subroutine_type(
        info.builder, info.file, types.elements as **llvm.MetaData, types.len, 0
    );
    ptrvec.free_v(&types);

    let sub_program = llvm.di_builder_create_function(
        info.builder, surrounding, ir_f.name.data, ir_f.name.len,
        "", 0, // linkage name
        info.file, ir_f.meta.pos.lnr,
        ll_ty,
        false,           // is local to unit
        !ir_f.is_extern, // is definition
        ir_f.meta.pos.lnr,
        0,               // flags
        false            // is optimized
    );

    ptrvec.set(&info.scopes, ir_f.meta.scope.id, sub_program as *void);
    return sub_program;
}

def dbg_set_inst_location(c: *ModuleCompiler, inst: *mir.Inst) {
    if c.dbg == null {
        return;
    }

    if inst == null {
        llvm.set_current_debug_location2(c.builder, null);
        return;
    }

    let loc = dbg_create_location(c, inst);
    llvm.set_current_debug_location2(c.builder, loc);
}

def dbg_create_location(c: *ModuleCompiler, inst: *mir.Inst): *llvm.MetaData {
    let surrounding = dbg_get_scope(c.dbg, inst.meta);

    return llvm.di_builder_create_debug_location(
        c.context.ctx,
        inst.meta.pos.lnr, inst.meta.pos.col,
        surrounding,
        null // inlined at
    );
}

def dbg_declare_local(
    c: *ModuleCompiler,
    storage: *llvm.Value,
    insert_after: *llvm.Value,
    inst: *mir.Inst,
    t: *ty.Type,
    name_len: i32,
    name: string
) {
    if c.dbg == null {
        return;
    }

    let surrounding = dbg_get_scope(c.dbg, inst.meta);
    let loc = dbg_create_location(c, inst);
    let ty = dbg_translate_type(c, t);
    dbg.assert(ty != null, "dbg type was null");

    let dbg_local_var = llvm.di_builder_create_auto_variable(
        c.dbg.builder,
        surrounding,
        name, name_len,
        c.dbg.file,
        inst.meta.pos.lnr,
        ty,
        false,  // always preserve
        0,      // flags
        0       // align
    );

    let expr = llvm.di_builder_create_expression(c.dbg.builder, null, 0);

    llvm.di_builder_insert_declare_before(
        c.dbg.builder, storage, dbg_local_var, expr, loc, insert_after
    );
}


def dbg_declare_parameter(
    c: *ModuleCompiler,
    func: *FunctionData,
    storage: *llvm.Value,
    insert_after: *llvm.Value,
    inst: *mir.Inst,
    param_nr: i32
) {
    if c.dbg == null {
        return;
    }

    let param = ty.param_at(ty.as_func(func.irfunc.ty), param_nr);

    let surrounding = dbg_get_scope(c.dbg, inst.meta);
    let loc = dbg_create_location(c, inst);
    let ty = dbg_translate_type(c, param.ty);
    dbg.assert(ty != null, "dbg type was null");

    let dbg_local_var = llvm.di_builder_create_parameter_variable(
        c.dbg.builder,
        surrounding,
        ident.start(&param.name), ident.len(&param.name),
        param_nr + 1,
        c.dbg.file,
        inst.meta.pos.lnr,
        ty,
        false,  // always preserve
        0       // flags
    );

    let expr = llvm.di_builder_create_expression(c.dbg.builder, null, 0);

    llvm.di_builder_insert_declare_before(
        c.dbg.builder, storage, dbg_local_var, expr, loc, insert_after
    );
}

def finalize(info: *DebugInfo) {
    llvm.di_builder_finalize(info.builder);
}

def free_dbg_info(info: *DebugInfo) {
    llvm.dispose_di_builder(info.builder);
    ptrvec.free_v(&info.scopes);
    map.free_m(&info.structs);
}
