import "ty";
import "vec";
import "std";
import "span";
import "tyid";
import "ident";
import "lexer";

type Param struct {
    name: ident.Ident,
    ty: tyid.Type
}

def create_param(name: ident.Ident, ty: tyid.Type): Param {
    return Param { name: name, ty: ty };
}

def is_varargs_param(p: *Param): bool {
    return std.memcmp(ident.start(&p.name) as *void, "..." as *void, 3) == 0;
}

type ParamList struct {
    params: vec.Vec
}

def pl_from_vec(params: vec.Vec): ParamList {
    return ParamList { params: params };
}

def free_pl(pl: *ParamList): void {
    pl.params.free();
}

def add_param(pl: *ParamList, p: *Param): void {
    pl.params.push(p as *void);
}

type FuncDef struct {
    is_extern: bool,
    is_method: bool,
    name: ident.Ident,
    receiver: Param,
    ret_ty: tyid.Type,
    params: ParamList,
    func_ty: *ty.Type
}

def create_func(
    name: lexer.Token,
    params: ParamList,
    ret_ty: tyid.Type,
    is_extern: bool
): FuncDef {
    return FuncDef {
        is_extern: is_extern,
        is_method: false,
        name: ident.create(name),
        receiver: undefined,
        ret_ty: ret_ty,
        params: params,
        func_ty: null
    };
}

def create_method(
    name: lexer.Token,
    receiver: Param,
    params: ParamList,
    ret_ty: tyid.Type,
    is_extern: bool
): FuncDef {
    return FuncDef {
        is_extern: is_extern,
        is_method: true,
        name: ident.create(name),
        receiver: receiver,
        ret_ty: ret_ty,
        params: params,
        func_ty: null
    };
}

def (f: *FuncDef) get_param_ptr(i: u32): *Param {
    return f.params.params.get_ptr(i as usize) as *Param;
}

def (f: *FuncDef) num_params(): u32 {
    return f.params.params.len as u32;
}

def free_f(f: *FuncDef) {
    free_pl(&f.params);
}
