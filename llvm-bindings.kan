import "std";

// This module was mainly generated by etc/generate-llvm-bindings.py
// with just a few manual tweaks

// Empty types for LLVM. We can only access these through pointers
type Context struct {}
type Module struct {}
type Builder struct {}
type BasicBlock struct {}
type Func struct {}
type Type struct {}
type Value struct {}
type Target struct {}
type TargetMachine struct {}
type TargetData struct {}
type MemoryBuffer struct {}
type PassManager struct {}
type PassManagerBuilder struct {}
type DbgBuilder struct {}
type MetaData struct {}


// Core
extern def LLVMShutdown(): void;

extern def LLVMCreateMessage(message: string): string;

extern def LLVMDisposeMessage(message: string): void;


def shutdown(): void {
    LLVMShutdown();
}

def create_message(message: string): string {
    return LLVMCreateMessage(message);
}

def dispose_message(message: string): void {
    LLVMDisposeMessage(message);
}


// Core->Contexts
extern def LLVMContextCreate(): *Context;

extern def LLVMContextDispose(c: *Context): void;


def context_create(): *Context {
    return LLVMContextCreate();
}

def context_dispose(c: *Context): void {
    LLVMContextDispose(c);
}


// Core->Modules
extern def LLVMModuleCreateWithNameInContext(module_id: string, c: *Context): *Module;

extern def LLVMDisposeModule(m: *Module): void;

extern def LLVMSetSourceFileName(m: *Module, name: string, len: usize): void;

extern def LLVMSetTarget(m: *Module, triple: string): void;

extern def LLVMAddModuleFlag(m: *Module, behavior: i32, key: string, key_len: usize, val: *MetaData): void;

extern def LLVMDumpModule(m: *Module): void;

extern def LLVMAddFunction(m: *Module, name: string, function_ty: *Type): *Value;

extern def LLVMGetNamedFunction(m: *Module, name: string): *Value;

extern def LLVMGetFirstFunction(m: *Module): *Value;

extern def LLVMGetNextFunction(fn: *Value): *Value;


def module_create_with_name_in_context(module_id: string, c: *Context): *Module {
    return LLVMModuleCreateWithNameInContext(module_id, c);
}

def dispose_module(m: *Module): void {
    LLVMDisposeModule(m);
}
// Set the original source file name of a module to a string Name with length Len.
def set_source_file_name(m: *Module, name: string, len: usize): void {
    LLVMSetSourceFileName(m, name, len);
}

def set_target(m: *Module, triple: string): void {
    LLVMSetTarget(m, triple);
}
// Add a module-level flag to the module-level flags metadata if it doesn't already exist.
def add_module_flag(m: *Module, behavior: i32, key: string, key_len: usize, val: *MetaData): void {
    LLVMAddModuleFlag(m, behavior, key, key_len, val);
}

def dump_module(m: *Module): void {
    LLVMDumpModule(m);
}

def add_function(m: *Module, name: string, function_ty: *Type): *Value {
    return LLVMAddFunction(m, name, function_ty);
}

def get_named_function(m: *Module, name: string): *Value {
    return LLVMGetNamedFunction(m, name);
}

def get_first_function(m: *Module): *Value {
    return LLVMGetFirstFunction(m);
}

def get_next_function(fn: *Value): *Value {
    return LLVMGetNextFunction(fn);
}


// Core->Types
extern def LLVMInt1TypeInContext(c: *Context): *Type;

extern def LLVMInt8TypeInContext(c: *Context): *Type;

extern def LLVMInt16TypeInContext(c: *Context): *Type;

extern def LLVMInt32TypeInContext(c: *Context): *Type;

extern def LLVMInt64TypeInContext(c: *Context): *Type;

extern def LLVMIntTypeInContext(c: *Context, num_bits: u32): *Type;

extern def LLVMFloatTypeInContext(c: *Context): *Type;

extern def LLVMDoubleTypeInContext(c: *Context): *Type;

extern def LLVMFunctionType(return_type: *Type, param_types: **Type, param_count: u32, is_var_arg: i32): *Type;

extern def LLVMStructCreateNamed(c: *Context, name: string): *Type;

extern def LLVMStructSetBody(struct_ty: *Type, element_types: **Type, element_count: u32, packed: i32): void;

extern def LLVMArrayType(element_type: *Type, element_count: u32): *Type;

extern def LLVMPointerType(element_type: *Type, address_space: u32): *Type;

extern def LLVMVoidTypeInContext(c: *Context): *Type;


def int1_type_in_context(c: *Context): *Type {
    return LLVMInt1TypeInContext(c);
}

def int8_type_in_context(c: *Context): *Type {
    return LLVMInt8TypeInContext(c);
}

def int16_type_in_context(c: *Context): *Type {
    return LLVMInt16TypeInContext(c);
}

def int32_type_in_context(c: *Context): *Type {
    return LLVMInt32TypeInContext(c);
}

def int64_type_in_context(c: *Context): *Type {
    return LLVMInt64TypeInContext(c);
}

def int_type_in_context(c: *Context, num_bits: u32): *Type {
    return LLVMIntTypeInContext(c, num_bits);
}

def float_type_in_context(c: *Context): *Type {
    return LLVMFloatTypeInContext(c);
}

def double_type_in_context(c: *Context): *Type {
    return LLVMDoubleTypeInContext(c);
}

def function_type(return_type: *Type, param_types: **Type, param_count: u32, is_var_arg: bool): *Type {
    return LLVMFunctionType(return_type, param_types, param_count, std.bool_to_int(is_var_arg) as i32);
}

def struct_create_named(c: *Context, name: string): *Type {
    return LLVMStructCreateNamed(c, name);
}

def struct_set_body(struct_ty: *Type, element_types: **Type, element_count: u32, packed: bool): void {
    LLVMStructSetBody(struct_ty, element_types, element_count, std.bool_to_int(packed) as i32);
}

def array_type(element_type: *Type, element_count: u32): *Type {
    return LLVMArrayType(element_type, element_count);
}

def pointer_type(element_type: *Type, address_space: u32): *Type {
    return LLVMPointerType(element_type, address_space);
}

def void_type_in_context(c: *Context): *Type {
    return LLVMVoidTypeInContext(c);
}


// Core->Values
extern def LLVMTypeOf(val: *Value): *Type;

extern def LLVMConstNull(ty: *Type): *Value;

extern def LLVMGetUndef(ty: *Type): *Value;

extern def LLVMConstInt(int_ty: *Type, n: usize, sign_extend: i32): *Value;

extern def LLVMConstIntOfString(int_ty: *Type, text: string, radix: u8): *Value;

extern def LLVMConstIntOfStringAndSize(int_ty: *Type, text: string, s_len: u32, radix: u8): *Value;

extern def LLVMConstRealOfString(real_ty: *Type, text: string): *Value;

extern def LLVMConstStringInContext(c: *Context, str: string, length: u32, dont_null_terminate: i32): *Value;

extern def LLVMSizeOf(ty: *Type): *Value;

extern def LLVMSetLinkage(global: *Value, linkage: i32): void;

extern def LLVMSetUnnamedAddress(global: *Value, unnamed_addr: i32): void;

extern def LLVMGetAlignment(v: *Value): u32;

extern def LLVMSetAlignment(v: *Value, bytes: u32): void;

extern def LLVMAddGlobal(m: *Module, ty: *Type, name: string): *Value;

extern def LLVMGetNamedGlobal(m: *Module, name: string): *Value;

extern def LLVMSetInitializer(global_var: *Value, constant_val: *Value): void;

extern def LLVMSetGlobalConstant(global_var: *Value, is_constant: i32): void;

extern def LLVMGetParam(fn: *Value, index: u32): *Value;


def type_of(val: *Value): *Type {
    return LLVMTypeOf(val);
}

def const_null(ty: *Type): *Value {
    return LLVMConstNull(ty);
}

def get_undef(ty: *Type): *Value {
    return LLVMGetUndef(ty);
}

def const_int(int_ty: *Type, n: usize, sign_extend: bool): *Value {
    return LLVMConstInt(int_ty, n, std.bool_to_int(sign_extend) as i32);
}

def const_int_of_string(int_ty: *Type, text: string, radix: u8): *Value {
    return LLVMConstIntOfString(int_ty, text, radix);
}

def const_int_of_string_and_size(int_ty: *Type, text: string, s_len: u32, radix: u8): *Value {
    return LLVMConstIntOfStringAndSize(int_ty, text, s_len, radix);
}

def const_real_of_string(real_ty: *Type, text: string): *Value {
    return LLVMConstRealOfString(real_ty, text);
}

def const_string_in_context(c: *Context, str: string, length: u32, dont_null_terminate: bool): *Value {
    return LLVMConstStringInContext(c, str, length, std.bool_to_int(dont_null_terminate) as i32);
}

def size_of(ty: *Type): *Value {
    return LLVMSizeOf(ty);
}

def set_linkage(global: *Value, linkage: i32): void {
    LLVMSetLinkage(global, linkage);
}

def set_unnamed_address(global: *Value, unnamed_addr: i32): void {
    LLVMSetUnnamedAddress(global, unnamed_addr);
}

def get_alignment(v: *Value): u32 {
    return LLVMGetAlignment(v);
}

def set_alignment(v: *Value, bytes: u32): void {
    LLVMSetAlignment(v, bytes);
}

def add_global(m: *Module, ty: *Type, name: string): *Value {
    return LLVMAddGlobal(m, ty, name);
}

def get_named_global(m: *Module, name: string): *Value {
    return LLVMGetNamedGlobal(m, name);
}

def set_initializer(global_var: *Value, constant_val: *Value): void {
    LLVMSetInitializer(global_var, constant_val);
}

def set_global_constant(global_var: *Value, is_constant: bool): void {
    LLVMSetGlobalConstant(global_var, std.bool_to_int(is_constant) as i32);
}

def get_param(fn: *Value, index: u32): *Value {
    return LLVMGetParam(fn, index);
}


// Core->Metadata
extern def LLVMValueAsMetadata(val: *Value): *MetaData;

// Obtain a Value as Metadata.
def value_as_metadata(val: *Value): *MetaData {
    return LLVMValueAsMetadata(val);
}


// Core->Basic Block
extern def LLVMBasicBlockAsValue(bb: *BasicBlock): *Value;

extern def LLVMAppendBasicBlockInContext(c: *Context, fn: *Value, name: string): *BasicBlock;


def basic_block_as_value(bb: *BasicBlock): *Value {
    return LLVMBasicBlockAsValue(bb);
}

def append_basic_block_in_context(c: *Context, fn: *Value, name: string): *BasicBlock {
    return LLVMAppendBasicBlockInContext(c, fn, name);
}


// Core->Instructions


// Core->Values again; these don't appear in Doxygen because they're macro-generated.


// Core->Extract/Insert Value


// Core->Instruction Builders
extern def LLVMCreateBuilderInContext(c: *Context): *Builder;

extern def LLVMPositionBuilderAtEnd(builder: *Builder, block: *BasicBlock): void;

extern def LLVMGetInsertBlock(builder: *Builder): *BasicBlock;

extern def LLVMDisposeBuilder(builder: *Builder): void;

extern def LLVMSetCurrentDebugLocation2(builder: *Builder, loc: *MetaData): void;

extern def LLVMSetInstDebugLocation(builder: *Builder, inst: *Value): void;

extern def LLVMBuildRetVoid(arg1: *Builder): *Value;

extern def LLVMBuildRet(arg1: *Builder, v: *Value): *Value;

extern def LLVMBuildBr(arg1: *Builder, dest: *BasicBlock): *Value;

extern def LLVMBuildCondBr(arg1: *Builder, if_value: *Value, then: *BasicBlock, else_value: *BasicBlock): *Value;

extern def LLVMBuildAdd(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFAdd(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildSub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFSub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildMul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFMul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildSDiv(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFDiv(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildSRem(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFRem(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildShl(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildAShr(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildAnd(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildOr(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildNeg(arg1: *Builder, v: *Value, name: string): *Value;

extern def LLVMBuildFNeg(arg1: *Builder, v: *Value, name: string): *Value;

extern def LLVMBuildNot(arg1: *Builder, v: *Value, name: string): *Value;

extern def LLVMBuildMalloc(arg1: *Builder, ty: *Type, name: string): *Value;

extern def LLVMBuildMemSet(b: *Builder, ptr: *Value, val: *Value, len: *Value, align: u32): *Value;

extern def LLVMBuildMemCpy(b: *Builder, dst: *Value, dst_align: u32, src: *Value, src_align: u32, size: *Value): *Value;

extern def LLVMBuildAlloca(arg1: *Builder, ty: *Type, name: string): *Value;

extern def LLVMBuildFree(arg1: *Builder, pointer_val: *Value): *Value;

extern def LLVMBuildLoad(arg1: *Builder, pointer_val: *Value, name: string): *Value;

extern def LLVMBuildStore(arg1: *Builder, val: *Value, ptr: *Value): *Value;

extern def LLVMBuildGEP(b: *Builder, pointer: *Value, indices: **Value, num_indices: u32, name: string): *Value;

extern def LLVMBuildInBoundsGEP(b: *Builder, pointer: *Value, indices: **Value, num_indices: u32, name: string): *Value;

extern def LLVMBuildStructGEP(b: *Builder, pointer: *Value, idx: u32, name: string): *Value;

extern def LLVMBuildZExt(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildFPToSI(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildSIToFP(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildFPExt(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildPtrToInt(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildBitCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildPointerCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildIntCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildFPCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildICmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFCmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildCall(arg1: *Builder, fn: *Value, args: **Value, num_args: u32, name: string): *Value;


def create_builder_in_context(c: *Context): *Builder {
    return LLVMCreateBuilderInContext(c);
}

def position_builder_at_end(builder: *Builder, block: *BasicBlock): void {
    LLVMPositionBuilderAtEnd(builder, block);
}

def get_insert_block(builder: *Builder): *BasicBlock {
    return LLVMGetInsertBlock(builder);
}

def dispose_builder(builder: *Builder): void {
    LLVMDisposeBuilder(builder);
}
// Set location information used by debugging information.
def set_current_debug_location2(builder: *Builder, loc: *MetaData): void {
    LLVMSetCurrentDebugLocation2(builder, loc);
}
// Attempts to set the debug location for the given instruction using the
// current debug location for the given builder.  If the builder has no current
// debug location, this function is a no-op.
def set_inst_debug_location(builder: *Builder, inst: *Value): void {
    LLVMSetInstDebugLocation(builder, inst);
}
// Terminators
def build_ret_void(arg1: *Builder): *Value {
    return LLVMBuildRetVoid(arg1);
}

def build_ret(arg1: *Builder, v: *Value): *Value {
    return LLVMBuildRet(arg1, v);
}

def build_br(arg1: *Builder, dest: *BasicBlock): *Value {
    return LLVMBuildBr(arg1, dest);
}

def build_cond_br(arg1: *Builder, if_value: *Value, then: *BasicBlock, else_value: *BasicBlock): *Value {
    return LLVMBuildCondBr(arg1, if_value, then, else_value);
}
// Arithmetic
def build_add(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildAdd(arg1, lhs, rhs, name);
}

def build_f_add(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFAdd(arg1, lhs, rhs, name);
}

def build_sub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildSub(arg1, lhs, rhs, name);
}

def build_f_sub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFSub(arg1, lhs, rhs, name);
}

def build_mul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildMul(arg1, lhs, rhs, name);
}

def build_f_mul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFMul(arg1, lhs, rhs, name);
}

def build_s_div(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildSDiv(arg1, lhs, rhs, name);
}

def build_f_div(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFDiv(arg1, lhs, rhs, name);
}

def build_s_rem(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildSRem(arg1, lhs, rhs, name);
}

def build_f_rem(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFRem(arg1, lhs, rhs, name);
}

def build_shl(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildShl(arg1, lhs, rhs, name);
}

def build_a_shr(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildAShr(arg1, lhs, rhs, name);
}

def build_and(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildAnd(arg1, lhs, rhs, name);
}

def build_or(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildOr(arg1, lhs, rhs, name);
}

def build_neg(arg1: *Builder, v: *Value, name: string): *Value {
    return LLVMBuildNeg(arg1, v, name);
}

def build_f_neg(arg1: *Builder, v: *Value, name: string): *Value {
    return LLVMBuildFNeg(arg1, v, name);
}

def build_not(arg1: *Builder, v: *Value, name: string): *Value {
    return LLVMBuildNot(arg1, v, name);
}
// Memory
def build_malloc(arg1: *Builder, ty: *Type, name: string): *Value {
    return LLVMBuildMalloc(arg1, ty, name);
}

def build_mem_set(b: *Builder, ptr: *Value, val: *Value, len: *Value, align: u32): *Value {
    return LLVMBuildMemSet(b, ptr, val, len, align);
}

def build_mem_cpy(b: *Builder, dst: *Value, dst_align: u32, src: *Value, src_align: u32, size: *Value): *Value {
    return LLVMBuildMemCpy(b, dst, dst_align, src, src_align, size);
}

def build_alloca(arg1: *Builder, ty: *Type, name: string): *Value {
    return LLVMBuildAlloca(arg1, ty, name);
}

def build_free(arg1: *Builder, pointer_val: *Value): *Value {
    return LLVMBuildFree(arg1, pointer_val);
}

def build_load(arg1: *Builder, pointer_val: *Value, name: string): *Value {
    return LLVMBuildLoad(arg1, pointer_val, name);
}

def build_store(arg1: *Builder, val: *Value, ptr: *Value): *Value {
    return LLVMBuildStore(arg1, val, ptr);
}

def build_gep(b: *Builder, pointer: *Value, indices: **Value, num_indices: u32, name: string): *Value {
    return LLVMBuildGEP(b, pointer, indices, num_indices, name);
}

def build_in_bounds_gep(b: *Builder, pointer: *Value, indices: **Value, num_indices: u32, name: string): *Value {
    return LLVMBuildInBoundsGEP(b, pointer, indices, num_indices, name);
}

def build_struct_gep(b: *Builder, pointer: *Value, idx: u32, name: string): *Value {
    return LLVMBuildStructGEP(b, pointer, idx, name);
}

def build_z_ext(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildZExt(arg1, val, dest_ty, name);
}

def build_fp_to_si(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildFPToSI(arg1, val, dest_ty, name);
}

def build_si_to_fp(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildSIToFP(arg1, val, dest_ty, name);
}

def build_fp_ext(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildFPExt(arg1, val, dest_ty, name);
}

def build_ptr_to_int(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildPtrToInt(arg1, val, dest_ty, name);
}

def build_bit_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildBitCast(arg1, val, dest_ty, name);
}

def build_pointer_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildPointerCast(arg1, val, dest_ty, name);
}

def build_int_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildIntCast(arg1, val, dest_ty, name);
}

def build_fp_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildFPCast(arg1, val, dest_ty, name);
}
// Comparisons
def build_i_cmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildICmp(arg1, op, lhs, rhs, name);
}

def build_f_cmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFCmp(arg1, op, lhs, rhs, name);
}

def build_call(arg1: *Builder, fn: *Value, args: **Value, num_args: u32, name: string): *Value {
    return LLVMBuildCall(arg1, fn, args, num_args, name);
}


// Core->Module Providers


// Core->Memory Buffers
extern def LLVMDisposeMemoryBuffer(mem_buf: *MemoryBuffer): void;


def dispose_memory_buffer(mem_buf: *MemoryBuffer): void {
    LLVMDisposeMemoryBuffer(mem_buf);
}


// Core->pass registry


// Core->Pass managers
extern def LLVMCreatePassManager(): *PassManager;

extern def LLVMCreateFunctionPassManagerForModule(m: *Module): *PassManager;

extern def LLVMRunPassManager(pm: *PassManager, m: *Module): i32;

extern def LLVMInitializeFunctionPassManager(fpm: *PassManager): i32;

extern def LLVMRunFunctionPassManager(fpm: *PassManager, f: *Value): i32;

extern def LLVMFinalizeFunctionPassManager(fpm: *PassManager): i32;

extern def LLVMDisposePassManager(pm: *PassManager): void;


def create_pass_manager(): *PassManager {
    return LLVMCreatePassManager();
}

def create_function_pass_manager_for_module(m: *Module): *PassManager {
    return LLVMCreateFunctionPassManagerForModule(m);
}

def run_pass_manager(pm: *PassManager, m: *Module): bool {
    return std.int_to_bool(LLVMRunPassManager(pm, m) as usize);
}

def initialize_function_pass_manager(fpm: *PassManager): bool {
    return std.int_to_bool(LLVMInitializeFunctionPassManager(fpm) as usize);
}

def run_function_pass_manager(fpm: *PassManager, f: *Value): bool {
    return std.int_to_bool(LLVMRunFunctionPassManager(fpm, f) as usize);
}

def finalize_function_pass_manager(fpm: *PassManager): bool {
    return std.int_to_bool(LLVMFinalizeFunctionPassManager(fpm) as usize);
}

def dispose_pass_manager(pm: *PassManager): void {
    LLVMDisposePassManager(pm);
}


// Core->Threading


extern def LLVMLinkModules2(dest: *Module, src: *Module): i32;

// Link the source module into the destination module.
// 
// Destroys the source module, returns true on error. Use the diagnostic
// handler to get any diagnostic message.
def link_modules2(dest: *Module, src: *Module): bool {
    return std.int_to_bool(LLVMLinkModules2(dest, src) as usize);
}


extern def LLVMVerifyModule(m: *Module, action: i32, out_message: *string): i32;

// Verify that a module is valid, taking the specified action if not.
// 
// Optionally returns a human-readable description of any invalid constructs,
// which must be disposed with `LLVMDisposeMessage`.
def verify_module(m: *Module, action: i32, out_message: *string): bool {
    return std.int_to_bool(LLVMVerifyModule(m, action, out_message) as usize);
}


extern def LLVMInitializeX86TargetInfo(): void;

extern def LLVMInitializeX86Target(): void;

extern def LLVMInitializeX86TargetMC(): void;

extern def LLVMInitializeX86AsmPrinter(): void;


def initialize_x86_target_info(): void {
    LLVMInitializeX86TargetInfo();
}

def initialize_x86_target(): void {
    LLVMInitializeX86Target();
}

def initialize_x86_target_mc(): void {
    LLVMInitializeX86TargetMC();
}

def initialize_x86_asm_printer(): void {
    LLVMInitializeX86AsmPrinter();
}


extern def LLVMSetModuleDataLayout(m: *Module, r: *Target): void;

extern def LLVMDisposeTargetData(td: *Target): void;

// Set the data layout for a module.
def set_module_data_layout(m: *Module, r: *Target): void {
    LLVMSetModuleDataLayout(m, r);
}

def dispose_target_data(td: *Target): void {
    LLVMDisposeTargetData(td);
}


// macros (wrappers/target.c).


extern def LLVMGetTargetFromTriple(triple: string, t: **Target, error_message: *string): i32;

extern def LLVMCreateTargetMachine(t: *Target, triple: string, cpu: string, features: string, level: i32, reloc: i32, code_model: i32): *TargetMachine;

extern def LLVMDisposeTargetMachine(t: *TargetMachine): void;

extern def LLVMCreateTargetDataLayout(t: *TargetMachine): *Target;

extern def LLVMTargetMachineEmitToFile(t: *TargetMachine, m: *Module, filename: string, codegen: i32, error_message: *string): i32;

extern def LLVMTargetMachineEmitToMemoryBuffer(t: *TargetMachine, m: *Module, codegen: i32, error_message: *string, out_mem_buf: **MemoryBuffer): i32;


def get_target_from_triple(triple: string, t: **Target, error_message: *string): bool {
    return std.int_to_bool(LLVMGetTargetFromTriple(triple, t, error_message) as usize);
}

def create_target_machine(t: *Target, triple: string, cpu: string, features: string, level: i32, reloc: i32, code_model: i32): *TargetMachine {
    return LLVMCreateTargetMachine(t, triple, cpu, features, level, reloc, code_model);
}

def dispose_target_machine(t: *TargetMachine): void {
    LLVMDisposeTargetMachine(t);
}
// Create a DataLayout based on the target machine.
def create_target_data_layout(t: *TargetMachine): *Target {
    return LLVMCreateTargetDataLayout(t);
}

def target_machine_emit_to_file(t: *TargetMachine, m: *Module, filename: string, codegen: i32, error_message: *string): bool {
    return std.int_to_bool(LLVMTargetMachineEmitToFile(t, m, filename, codegen, error_message) as usize);
}

def target_machine_emit_to_memory_buffer(t: *TargetMachine, m: *Module, codegen: i32, error_message: *string, out_mem_buf: **MemoryBuffer): bool {
    return std.int_to_bool(LLVMTargetMachineEmitToMemoryBuffer(t, m, codegen, error_message, out_mem_buf) as usize);
}


extern def LLVMParseBitcodeInContext2(context_ref: *Context, mem_buf: *MemoryBuffer, out_module: **Module): i32;


def parse_bitcode_in_context2(context_ref: *Context, mem_buf: *MemoryBuffer, out_module: **Module): bool {
    return std.int_to_bool(LLVMParseBitcodeInContext2(context_ref, mem_buf, out_module) as usize);
}


extern def LLVMWriteBitcodeToMemoryBuffer(m: *Module): *MemoryBuffer;

// Writes a module to a new memory buffer.
def write_bitcode_to_memory_buffer(m: *Module): *MemoryBuffer {
    return LLVMWriteBitcodeToMemoryBuffer(m);
}


extern def LLVMPassManagerBuilderCreate(): *PassManagerBuilder;

extern def LLVMPassManagerBuilderDispose(pmb: *PassManagerBuilder): void;

extern def LLVMPassManagerBuilderSetOptLevel(pmb: *PassManagerBuilder, opt_level: u32): void;

extern def LLVMPassManagerBuilderUseInlinerWithThreshold(pmb: *PassManagerBuilder, threshold: u32): void;

extern def LLVMPassManagerBuilderPopulateFunctionPassManager(pmb: *PassManagerBuilder, pm: *PassManager): void;

extern def LLVMPassManagerBuilderPopulateModulePassManager(pmb: *PassManagerBuilder, pm: *PassManager): void;


def pass_manager_builder_create(): *PassManagerBuilder {
    return LLVMPassManagerBuilderCreate();
}

def pass_manager_builder_dispose(pmb: *PassManagerBuilder): void {
    LLVMPassManagerBuilderDispose(pmb);
}

def pass_manager_builder_set_opt_level(pmb: *PassManagerBuilder, opt_level: u32): void {
    LLVMPassManagerBuilderSetOptLevel(pmb, opt_level);
}

def pass_manager_builder_use_inliner_with_threshold(pmb: *PassManagerBuilder, threshold: u32): void {
    LLVMPassManagerBuilderUseInlinerWithThreshold(pmb, threshold);
}

def pass_manager_builder_populate_function_pass_manager(pmb: *PassManagerBuilder, pm: *PassManager): void {
    LLVMPassManagerBuilderPopulateFunctionPassManager(pmb, pm);
}

def pass_manager_builder_populate_module_pass_manager(pmb: *PassManagerBuilder, pm: *PassManager): void {
    LLVMPassManagerBuilderPopulateModulePassManager(pmb, pm);
}


extern def LLVMAddDeadStoreEliminationPass(pm: *PassManager): void;


def add_dead_store_elimination_pass(pm: *PassManager): void {
    LLVMAddDeadStoreEliminationPass(pm);
}


extern def LLVMAddPromoteMemoryToRegisterPass(pm: *PassManager): void;


def add_promote_memory_to_register_pass(pm: *PassManager): void {
    LLVMAddPromoteMemoryToRegisterPass(pm);
}


extern def LLVMCreateDIBuilder(m: *Module): *DbgBuilder;

extern def LLVMDisposeDIBuilder(builder: *DbgBuilder): void;

extern def LLVMDIBuilderFinalize(builder: *DbgBuilder): void;

extern def LLVMDIBuilderCreateCompileUnit(builder: *DbgBuilder, lang: i32, file_ref: *MetaData, producer: string, producer_len: usize, is_optimized: i32, flags: string, flags_len: usize, runtime_ver: u32, split_name: string, split_name_len: usize, kind: i32, dwo_id: u32, split_debug_inlining: i32, debug_info_for_profiling: i32): *MetaData;

extern def LLVMDIBuilderCreateFile(builder: *DbgBuilder, filename: string, filename_len: usize, directory: string, directory_len: usize): *MetaData;

extern def LLVMDIBuilderCreateFunction(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, linkage_name: string, linkage_name_len: usize, file: *MetaData, line_no: u32, ty: *MetaData, is_local_to_unit: i32, is_definition: i32, scope_line: u32, flags: i32, is_optimized: i32): *MetaData;

extern def LLVMDIBuilderCreateLexicalBlock(builder: *DbgBuilder, scope: *MetaData, file: *MetaData, line: u32, column: u32): *MetaData;

extern def LLVMDIBuilderCreateDebugLocation(ctx: *Context, line: u32, column: u32, scope: *MetaData, inlined_at: *MetaData): *MetaData;

extern def LLVMDIBuilderCreateSubroutineType(builder: *DbgBuilder, file: *MetaData, parameter_types: **MetaData, num_parameter_types: u32, flags: i32): *MetaData;

extern def LLVMDIBuilderCreateEnumerator(builder: *DbgBuilder, name: string, name_len: usize, value: i64, is_unsigned: i32): *MetaData;

extern def LLVMDIBuilderCreateEnumerationType(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_number: u32, size_in_bits: u64, align_in_bits: u32, elements: **MetaData, num_elements: u32, class_ty: *MetaData): *MetaData;

extern def LLVMDIBuilderCreateBasicType(builder: *DbgBuilder, name: string, name_len: usize, size_in_bits: u64, encoding: i32, flags: i32): *MetaData;

extern def LLVMDIBuilderCreatePointerType(builder: *DbgBuilder, pointee_ty: *MetaData, size_in_bits: u64, align_in_bits: u32, address_space: u32, name: string, name_len: usize): *MetaData;

extern def LLVMDIBuilderCreateStructType(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_number: u32, size_in_bits: u64, align_in_bits: u32, flags: i32, derived_from: *MetaData, elements: **MetaData, num_elements: u32, run_time_lang: u32, v_table_holder: *MetaData, unique_id: string, unique_id_len: usize): *MetaData;

extern def LLVMDIBuilderCreateMemberType(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_no: u32, size_in_bits: u64, align_in_bits: u32, offset_in_bits: u64, flags: i32, ty: *MetaData): *MetaData;

extern def LLVMDIBuilderCreateForwardDecl(builder: *DbgBuilder, tag: u32, name: string, name_len: usize, scope: *MetaData, file: *MetaData, line: u32, runtime_lang: u32, size_in_bits: u64, align_in_bits: u32, unique_identifier: string, unique_identifier_len: usize): *MetaData;

extern def LLVMDIBuilderCreateExpression(builder: *DbgBuilder, addr: *i64, length: usize): *MetaData;

extern def LLVMDIBuilderCreateConstantValueExpression(builder: *DbgBuilder, value: i64): *MetaData;

extern def LLVMDIBuilderInsertDeclareBefore(builder: *DbgBuilder, storage: *Value, var_info: *MetaData, expr: *MetaData, debug_loc: *MetaData, instr: *Value): *Value;

extern def LLVMDIBuilderCreateAutoVariable(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_no: u32, ty: *MetaData, always_preserve: i32, flags: i32, align_in_bits: u32): *MetaData;

extern def LLVMDIBuilderCreateParameterVariable(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, arg_no: u32, file: *MetaData, line_no: u32, ty: *MetaData, always_preserve: i32, flags: i32): *MetaData;

extern def LLVMSetSubprogram(func: *Value, sp: *MetaData): void;

// Construct a builder for a module and collect unresolved nodes.
def create_di_builder(m: *Module): *DbgBuilder {
    return LLVMCreateDIBuilder(m);
}
// Deallocate a builder and everything it owns.
// 
// The builder must be finalized before this.
def dispose_di_builder(builder: *DbgBuilder): void {
    LLVMDisposeDIBuilder(builder);
}
// Construct any deferred debug info descriptors.
def di_builder_finalize(builder: *DbgBuilder): void {
    LLVMDIBuilderFinalize(builder);
}

def di_builder_create_compile_unit(builder: *DbgBuilder, lang: i32, file_ref: *MetaData, producer: string, producer_len: usize, is_optimized: bool, flags: string, flags_len: usize, runtime_ver: u32, split_name: string, split_name_len: usize, kind: i32, dwo_id: u32, split_debug_inlining: bool, debug_info_for_profiling: bool): *MetaData {
    return LLVMDIBuilderCreateCompileUnit(builder, lang, file_ref, producer, producer_len, std.bool_to_int(is_optimized) as i32, flags, flags_len, runtime_ver, split_name, split_name_len, kind, dwo_id, std.bool_to_int(split_debug_inlining) as i32, std.bool_to_int(debug_info_for_profiling) as i32);
}
// Create a file descriptor to hold debugging information for a file.
def di_builder_create_file(builder: *DbgBuilder, filename: string, filename_len: usize, directory: string, directory_len: usize): *MetaData {
    return LLVMDIBuilderCreateFile(builder, filename, filename_len, directory, directory_len);
}
// Create a new descriptor for the specified subprogram.
def di_builder_create_function(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, linkage_name: string, linkage_name_len: usize, file: *MetaData, line_no: u32, ty: *MetaData, is_local_to_unit: bool, is_definition: bool, scope_line: u32, flags: i32, is_optimized: bool): *MetaData {
    return LLVMDIBuilderCreateFunction(builder, scope, name, name_len, linkage_name, linkage_name_len, file, line_no, ty, std.bool_to_int(is_local_to_unit) as i32, std.bool_to_int(is_definition) as i32, scope_line, flags, std.bool_to_int(is_optimized) as i32);
}
// Create a descriptor for a lexical block with the specified parent context.
def di_builder_create_lexical_block(builder: *DbgBuilder, scope: *MetaData, file: *MetaData, line: u32, column: u32): *MetaData {
    return LLVMDIBuilderCreateLexicalBlock(builder, scope, file, line, column);
}
// Creates a new DebugLocation that describes a source location.
def di_builder_create_debug_location(ctx: *Context, line: u32, column: u32, scope: *MetaData, inlined_at: *MetaData): *MetaData {
    return LLVMDIBuilderCreateDebugLocation(ctx, line, column, scope, inlined_at);
}
// Create subroutine type.
def di_builder_create_subroutine_type(builder: *DbgBuilder, file: *MetaData, parameter_types: **MetaData, num_parameter_types: u32, flags: i32): *MetaData {
    return LLVMDIBuilderCreateSubroutineType(builder, file, parameter_types, num_parameter_types, flags);
}
// Create debugging information entry for an enumerator.
def di_builder_create_enumerator(builder: *DbgBuilder, name: string, name_len: usize, value: i64, is_unsigned: bool): *MetaData {
    return LLVMDIBuilderCreateEnumerator(builder, name, name_len, value, std.bool_to_int(is_unsigned) as i32);
}
// Create debugging information entry for an enumeration.
def di_builder_create_enumeration_type(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_number: u32, size_in_bits: u64, align_in_bits: u32, elements: **MetaData, num_elements: u32, class_ty: *MetaData): *MetaData {
    return LLVMDIBuilderCreateEnumerationType(builder, scope, name, name_len, file, line_number, size_in_bits, align_in_bits, elements, num_elements, class_ty);
}
// Create debugging information entry for a basic type.
def di_builder_create_basic_type(builder: *DbgBuilder, name: string, name_len: usize, size_in_bits: u64, encoding: i32, flags: i32): *MetaData {
    return LLVMDIBuilderCreateBasicType(builder, name, name_len, size_in_bits, encoding, flags);
}
// Create debugging information entry for a pointer.
def di_builder_create_pointer_type(builder: *DbgBuilder, pointee_ty: *MetaData, size_in_bits: u64, align_in_bits: u32, address_space: u32, name: string, name_len: usize): *MetaData {
    return LLVMDIBuilderCreatePointerType(builder, pointee_ty, size_in_bits, align_in_bits, address_space, name, name_len);
}
// Create debugging information entry for a struct.
def di_builder_create_struct_type(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_number: u32, size_in_bits: u64, align_in_bits: u32, flags: i32, derived_from: *MetaData, elements: **MetaData, num_elements: u32, run_time_lang: u32, v_table_holder: *MetaData, unique_id: string, unique_id_len: usize): *MetaData {
    return LLVMDIBuilderCreateStructType(builder, scope, name, name_len, file, line_number, size_in_bits, align_in_bits, flags, derived_from, elements, num_elements, run_time_lang, v_table_holder, unique_id, unique_id_len);
}
// Create debugging information entry for a member.
def di_builder_create_member_type(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_no: u32, size_in_bits: u64, align_in_bits: u32, offset_in_bits: u64, flags: i32, ty: *MetaData): *MetaData {
    return LLVMDIBuilderCreateMemberType(builder, scope, name, name_len, file, line_no, size_in_bits, align_in_bits, offset_in_bits, flags, ty);
}
// Create a permanent forward-declared type.
def di_builder_create_forward_decl(builder: *DbgBuilder, tag: u32, name: string, name_len: usize, scope: *MetaData, file: *MetaData, line: u32, runtime_lang: u32, size_in_bits: u64, align_in_bits: u32, unique_identifier: string, unique_identifier_len: usize): *MetaData {
    return LLVMDIBuilderCreateForwardDecl(builder, tag, name, name_len, scope, file, line, runtime_lang, size_in_bits, align_in_bits, unique_identifier, unique_identifier_len);
}
// Create a new descriptor for the specified variable which has a complex
def di_builder_create_expression(builder: *DbgBuilder, addr: *i64, length: usize): *MetaData {
    return LLVMDIBuilderCreateExpression(builder, addr, length);
}
// Create a new descriptor for the specified variable that does not have an
def di_builder_create_constant_value_expression(builder: *DbgBuilder, value: i64): *MetaData {
    return LLVMDIBuilderCreateConstantValueExpression(builder, value);
}
// Insert a new llvm.dbg.declare intrinsic call before the given instruction.
def di_builder_insert_declare_before(builder: *DbgBuilder, storage: *Value, var_info: *MetaData, expr: *MetaData, debug_loc: *MetaData, instr: *Value): *Value {
    return LLVMDIBuilderInsertDeclareBefore(builder, storage, var_info, expr, debug_loc, instr);
}
// Create a new descriptor for a local auto variable.
def di_builder_create_auto_variable(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, file: *MetaData, line_no: u32, ty: *MetaData, always_preserve: bool, flags: i32, align_in_bits: u32): *MetaData {
    return LLVMDIBuilderCreateAutoVariable(builder, scope, name, name_len, file, line_no, ty, std.bool_to_int(always_preserve) as i32, flags, align_in_bits);
}
// Create a new descriptor for a function parameter variable.
def di_builder_create_parameter_variable(builder: *DbgBuilder, scope: *MetaData, name: string, name_len: usize, arg_no: u32, file: *MetaData, line_no: u32, ty: *MetaData, always_preserve: bool, flags: i32): *MetaData {
    return LLVMDIBuilderCreateParameterVariable(builder, scope, name, name_len, arg_no, file, line_no, ty, std.bool_to_int(always_preserve) as i32, flags);
}
// Set the subprogram attached to a function.
def set_subprogram(func: *Value, sp: *MetaData): void {
    LLVMSetSubprogram(func, sp);
}


