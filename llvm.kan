import "std";

// This module was mainly generated by etc/generate-llvm-bindings.py
// with just a few manual tweaks

// Empty types for LLVM. We can only access these through pointers
type Context struct {}
type Module struct {}
type Builder struct {}
type BasicBlock struct {}
type Func struct {}
type Type struct {}
type Value struct {}


// Core
extern def LLVMShutdown(): void;

extern def LLVMCreateMessage(message: string): string;

extern def LLVMDisposeMessage(message: string): void;


def shutdown(): void {
    LLVMShutdown();
}

def create_message(message: string): string {
    return LLVMCreateMessage(message);
}

def dispose_message(message: string): void {
    LLVMDisposeMessage(message);
}


// Core->Contexts
extern def LLVMContextCreate(): *Context;

extern def LLVMContextDispose(c: *Context): void;


def context_create(): *Context {
    return LLVMContextCreate();
}

def context_dispose(c: *Context): void {
    LLVMContextDispose(c);
}


// Core->Modules
extern def LLVMModuleCreateWithNameInContext(module_id: string, c: *Context): *Module;

extern def LLVMDisposeModule(m: *Module): void;

extern def LLVMSetSourceFileName(m: *Module, name: string, len: *void): void;

extern def LLVMDumpModule(m: *Module): void;

extern def LLVMAddFunction(m: *Module, name: string, function_ty: *Type): *Value;

extern def LLVMGetNamedFunction(m: *Module, name: string): *Value;


def module_create_with_name_in_context(module_id: string, c: *Context): *Module {
    return LLVMModuleCreateWithNameInContext(module_id, c);
}

def dispose_module(m: *Module): void {
    LLVMDisposeModule(m);
}

// Set the original source file name of a module to a string Name with length Len.
def set_source_file_name(m: *Module, name: string, len: i32): void {
    LLVMSetSourceFileName(m, name, std.int_to_ptr(len));
}

def dump_module(m: *Module): void {
    LLVMDumpModule(m);
}

def add_function(m: *Module, name: string, function_ty: *Type): *Value {
    return LLVMAddFunction(m, name, function_ty);
}

def get_named_function(m: *Module, name: string): *Value {
    return LLVMGetNamedFunction(m, name);
}


// Core->Types
extern def LLVMInt1TypeInContext(c: *Context): *Type;

extern def LLVMInt8TypeInContext(c: *Context): *Type;

extern def LLVMInt32TypeInContext(c: *Context): *Type;

extern def LLVMInt64TypeInContext(c: *Context): *Type;

extern def LLVMFloatTypeInContext(c: *Context): *Type;

extern def LLVMDoubleTypeInContext(c: *Context): *Type;

extern def LLVMFunctionType(return_type: *Type, param_types: **Type, param_count: i32, is_var_arg: i32): *Type;

extern def LLVMStructCreateNamed(c: *Context, name: string): *Type;

extern def LLVMStructSetBody(struct_ty: *Type, element_types: **Type, element_count: i32, packed: i32): void;

extern def LLVMArrayType(element_type: *Type, element_count: i32): *Type;

extern def LLVMPointerType(element_type: *Type, address_space: i32): *Type;

extern def LLVMVoidTypeInContext(c: *Context): *Type;


def int1_type_in_context(c: *Context): *Type {
    return LLVMInt1TypeInContext(c);
}

def int8_type_in_context(c: *Context): *Type {
    return LLVMInt8TypeInContext(c);
}

def int32_type_in_context(c: *Context): *Type {
    return LLVMInt32TypeInContext(c);
}

def int64_type_in_context(c: *Context): *Type {
    return LLVMInt64TypeInContext(c);
}

def float_type_in_context(c: *Context): *Type {
    return LLVMFloatTypeInContext(c);
}

def double_type_in_context(c: *Context): *Type {
    return LLVMDoubleTypeInContext(c);
}

def function_type(return_type: *Type, param_types: **Type, param_count: i32, is_var_arg: bool): *Type {
    return LLVMFunctionType(return_type, param_types, param_count, std.bool_to_int(is_var_arg));
}

def struct_create_named(c: *Context, name: string): *Type {
    return LLVMStructCreateNamed(c, name);
}

def struct_set_body(struct_ty: *Type, element_types: **Type, element_count: i32, packed: bool): void {
    LLVMStructSetBody(struct_ty, element_types, element_count, std.bool_to_int(packed));
}

def array_type(element_type: *Type, element_count: i32): *Type {
    return LLVMArrayType(element_type, element_count);
}

def pointer_type(element_type: *Type, address_space: i32): *Type {
    return LLVMPointerType(element_type, address_space);
}

def void_type_in_context(c: *Context): *Type {
    return LLVMVoidTypeInContext(c);
}


// Core->Values
extern def LLVMTypeOf(val: *Value): *Type;

extern def LLVMConstNull(ty: *Type): *Value;

extern def LLVMConstInt(int_ty: *Type, n: *void, sign_extend: i32): *Value;

extern def LLVMConstIntOfString(int_ty: *Type, text: string, radix: char): *Value;

extern def LLVMConstRealOfString(real_ty: *Type, text: string): *Value;

extern def LLVMConstStringInContext(c: *Context, str: string, length: i32, dont_null_terminate: i32): *Value;

extern def LLVMSizeOf(ty: *Type): *Value;

extern def LLVMSetLinkage(global: *Value, linkage: i32): void;

extern def LLVMSetUnnamedAddress(global: *Value, unnamed_addr: i32): void;

extern def LLVMAddGlobal(m: *Module, ty: *Type, name: string): *Value;

extern def LLVMSetInitializer(global_var: *Value, constant_val: *Value): void;

extern def LLVMSetGlobalConstant(global_var: *Value, is_constant: i32): void;

extern def LLVMGetParam(fn: *Value, index: i32): *Value;


def type_of(val: *Value): *Type {
    return LLVMTypeOf(val);
}

def const_null(ty: *Type): *Value {
    return LLVMConstNull(ty);
}

def const_int(int_ty: *Type, n: i32, sign_extend: bool): *Value {
    return LLVMConstInt(int_ty, std.int_to_ptr(n), std.bool_to_int(sign_extend));
}

def const_int_of_string(int_ty: *Type, text: string, radix: i32): *Value {
    return LLVMConstIntOfString(int_ty, text, std.int_to_char(radix));
}

def const_real_of_string(real_ty: *Type, text: string): *Value {
    return LLVMConstRealOfString(real_ty, text);
}

def const_string_in_context(c: *Context, str: string, length: i32, dont_null_terminate: bool): *Value {
    return LLVMConstStringInContext(c, str, length, std.bool_to_int(dont_null_terminate));
}

def size_of(ty: *Type): *Value {
    return LLVMSizeOf(ty);
}

def set_linkage(global: *Value, linkage: i32): void {
    LLVMSetLinkage(global, linkage);
}

def set_unnamed_address(global: *Value, unnamed_addr: i32): void {
    LLVMSetUnnamedAddress(global, unnamed_addr);
}

def add_global(m: *Module, ty: *Type, name: string): *Value {
    return LLVMAddGlobal(m, ty, name);
}

def set_initializer(global_var: *Value, constant_val: *Value): void {
    LLVMSetInitializer(global_var, constant_val);
}

def set_global_constant(global_var: *Value, is_constant: bool): void {
    LLVMSetGlobalConstant(global_var, std.bool_to_int(is_constant));
}

def get_param(fn: *Value, index: i32): *Value {
    return LLVMGetParam(fn, index);
}


// Core->Basic Block
extern def LLVMAppendBasicBlockInContext(c: *Context, fn: *Value, name: string): *BasicBlock;


def append_basic_block_in_context(c: *Context, fn: *Value, name: string): *BasicBlock {
    return LLVMAppendBasicBlockInContext(c, fn, name);
}


// Core->Instruction Builders
extern def LLVMCreateBuilderInContext(c: *Context): *Builder;

extern def LLVMPositionBuilderAtEnd(builder: *Builder, block: *BasicBlock): void;

extern def LLVMDisposeBuilder(builder: *Builder): void;

extern def LLVMBuildRetVoid(arg1: *Builder): *Value;

extern def LLVMBuildRet(arg1: *Builder, v: *Value): *Value;

extern def LLVMBuildBr(arg1: *Builder, dest: *BasicBlock): *Value;

extern def LLVMBuildCondBr(arg1: *Builder, if_value: *Value, then: *BasicBlock, else_value: *BasicBlock): *Value;

extern def LLVMBuildAdd(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFAdd(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildSub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFSub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildMul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFMul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildSDiv(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFDiv(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildSRem(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildAnd(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildOr(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildNeg(arg1: *Builder, v: *Value, name: string): *Value;

extern def LLVMBuildNot(arg1: *Builder, v: *Value, name: string): *Value;

extern def LLVMBuildMalloc(arg1: *Builder, ty: *Type, name: string): *Value;

extern def LLVMBuildAlloca(arg1: *Builder, ty: *Type, name: string): *Value;

extern def LLVMBuildFree(arg1: *Builder, pointer_val: *Value): *Value;

extern def LLVMBuildLoad(arg1: *Builder, pointer_val: *Value, name: string): *Value;

extern def LLVMBuildStore(arg1: *Builder, val: *Value, ptr: *Value): *Value;

extern def LLVMBuildGEP(b: *Builder, pointer: *Value, indices: **Value, num_indices: i32, name: string): *Value;

extern def LLVMBuildInBoundsGEP(b: *Builder, pointer: *Value, indices: **Value, num_indices: i32, name: string): *Value;

extern def LLVMBuildStructGEP(b: *Builder, pointer: *Value, idx: i32, name: string): *Value;

extern def LLVMBuildFPExt(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildPtrToInt(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildBitCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildPointerCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildIntCast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value;

extern def LLVMBuildICmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildFCmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value;

extern def LLVMBuildCall(arg1: *Builder, fn: *Value, args: **Value, num_args: i32, name: string): *Value;


def create_builder_in_context(c: *Context): *Builder {
    return LLVMCreateBuilderInContext(c);
}

def position_builder_at_end(builder: *Builder, block: *BasicBlock): void {
    LLVMPositionBuilderAtEnd(builder, block);
}

def dispose_builder(builder: *Builder): void {
    LLVMDisposeBuilder(builder);
}
// Terminators
def build_ret_void(arg1: *Builder): *Value {
    return LLVMBuildRetVoid(arg1);
}

def build_ret(arg1: *Builder, v: *Value): *Value {
    return LLVMBuildRet(arg1, v);
}

def build_br(arg1: *Builder, dest: *BasicBlock): *Value {
    return LLVMBuildBr(arg1, dest);
}

def build_cond_br(arg1: *Builder, if_value: *Value, then: *BasicBlock, else_value: *BasicBlock): *Value {
    return LLVMBuildCondBr(arg1, if_value, then, else_value);
}
// Arithmetic
def build_add(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildAdd(arg1, lhs, rhs, name);
}

def build_f_add(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFAdd(arg1, lhs, rhs, name);
}

def build_sub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildSub(arg1, lhs, rhs, name);
}

def build_f_sub(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFSub(arg1, lhs, rhs, name);
}

def build_mul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildMul(arg1, lhs, rhs, name);
}

def build_f_mul(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFMul(arg1, lhs, rhs, name);
}

def build_s_div(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildSDiv(arg1, lhs, rhs, name);
}

def build_f_div(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFDiv(arg1, lhs, rhs, name);
}

def build_s_rem(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildSRem(arg1, lhs, rhs, name);
}

def build_and(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildAnd(arg1, lhs, rhs, name);
}

def build_or(arg1: *Builder, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildOr(arg1, lhs, rhs, name);
}

def build_neg(arg1: *Builder, v: *Value, name: string): *Value {
    return LLVMBuildNeg(arg1, v, name);
}

def build_not(arg1: *Builder, v: *Value, name: string): *Value {
    return LLVMBuildNot(arg1, v, name);
}
// Memory
def build_malloc(arg1: *Builder, ty: *Type, name: string): *Value {
    return LLVMBuildMalloc(arg1, ty, name);
}

def build_alloca(arg1: *Builder, ty: *Type, name: string): *Value {
    return LLVMBuildAlloca(arg1, ty, name);
}

def build_free(arg1: *Builder, pointer_val: *Value): *Value {
    return LLVMBuildFree(arg1, pointer_val);
}

def build_load(arg1: *Builder, pointer_val: *Value, name: string): *Value {
    return LLVMBuildLoad(arg1, pointer_val, name);
}

def build_store(arg1: *Builder, val: *Value, ptr: *Value): *Value {
    return LLVMBuildStore(arg1, val, ptr);
}

def build_gep(b: *Builder, pointer: *Value, indices: **Value, num_indices: i32, name: string): *Value {
    return LLVMBuildGEP(b, pointer, indices, num_indices, name);
}

def build_in_bounds_gep(b: *Builder, pointer: *Value, indices: **Value, num_indices: i32, name: string): *Value {
    return LLVMBuildInBoundsGEP(b, pointer, indices, num_indices, name);
}

def build_struct_gep(b: *Builder, pointer: *Value, idx: i32, name: string): *Value {
    return LLVMBuildStructGEP(b, pointer, idx, name);
}

def build_fp_ext(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildFPExt(arg1, val, dest_ty, name);
}

def build_ptr_to_int(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildPtrToInt(arg1, val, dest_ty, name);
}

def build_bit_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildBitCast(arg1, val, dest_ty, name);
}

def build_pointer_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildPointerCast(arg1, val, dest_ty, name);
}

def build_int_cast(arg1: *Builder, val: *Value, dest_ty: *Type, name: string): *Value {
    return LLVMBuildIntCast(arg1, val, dest_ty, name);
}
// Comparisons
def build_i_cmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildICmp(arg1, op, lhs, rhs, name);
}

def build_f_cmp(arg1: *Builder, op: i32, lhs: *Value, rhs: *Value, name: string): *Value {
    return LLVMBuildFCmp(arg1, op, lhs, rhs, name);
}

def build_call(arg1: *Builder, fn: *Value, args: **Value, num_args: i32, name: string): *Value {
    return LLVMBuildCall(arg1, fn, args, num_args, name);
}


// Linker

extern def LLVMLinkModules2(dest: *Module, src: *Module): i32;

// Link the source module into the destination module.
//
// Destroys the source module, returns true on error. Use the diagnostic
// handler to get any diagnostic message.
def link_modules2(dest: *Module, src: *Module): bool {
    return std.int_to_bool(LLVMLinkModules2(dest, src));
}

// Analysis

extern def LLVMVerifyModule(m: *Module, action: i32, out_message: *string): i32;

// Verify that a module is valid, taking the specified action if not.
//
// Optionally returns a human-readable description of any invalid constructs,
// which must be disposed with `LLVMDisposeMessage`.
def verify_module(m: *Module, action: i32, out_message: *string): bool {
    return std.int_to_bool(LLVMVerifyModule(m, action, out_message));
}
