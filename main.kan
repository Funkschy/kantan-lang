import "parser";
import "io";
import "ast";
import "reader";
import "std";
import "span";
import "source";
import "mod";

def main(argc: i32, argv: *string): void {
    if argc <= 1 {
        io.printf("ERROR: no input files\n");
        return;
    }

    let span_interner = span.create_interner();

    let file_map = reader.create();
    let res = reader.add_all(&file_map, argc, argv);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        reader.free_fm(&file_map);
        return;
    }

    let i = 0;
    while i < reader.num_files(&file_map) {
        let src = reader.get_by_idx(&file_map, i);
        io.printf("Compiling %s\n", source.file_name(&src));
        let p = parser.create(source.code(&src), &span_interner, i);
        let mod = parser.parse(&p);

        if parser.num_errs(&p) > 0 {
            io.printf("%d errors found\n", parser.num_errs(&p));
            print_parse_errors(&p, &span_interner, &file_map);
            parser.free_p(&p);
        }

        let num_imports = mod.num_imports(&mod);
        let j = 0;
        while j < num_imports {
            let is = mod.get_import_at(&mod, j);
            let len = span.get(&span_interner, is.path_span).len;
            io.printf("import '%.*s'\n", len, is.mod_path);

            j = j + 1;
        }

        io.printf("%d functions\n", mod.num_functions(&mod));
        if mod.num_functions(&mod) > 0 {
            let first = mod.get_function_at(&mod, 0);
            let s = ident.to_string(&first.decl.ret_ty, &span_interner);
            let name = ident.to_string(&first.decl.name, &span_interner);
            io.printf("%s: %s\n", name, s);
            delete s;
            delete name;
        }

        // just get the first stmt
        let s = mod.get_stmt(&mod, 0);

        if s != null {
            let is_expr = ast.is_expr_stmt(s);
            io.printf("is expr: %d\n", is_expr);

            if is_expr {
                let e = ast.as_expr_stmt(s).expr;

                let s = ast.expr_to_string(e, &span_interner);
                io.printf("%s\n", s);
                delete s;
            } else if ast.is_let_stmt(s) {
                let ls = ast.as_let_stmt(s);

                let ident: string = ls.ident.ident;
                let ident_len = span.get(&span_interner, ls.ident.ident_span).len;
                let value = ast.expr_to_string(ls.value, &span_interner);

                io.printf("let %.*s = %s;\n", ident_len, ident, value);
                delete value;
            }
        } else {
            io.printf("ERROR: no valid statement in file\n");
        }

        mod.free_m(&mod);
        i = i + 1;
    }

    reader.free_fm(&file_map);
}

def print_parse_errors(p: *parser.Parser, si: *span.SpanInterner, fm: *reader.FileMap): void {
    let err = parser.ParseError { span: span.empty(), text: null };
    let i = 0;
    while i < parser.num_errs(p) {
        parser.get_err(p, i, &err);
        let span = span.get(si, err.span);
        let src = reader.get_by_idx(fm, span.ctx);

        print_parse_error(&err, &span, &src);

        i = i + 1;
    }
}

def print_parse_error(err: *parser.ParseError, span: *span.BigSpan, file: *source.SourceFile): void {
    io.printf(
        "ERROR: %s\n--> %s:%d:%d\n\n",
        err.text,
        source.file_name(file),
        span.start,
        span.start + span.len
    );
}
