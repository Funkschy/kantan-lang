#include "std.h"
 // #define DEBUG
#define DEBUG_ASSERT 0

import "parser";
import "io";
import "ast";
import "reader";
import "std";
import "span";
import "source";
import "mod";
import "tyid";
import "record";

import "ty";
import "ptrvec";
import "tychk";
import "path";

def main(argc: i32, argv: *string): i32 {
    if argc <= 1 {
        io.printf("ERROR: no input files\n");
        return - 1;
    }

    // get the current working directory, so we can resolve file paths
    // relative to it
    let cwd_buf = path.get_cwd();
    let cwd = cwd_buf.inner;

    let num_total_errs = 0;

    let file_map = reader.create();
    let res = reader.add_std_lib(&file_map, &cwd);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        path.free_pb(&cwd_buf);
        reader.free_fm(&file_map);
        return -2;
    }

    let res = reader.add_all(&file_map, &cwd, argc - 1, argv + 1);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        path.free_pb(&cwd_buf);
        reader.free_fm(&file_map);
        return -3;
    }

    let mm = mod.map_with_cap(reader.num_files(&file_map));

    let i = 0;
    while i < reader.num_files(&file_map) {
        let src = reader.get_by_idx(&file_map, i);
        let p = parser.create(src);
        let curr_mod = parser.parse(&p);

        let num_errs = parser.num_errs(&p);
        num_total_errs = num_total_errs + num_errs;
        if num_errs > 0 {
            io.printf("%d parse errors found\n", num_errs);
            print_parse_errors(&p, &file_map, &cwd);
        }

        mod.add_mod(&mm, curr_mod);
        print_dbg_mod_info(curr_mod);

        // just get the first stmt
        let s = mod.get_stmt(curr_mod, 0);

        if s != null {
            print_dbg_stmt_info(s);
        } else {
            io.printf("ERROR: no valid statement in file\n");
        }

        parser.free_p(&p);
        i = i + 1;
    }

    // TODO(#5): only type check, if no parse errors where found?
    //  this does not seem to be a problem right now
    let tc = tychk.create(&mm);
    tychk.check(&tc);

    let num_errs = tychk.num_errs(&tc);
    num_total_errs = num_total_errs + num_errs;
    if num_errs > 0 {
        io.printf("%d type errors found\n", num_errs);
        print_type_errors(&tc, &file_map, &cwd);
    }

    tychk.free_tc(&tc);
    reader.free_fm(&file_map);
    mod.map_free(&mm);
    path.free_pb(&cwd_buf);

    return num_total_errs;
}

def print_dbg_stmt_info(s: *ast.Stmt): void {
#ifdef DEBUG
    let is_expr = ast.is_expr_stmt(s);
    io.printf("is expr: %d\n", is_expr);

    if is_expr {
        let e = ast.as_expr_stmt(s).expr;

        let s = ast.expr_to_string(e);
        io.printf("%s\n", s);
        delete s;

        if ast.is_int_expr(e) {
            ty.make_i32(e.ty);
            io.printf("width: %d, align: %d\n", e.ty.width, e.ty.align);
        }

    } else if ast.is_struct_decl_stmt(s) {
        let decl_s = ast.as_struct_decl_stmt(s);
        let s = record.to_string(&decl_s.decl);
        io.printf("%s\n", s);
        delete s;
    } else if ast.is_let_stmt(s) {
        let ls = ast.as_let_stmt(s);

        let ident: string = ident.start(&ls.ident);
        let ident_len = ident.len(&ls.ident);
        let value = ast.expr_to_string(ls.value);

        let ty = (new '\0') as string;
        if ast.has_type_decl(ls) {
            delete ty;
            let tys = tyid.to_string(&ls.ty);
            ty = std.format_str(": %s", tys);
            delete tys;
        }

        io.printf("let %.*s%s = %s;\n", ident_len, ident, ty, value);
        delete value;
        delete ty;
    }
#endif
}

def print_dbg_mod_info(curr_mod: *mod.Module): void {
#ifdef DEBUG
    let num_imports = mod.num_imports(curr_mod);
    let j = 0;
    while j < num_imports {
        let is = mod.get_import_at(curr_mod, j);
        let s = ident.to_string(&is.curr_mod);
        io.printf("import '%s'\n", s);
        delete s;

        j = j + 1;
    }

    io.printf("%d functions\n", mod.num_functions(curr_mod));
    if mod.num_functions(curr_mod) > 0 {
        let first = mod.get_function_at(curr_mod, 0);
        let s = tyid.to_string(&first.decl.ret_ty);
        let name = ident.to_string(&first.decl.name);
        io.printf("def %s: %s\n", name, s);
        delete s;
        delete name;
    }

    io.printf("%d structs\n", mod.num_structs(curr_mod));
    if mod.num_structs(curr_mod) > 0 {
        let first = mod.get_struct_at(curr_mod, 0);
        let s = record.to_string(&first.decl);
        io.printf("%s\n", s);
        delete s;
    }
#endif
}

def print_parse_errors(
    p: *parser.Parser,
    fm: *reader.FileMap,
    abs_path: *path.Path
): void {
    let i = 0;
    while i < parser.num_errs(p) {
        let err = parser.get_err(p, i);
        let span = err.span;
        let src = reader.get_ptr_from_span(fm, &span);

        print_error(err.text, &span, src, abs_path);

        i = i + 1;
    }
}

def print_type_errors(
    tc: *tychk.TypeChecker,
    fm: *reader.FileMap,
    abs_path: *path.Path
): void {
    let i = 0;
    while i < tychk.num_errs(tc) {
        let err = tychk.get_err(tc, i);
        let span = err.span;
        let src = reader.get_ptr_from_span(fm, &span);

        print_error(err.text, &span, src, abs_path);

        i = i + 1;
    }
}

def printf_spanned(span: span.Span, file: *source.SourceFile): void {
    io.printf(" | %.*s\n", span.len(span), span.start);
}

def print_error(
    err_text: string,
    span: *span.Span,
    file: *source.SourceFile,
    abs_path: *path.Path
): void {
    let last_nl = 0;
    let line = source.find_line(span, file, &last_nl);
    let name = source.file_name_dup(file);
    let offset = 0;
    let file_path = &file.file.path.inner;
    let col = span.start - file.code - last_nl;

    // TODO(#13): this only works when the filepath is in a subdir of abs_path
    //  i don't actually know, if this is still a problem, this needs to be
    //  experimented with
    if path.is_abs(file_path) {
        let overlap = path.count_overlap(abs_path, file_path);
        if overlap == abs_path.len {
            offset = overlap + 1;
        }
    }

    io.printf(
        "ERROR: %s\n--> %s:%d:%d\n",
        err_text,
        name + offset,
        line.start_number,
        col
    );

    printf_spanned(line.span, file);
    io.printf("\n");

    delete name;
}
