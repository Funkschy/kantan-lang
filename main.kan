#include "std.h"

import "io";
import "std";
import "dbg";

import "parser";
import "ast";
import "reader";
import "span";
import "source";
import "mod";
import "tyid";
import "record";

import "ty";
import "ptrvec";
import "tychk";
import "path";

import "mirc";
import "transform";
import "llvm"; // needed for shutdown

def main(argc: i32, argv: *string): i32 {
    if argc <= 1 {
        io.printf("ERROR: no input files\n");
        llvm.shutdown();
        return - 1;
    }

    // get the current working directory, so we can resolve file paths
    // relative to it
    let cwd_buf = path.get_cwd();
    let cwd = cwd_buf.inner;

    let num_total_errs = 0;

    let file_map = reader.create();
    let res = reader.add_std_lib(&file_map, &cwd);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        path.free_pb(&cwd_buf);
        reader.free_fm(&file_map);
        llvm.shutdown();
        return -2;
    }

    let res = reader.add_all(&file_map, &cwd, argc - 1, argv + 1);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        path.free_pb(&cwd_buf);
        reader.free_fm(&file_map);
        llvm.shutdown();
        return -3;
    }

    let project_root = file_map.proj_root.inner;
    let mm = mod.map_with_cap(project_root, reader.num_files(&file_map));

    let i = 0;
    while i < reader.num_files(&file_map) {
        let src = reader.get_ptr_by_idx(&file_map, i);
        let p = parser.create(src);
        let curr_mod = parser.parse(&p);
        curr_mod.name = mod.mangle_mod_name(curr_mod, project_root);

        let num_errs = parser.num_errs(&p);
        num_total_errs = num_total_errs + num_errs;
        if num_errs > 0 {
            io.printf("%d parse errors found\n", num_errs);
            print_parse_errors(&p, &file_map, &cwd);
        }

        mod.add_mod(&mm, curr_mod);

        // just get the first stmt
        let s = mod.get_stmt(curr_mod, 0);

        if s == null {
            io.printf("ERROR: no valid statement in file\n");
        }

        parser.free_p(&p);
        i = i + 1;
    }

    let tychk_res = tychk.empty_result();

    if num_total_errs == 0 {
        let tc = tychk.create(&mm);
         tychk_res = tychk.check(&tc);

        if tychk_res.had_errors {
            let num_errs = tychk.num_errs(&tc);
            num_total_errs = num_total_errs + num_errs;
            io.printf("%d type errors found\n", num_errs);
            print_type_errors(&tc, &file_map, &cwd);
        }

        tychk.free_tc(&tc);
    }

    if num_total_errs == 0 {
        transform.compile_all(
            mirc.CompilationData {
                mods: tychk_res.mods,
                proj_root: project_root,
                global_types: tychk_res.globals.bindings
            },
            tychk_res.types
        );
    }

    // this also frees all the types, so it has to happen after compilation
    // TODO(#67): implement some form of type garbage collection
    tychk.free_result(&tychk_res);
    reader.free_fm(&file_map);
    mod.map_free(&mm);
    path.free_pb(&cwd_buf);

    if num_total_errs > 0 {
        io.printf("%d compile errors found\n", num_total_errs);
        llvm.shutdown();
        return 1;
    }

    llvm.shutdown();
    return 0;
}

def print_parse_errors(
    p: *parser.Parser,
    fm: *reader.FileMap,
    abs_path: *path.Path
): void {
    let i = 0;
    while i < parser.num_errs(p) {
        let err = parser.get_err(p, i);
        let src = reader.get_ptr_from_span(fm, err.span);

        print_error(err.text, err.span, src, abs_path);

        i = i + 1;
    }
}

def print_type_errors(
    tc: *tychk.TypeChecker,
    fm: *reader.FileMap,
    abs_path: *path.Path
): void {
    let i = 0;
    while i < tychk.num_errs(tc) {
        let err = tychk.get_err(tc, i);
        let src = reader.get_ptr_from_span(fm, err.span);

        print_error(err.text, err.span, src, abs_path);

        i = i + 1;
    }
}

def printf_spanned(s: span.Span, file: *source.SourceFile): void {
    io.printf(" | ");

    let ptr = s.start;
    let len = span.len(s);
    while ptr - s.start < len {
        let c = *ptr;
        io.putchar(std.char_to_int(c));
        if c == '\n' {
            io.printf(" | ");
        }
        ptr = ptr + 1;
    }

    io.putchar(std.char_to_int('\n'));
}

def print_error(
    err_text: string,
    span: span.Span,
    file: *source.SourceFile,
    abs_path: *path.Path
): void {
    dbg.assert(file != null, "source file was null");

    let line_info = source.find_line(file, span);
    let name = source.file_name_dup(file);

    let offset = 0;
    let file_path = &file.file.path.inner;

    // TODO(#13): this only works when the filepath is in a subdir of abs_path
    //  i don't actually know, if this is still a problem, this needs to be
    //  experimented with
    if path.is_abs(file_path) {
        let overlap = path.count_overlap(abs_path, file_path);
        if overlap == abs_path.len {
            offset = overlap + 1;
        }
    }

    io.printf(
        "ERROR: %s\n--> %s:%d:%d\n",
        err_text,
        name + offset,
        line_info.pos.lnr,
        line_info.pos.col
    );

    printf_spanned(line_info.span, file);
    io.printf("\n");

    delete name;
}
