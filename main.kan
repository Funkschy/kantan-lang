#include "std.h"
// #define DEBUG

import "parser";
import "io";
import "ast";
import "reader";
import "std";
import "span";
import "source";
import "mod";
import "tyid";
import "record";

import "ty";
import "ptrvec";

def main(argc: i32, argv: *string): i32 {
    if argc <= 1 {
        io.printf("ERROR: no input files\n");
        return - 1;
    }

    let num_total_errs = 0;
    let span_interner = span.create_interner();

    let file_map = reader.create();
    let res = reader.add_all(&file_map, argc, argv);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        reader.free_fm(&file_map);
        return -2;
    }

    let i = 0;
    while i < reader.num_files(&file_map) {
        let src = reader.get_by_idx(&file_map, i);
#ifdef DEBUG
        io.printf("Compiling %s\n", source.file_name(&src));
#endif
        let p = parser.create(source.code(&src), &span_interner, i);
        let mod = parser.parse(&p);

        let num_errs = parser.num_errs(&p);
        num_total_errs = num_total_errs + num_errs;
        if num_errs > 0 {
            io.printf("%d errors found\n", num_errs);
            print_parse_errors(&p, &span_interner, &file_map);
            parser.free_p(&p);
        }

        print_dbg_mod_info(&mod, &span_interner);

        // just get the first stmt
        let s = mod.get_stmt(&mod, 0);

        if s != null {
            print_dbg_stmt_info(s, &span_interner);
        } else {
            io.printf("ERROR: no valid statement in file\n");
        }

        mod.free_m(&mod);
        i = i + 1;
    }

    reader.free_fm(&file_map);
    return num_total_errs;
}

def print_dbg_stmt_info(s: *ast.Stmt, span_interner: *span.SpanInterner): void {
#ifdef DEBUG
    let is_expr = ast.is_expr_stmt(s);
    io.printf("is expr: %d\n", is_expr);

    if is_expr {
        let e = ast.as_expr_stmt(s).expr;

        let s = ast.expr_to_string(e, span_interner);
        io.printf("%s\n", s);
        delete s;

        if ast.is_int_expr(e) {
            ty.make_i32(e.ty);
            io.printf("width: %d, align: %d\n", e.ty.width, e.ty.align);
        }

    } else if ast.is_struct_decl_stmt(s) {
        let decl_s = ast.as_struct_decl_stmt(s);
        let s = record.to_string(&decl_s.decl, span_interner);
        io.printf("%s\n", s);
        delete s;
    } else if ast.is_let_stmt(s) {
        let ls = ast.as_let_stmt(s);

        let ident: string = ls.ident.ident;
        let ident_len = span.get(span_interner, ls.ident.ident_span).len;
        let value = ast.expr_to_string(ls.value, span_interner);

        let ty = (new '\0') as string;
        if ast.has_type_decl(ls) {
            delete ty;
            let tys = tyid.to_string(&ls.ty, span_interner);
            ty = std.format_str(": %s", tys);
            delete tys;
        }

        io.printf("let %.*s%s = %s;\n", ident_len, ident, ty, value);
        delete value;
        delete ty;
    }
#endif
}

def print_dbg_mod_info(mod: *mod.Module, span_interner: *span.SpanInterner): void {
#ifdef DEBUG
    let num_imports = mod.num_imports(mod);
    let j = 0;
    while j < num_imports {
        let is = mod.get_import_at(mod, j);
        let len = span.get(span_interner, is.path_span).len;
        io.printf("import '%.*s'\n", len, is.mod_path);

        j = j + 1;
    }

    io.printf("%d functions\n", mod.num_functions(mod));
    if mod.num_functions(mod) > 0 {
        let first = mod.get_function_at(mod, 0);
        let s = tyid.to_string(&first.decl.ret_ty, span_interner);
        let name = ident.to_string(&first.decl.name, span_interner);
        io.printf("def %s: %s\n", name, s);
        delete s;
        delete name;
    }

    io.printf("%d structs\n", mod.num_structs(mod));
    if mod.num_structs(mod) > 0 {
        let first = mod.get_struct_at(mod, 0);
        let s = record.to_string(&first.decl, span_interner);
        io.printf("%s\n", s);
        delete s;
    }
#endif
}

def print_parse_errors(p: *parser.Parser, si: *span.SpanInterner, fm: *reader.FileMap): void {
    let err = parser.empty_err();
    let i = 0;
    while i < parser.num_errs(p) {
        parser.get_err(p, i, &err);
        let span = span.get(si, err.span);
        let src = reader.get_by_idx(fm, span.ctx);

        print_parse_error(&err, &span, &src);

        i = i + 1;
    }
}

def print_parse_error(err: *parser.ParseError, span: *span.BigSpan, file: *source.SourceFile): void {
    let last_nl = 0;
    let line = source.find_line(span, file, &last_nl);

    io.printf(
        "ERROR: %s\n--> %s:%d:%d\n\n",
        err.text,
        source.file_name(file),
        line,
        span.start - last_nl
    );
}
