#include "std.h"
 // #define DEBUG

import "parser";
import "io";
import "ast";
import "reader";
import "std";
import "span";
import "source";
import "mod";
import "tyid";
import "record";

import "ty";
import "ptrvec";
import "tychk";
import "path";

// TODO:
// ModMap {
//     "/home/felix/.../test.kan": *Module { ... },
//     "/../oof.kan": *Module { ... }
// }
//
//    import map created by:
//      1) changing reader to use absolute paths using the cwd (Done)
//      2) getting an absolute path to each import path, using the current files abs path
//      3) getting the module for that file and putting it in the map at the relative files key
// ImportMap {
//     "test": *Module { ... },
//     "../oof": *Module { ... },
// }

def main(argc: i32, argv: *string): i32 {
    if argc <= 1 {
        io.printf("ERROR: no input files\n");
        return - 1;
    }

    let rel_compiler_path = path.empty();
    path.from_str(*argv, &rel_compiler_path);

    let abs_compiler_path = path.buf_from(path.empty());
    let error = path.canonicalize(&rel_compiler_path, &abs_compiler_path);
    if error != 0 {
        io.printf("ERROR: %s\n", std.strerror(error));
        return -1;
    }

    let compiler_path = path.parent(&abs_compiler_path.inner);

    let num_total_errs = 0;
    let span_interner = span.create_interner();

    let file_map = reader.create();
    let res = reader.add_std_lib(&file_map, &compiler_path);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        reader.free_fm(&file_map);
        path.free_pb(&abs_compiler_path);
        return -2;
    }

    let res = reader.add_all(&file_map, &compiler_path, argc - 1, argv + 1);
    if res.err_code != 0 {
        let err_msg = std.err2str(res.err_code, res.file_name);
        io.printf("ERROR: %s\n", err_msg);
        delete err_msg;

        reader.free_fm(&file_map);
        path.free_pb(&abs_compiler_path);
        return -2;
    }

    let mm = mod.map_with_cap(reader.num_files(&file_map));

    let i = 0;
    while i < reader.num_files(&file_map) {
        let src = reader.get_by_idx(&file_map, i);
        let p = parser.create(src, &span_interner, i);
        let mod = parser.parse(&p);

        let num_errs = parser.num_errs(&p);
        num_total_errs = num_total_errs + num_errs;
        if num_errs > 0 {
            io.printf("%d errors found\n", num_errs);
            print_parse_errors(&p, &span_interner, &file_map, &compiler_path);
            parser.free_p(&p);
        }

        mod.add_mod(&mm, mod);
        print_dbg_mod_info(mod, &span_interner);

        // just get the first stmt
        let s = mod.get_stmt(mod, 0);

        if s != null {
            print_dbg_stmt_info(s, &span_interner);
        } else {
            io.printf("ERROR: no valid statement in file\n");
        }

        i = i + 1;
    }

    let tchk = tychk.create(&span_interner, &mm);
    tychk.check(&tchk);

    tychk.free_tc(&tchk);
    reader.free_fm(&file_map);
    mod.map_free(&mm);
    path.free_pb(&abs_compiler_path);

    return num_total_errs;
}

def print_dbg_stmt_info(s: *ast.Stmt, span_interner: *span.SpanInterner): void {
#ifdef DEBUG
    let is_expr = ast.is_expr_stmt(s);
    io.printf("is expr: %d\n", is_expr);

    if is_expr {
        let e = ast.as_expr_stmt(s).expr;

        let s = ast.expr_to_string(e, span_interner);
        io.printf("%s\n", s);
        delete s;

        if ast.is_int_expr(e) {
            ty.make_i32(e.ty);
            io.printf("width: %d, align: %d\n", e.ty.width, e.ty.align);
        }

    } else if ast.is_struct_decl_stmt(s) {
        let decl_s = ast.as_struct_decl_stmt(s);
        let s = record.to_string(&decl_s.decl, span_interner);
        io.printf("%s\n", s);
        delete s;
    } else if ast.is_let_stmt(s) {
        let ls = ast.as_let_stmt(s);

        let ident: string = ls.ident.ident;
        let ident_len = span.get(span_interner, ls.ident.ident_span).len;
        let value = ast.expr_to_string(ls.value, span_interner);

        let ty = (new '\0') as string;
        if ast.has_type_decl(ls) {
            delete ty;
            let tys = tyid.to_string(&ls.ty, span_interner);
            ty = std.format_str(": %s", tys);
            delete tys;
        }

        io.printf("let %.*s%s = %s;\n", ident_len, ident, ty, value);
        delete value;
        delete ty;
    }
#endif
}

def print_dbg_mod_info(mod: *mod.Module, span_interner: *span.SpanInterner): void {
#ifdef DEBUG
    let num_imports = mod.num_imports(mod);
    let j = 0;
    while j < num_imports {
        let is = mod.get_import_at(mod, j);
        let s = ident.to_string(&is.mod, span_interner);
        io.printf("import '%s'\n", s);
        delete s;

        j = j + 1;
    }

    io.printf("%d functions\n", mod.num_functions(mod));
    if mod.num_functions(mod) > 0 {
        let first = mod.get_function_at(mod, 0);
        let s = tyid.to_string(&first.decl.ret_ty, span_interner);
        let name = ident.to_string(&first.decl.name, span_interner);
        io.printf("def %s: %s\n", name, s);
        delete s;
        delete name;
    }

    io.printf("%d structs\n", mod.num_structs(mod));
    if mod.num_structs(mod) > 0 {
        let first = mod.get_struct_at(mod, 0);
        let s = record.to_string(&first.decl, span_interner);
        io.printf("%s\n", s);
        delete s;
    }
#endif
}

def print_parse_errors(p: *parser.Parser,
    si: *span.SpanInterner,
    fm: *reader.FileMap,
    abs_path: *path.Path
): void {
    let err = parser.empty_err();
    let i = 0;
    while i < parser.num_errs(p) {
        parser.get_err(p, i, &err);
        let span = span.get(si, err.span);
        let src = reader.get_by_idx(fm, span.ctx);

        print_parse_error(&err, &span, &src, abs_path);

        i = i + 1;
    }
}

def print_parse_error(
    err: *parser.ParseError,
    span: *span.BigSpan,
    file: *source.SourceFile,
    abs_path: *path.Path
): void {
    let last_nl = 0;
    let line = source.find_line(span, file, &last_nl);
    let name = source.file_name_dup(file);

    io.printf(
        "ERROR: %s\n--> %s:%d:%d\n\n",
        err.text,
        name + abs_path.len + 1,
        line,
        span.start - last_nl
    );

    delete name;
}
