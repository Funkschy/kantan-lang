// TODO: replace map implementation with open addressing implementation

#include "std.h"

#define LOAD_FACTOR 0.75

import "std";
import "num";
import "ident";
import "span";

import "io"; // TODO: only debug

extern def get_map_index(cap: i32, key: string, key_len: i32): i32;

type Map struct {
    buckets: *Bucket,
    len: i32,
    cap: i32
}

type Bucket struct {
    item: Item,
    next: *Bucket
}

type Key struct {
    len: i32,
    value: string
}

def create_key(len: i32, value: string): Key {
    return Key { len: len, value: value };
}

def key_from_ident(span_interner: *span.SpanInterner, ident: *ident.Ident): Key {
    let len = span.get(span_interner, ident.ident_span).len;
    return create_key(len, ident.ident);
}

type Item struct  {
    key: Key,
    value: *void
}

def create(): Map {
    return Map { buckets: null, len: 0, cap: 0 };
}

def with_cap(cap: i32): Map {
    if cap % 2 != 0 {
        cap = num.next_pow_of_2(cap);
    }
    return Map { buckets: std.calloc(cap, sizeof Bucket) as *Bucket, len: 0, cap: cap };
}

def free_m(m: *Map): void {
    let i = 0;
    while i < m.cap {
        free_buckets(m.buckets + i);
        i = i + 1;
    }
    if m.buckets != null {
        delete m.buckets;
    }
}

def free_buckets(buckets: *Bucket): void {
    let last = buckets.next;
    while last != null {
        let t = last.next;
        delete last;
        last = t;
    }
}

def resize_if_needed(map: *Map): void {
    let cap = map.cap;
    if cap == 0 {
        map.cap = cap = 16;
        map.buckets = std.calloc(cap, sizeof Bucket) as *Bucket;
    }

    if num.int_to_float(map.len) > LOAD_FACTOR * num.int_to_float(cap) {
        cap = cap * 2;

        let new_buckets = std.calloc(map.cap, sizeof Bucket) as *Bucket;
        let new_map = Map { buckets: new_buckets, len: map.len, cap: cap };

        insert_all(map, &new_map);
        *map = new_map;
    }
}

def key_eq(first: *Key, second: *Key): bool {
    if first.len != second.len {
        return false;
    }

    return std.strncmp(first.value, second.value, first.len) == 0;
}

def bucket_is_empty(b: *Bucket): bool {
    return b.item.key.value == null;
}

def insert_all(old_map: *Map, new_map: *Map): void {
    let i = 0;

    // iterate over buckets
    while i < old_map.cap {
        let b = old_map.buckets + i;

        // iterate over list in bucket
        while b != null {
            if bucket_is_empty(b) {
                insert(new_map, b.item.key, b.item.value);
            }

            b = b.next;
        }

        i = i + 1;
    }

}

// inserts value into map at key
// returns: true if a value with the same key was replaced
def insert(map: *Map, key: Key, value: *void): bool {
    resize_if_needed(map);

    let b = map.buckets + get_map_index(map.cap, key.value, key.len);
    let item = Item { key: key, value: value };

    if bucket_is_empty(b) {
        b.item = item;
        return false;
    }

    while b != null {
        if bucket_is_empty(b) {
            b.item = Item { key: key, value: value };
            return false;
        }

        // same key
        if key_eq(&b.item.key, &key) {
            b.item.value = value;
            return true;
        }

        // no next bucket
        if b.next == null {
            b.next = new Bucket { item: item, next: null };
            map.len = map.len + 1;
            return false;
        }

        b = b.next;
    }

    // should be unreachable, so just abort
    std.abort();
    return false;
}

def get(map: *Map, key: Key): *void {
    if map.buckets == null {
        return null;
    }

    let b = map.buckets + get_map_index(map.cap, key.value, key.len);

    while b != null {
        if bucket_is_empty(b) {
            return null;
        }

        if key_eq(&b.item.key, &key) {
            return b.item.value;
        }

        b = b.next;
    }

    return null;
}
