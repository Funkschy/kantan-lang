import "io";
import "std";
import "ident";
import "span";

extern def get_map_index(cap: usize, key: string, key_len: usize): usize;

type Map struct {
    len: usize,
    cap: usize,
    items: *Item
}

type Iter struct {
    pos: usize,
    map: *Map
}

def iter_next(iter: *Iter): *Item {
    while iter.pos < iter.map.cap {
        let item = iter.map.items + iter.pos;
        iter.pos = iter.pos + 1;
        if item.key.value != null {
            return item;
        }
    }
    return null;
}

def iter(map: *Map): Iter {
    return Iter{ pos: 0, map: map };
}

type Key struct {
    len: usize,
    value: string
}

def create_key(len: usize, value: string): Key {
    return Key { len: len, value: value };
}

def key_from_ident(i: *ident.Ident): Key {
    return create_key(ident.len(i), ident.start(i));
}

type Item struct {
    key: Key,
    value: *void
}

def create_item(key: Key, value: *void): Item {
    return Item { key: key, value: value };
}

def create(): Map {
    return Map { len: 0, cap: 0, items: null };
}

def with_cap(cap: usize): Map {
    if cap == 0 {
        return Map { len: 0, cap: 0, items: null };
    }

    if cap % 2 != 0 {
        cap = std.next_pow_of_2(cap as i64) as usize;
    }

    let items = std.calloc(cap, sizeof Item) as *Item;
    return Map { len: 0, cap: cap, items: items };
}

def free_m(m: *Map): void {
    if m.items == null {
        return;
    }

    delete m.items;
}

def key_eq(first: Key, second: Key): bool {
    if first.len != second.len {
        return false;
    }

    return std.strncmp(first.value, second.value, first.len) == 0;
}

def insert_all(map: *Map, other: *Map): void {
    for let i: usize = 0; i < other.cap; i += 1 {
        let item = other.items + i;
        if item.key.value != null {
            insert(map, item.key, item.value);
        }
    }
}

// inserts value into map at key
// returns the replaced value or null
def insert(map: *Map, key: Key, value: *void): *void {
    if map.items == null || load_factor(map) > 0.75 {
        resize(map);
    }

    let index = get_map_index(map.cap, key.value, key.len);
    let item = map.items + index;

    // empty place
    if item.key.value == null {
        *item = create_item(key, value);
        map.len = map.len + 1;
        return null;
    }

    // overwrite
    if key_eq(item.key, key) {
        let old_val = item.value;
        item.value = value;
        return old_val;
    }

    let replaced: *void = null;
    // linear probing
    if probe_insert(map, index + 1, map.cap, key, value, &replaced) {
        return replaced;
    }

    probe_insert(map, 0, index, key, value, &replaced);
    return replaced;
}

def probe_insert(
    map: *Map,
    start: usize,
    len: usize,
    key: Key,
    value: *void,
    out_old_val: **void
): bool {
    let i = start;
    let item: *Item = null;
    while i < len {
        item = map.items + i;

        let insert = false;
        if item.key.value == null {
            insert = true;
        } else if key_eq(item.key, key) {
            *out_old_val = item.value;
            insert = true;
        }

        if insert {
            *item = create_item(key, value);
            map.len = map.len + 1;
            return true;
        }

        i = i + 1;
    }

    return false;
}

def probe_get(map: *Map, start: usize, end: usize, key: Key): *Item {
    let i = start;
    let item: *Item = null;
    while i < end {
        item = map.items + i;
        if item.key.value != null {
            if key_eq(item.key, key) {
                return item;
            }
        }
        i = i + 1;
    }

    return null;
}

def load_factor(map: *Map): f32 {
    if map.cap == 0 {
        return 0.0;
    }

    return map.len as f32 / (map.cap as f32);
}

def resize(map: *Map): void {
    let cap = map.cap * 2;
    if cap == 0 {
        cap = 4;
    }

    let new_map = with_cap(cap);
    insert_all(&new_map, map);
    free_m(map);
    *map = new_map;
}

def get(map: *Map, key: Key): *void {
    let item = get_item(map, key);
    if item == null {
        return null;
    }
    return item.value;
}

def get_item(map: *Map, key: Key): *Item {
    if map.items == null {
        return null;
    }

    let index = get_map_index(map.cap, key.value, key.len);
    let item = map.items + index;

    if item.key.value != null {
        if key_eq(item.key, key) {
            return item;
        }
    }

    let probe = probe_get(map, index + 1, map.cap, key);
    if probe == null {
        probe = probe_get(map, 0, index, key);
    }

    if probe != null {
        return probe;
    }

    return null;
}

def get_and_remove(map: *Map, key: Key): *void {
    let item = get_item(map, key);
    if item == null {
        return null;
    }

    let value = item.value;
    std.memset(item as *void, 0, sizeof Item);
    map.len = map.len - 1;
    return value;
}

def dump(map: *Map): void {
    let iter = iter(map);
    let item = iter_next(&iter);
    while item != null {
        io.printf("%.*s: %p\n", item.key.len, item.key.value, item.value);
        item = iter_next(&iter);
    }
}
