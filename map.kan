#include "std.h"

import "std";
import "num";
import "ident";
import "span";

extern def get_map_index(cap: i32, key: string, key_len: i32): i32;

type Map struct {
    len: i32,
    cap: i32,
    items: *Item
}

type Iter struct {
    pos: i32,
    map: *Map
}

def iter_next(iter: *Iter): *Item {
    while iter.pos < iter.map.cap {
        let item = iter.map.items + iter.pos;
        iter.pos = iter.pos + 1;
        if item.key.value != null {
            return item;
        }
    }
    return null;
}

def iter(map: *Map): Iter {
    return Iter{ pos: 0, map: map };
}

type Key struct {
    len: i32,
    value: string
}

def create_key(len: i32, value: string): Key {
    return Key { len: len, value: value };
}

def key_from_ident(span_interner: *span.SpanInterner, ident: *ident.Ident): Key {
    let len = span.get(span_interner, ident.ident_span).len;
    return create_key(len, ident.ident);
}

type Item struct {
    key: Key,
    value: *void
}

def create_item(key: Key, value: *void): Item {
    return Item { key: key, value: value };
}

def create(): Map {
    return Map { len: 0, cap: 0, items: null };
}

def with_cap(cap: i32): Map {
    if cap % 2 != 0 {
        cap = num.next_pow_of_2(cap);
    }

    let items = std.calloc(cap, sizeof Item) as *Item;
    return Map { len: 0, cap: cap, items: items };
}

def free_m(m: *Map): void {
    if m.items == null {
        return;
    }

    delete m.items;
}

def key_eq(first: Key, second: Key): bool {
    if first.len != second.len {
        return false;
    }

    return std.strncmp(first.value, second.value, first.len) == 0;
}

def insert_all(map: *Map, other: *Map): void {
    let i = 0;
    while i < other.cap {
        let item = other.items + i;
        if item.key.value != null {
            insert(map, item.key, item.value);
        }
        i = i + 1;
    }
}

// inserts value into map at key
// returns the replaced value or null
def insert(map: *Map, key: Key, value: *void): *void {
    if map.items == null || load_factor(map) > 0.75 {
        resize(map);
    }

    let index = get_map_index(map.cap, key.value, key.len);
    let item = map.items + index;

    // empty place
    if item.key.value == null {
        *item = create_item(key, value);
        map.len = map.len + 1;
        return null;
    }

    // overwrite
    if key_eq(item.key, key) {
        let old_val = item.value;
        item.value = value;
        return old_val;
    }

    let replaced: *void = null;
    // linear probing
    if probe_insert(map, index + 1, map.cap, key, value, &replaced) {
        return replaced;
    }

    probe_insert(map, 0, index, key, value, &replaced);
    return replaced;
}

def probe_insert(
    map: *Map,
    start: i32,
    len: i32,
    key: Key,
    value: *void,
    out_old_val: **void
): bool {
    let i = start;
    let item: *Item = null;
    while i < len {
        item = map.items + i;

        let insert = false;
        if item.key.value == null {
            insert = true;
        } else if key_eq(item.key, key) {
            *out_old_val = item.value;
            insert = true;
        }

        if insert {
            *item = create_item(key, value);
            map.len = map.len + 1;
            return true;
        }

        i = i + 1;
    }

    return false;
}

def probe_get(map: *Map, start: i32, len: i32, key: Key): *Item {
    let i = start;
    let item: *Item = null;
    while i < len {
        item = map.items + i;
        if item.key.value != null {
            if key_eq(item.key, key) {
                return item;
            }
        }
        i = i + 1;
    }

    return null;
}

def load_factor(map: *Map): f32 {
    if map.cap == 0 {
        return 0.0;
    }

    return num.int_to_float(map.len) / num.int_to_float(map.cap);
}

def resize(map: *Map): void {
    let cap = map.cap * 2;
    if cap == 0 {
        cap = 4;
    }

    let new_map = with_cap(cap);
    insert_all(&new_map, map);
    free_m(map);
    *map = new_map;
}

def get(map: *Map, key: Key): *void {
    if map.items == null {
        return null;
    }

    let index = get_map_index(map.cap, key.value, key.len);
    let item = map.items + index;

    if item.key.value == null {
        return null;
    }

    if key_eq(item.key, key) {
        return item.value;
    }

    let probe = probe_get(map, index + 1, map.cap, key);
    if probe != null {
        return probe.value;
    }

    probe = probe_get(map, 0, index, key);
    if probe != null {
        return probe.value;
    }

    return null;
}

def get_and_remove(map: *Map, key: Key): *void {
    if map.items == null {
        return null;
    }

    let index = get_map_index(map.cap, key.value, key.len);
    let item = map.items + index;

    if item.key.value == null {
        return null;
    }

    if key_eq(item.key, key) {
        let value = item.value;
        std.memset(item as *void, 0, sizeof Item);
        map.len = map.len - 1;
        return value;
    }

    let probe = probe_get(map, index + 1, map.cap, key);
    if probe == null {
        probe = probe_get(map, 0, index, key);
    }

    if probe != null {
        let value = probe.value;
        std.memset(probe as *void, 0, sizeof Item);
        map.len = map.len - 1;
        return value;
    }

    return null;
}
