import "io";
import "ty";
import "std";
import "str";
import "vec";
import "str";
import "map";
import "dbg";
import "mod";
import "vmap";
import "span";
import "name";
import "ident";
import "source";

extern def mir_binary2str(kind: i32): string;
extern def mir_unary2str(kind: i32): string;

type Module struct {
    globals: map.Map, // map.Map<name.Ref, *GlobalVar>
    functions: map.Map, // map.Map<name.Ref, *Func>
    user_defined_types: map.Map, // map.Map<name.Ref, *UserDefinedType>
    scopes: Scopes,
    actual: *mod.Module
}

def create_mod(
    globals: map.Map,
    funcs: map.Map,
    user_defined_types: map.Map,
    scopes: Scopes,
    actual: *mod.Module
): Module {
    return Module {
        globals: globals,
        functions: funcs,
        user_defined_types: user_defined_types,
        scopes: scopes,
        actual: actual
    };
}

def free_mod(m: *Module) {
    // free function names
    let f_iter = map.iter(&m.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *Func;
        free_func(f);
        delete f;

        item = map.iter_next(&f_iter);
    }

    // free user defined types
    let t_iter = map.iter(&m.user_defined_types);
    let item = map.iter_next(&t_iter);
    while item != null {
        delete item.value;
        item = map.iter_next(&t_iter);
    }

    // free globals
    let g_iter = map.iter(&m.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let gv = item.value as *GlobalVar;
        gv.free();
        delete gv;

        item = map.iter_next(&g_iter);
    }

    map.free_m(&m.functions);
    map.free_m(&m.user_defined_types);
    map.free_m(&m.globals);

    m.scopes.free();
}

def dump_module(m: *Module): void {
    let t_iter = map.iter(&m.user_defined_types);
    let item = map.iter_next(&t_iter);
    while item != null {
        let t = item.value as *UserDefinedType;

        let s_extern = "";
        if t.is_extern {
            s_extern = "extern ";
        }

        io.printf("%s%s %.*s { ", ty.to_static_string(t.ty), s_extern, t.name.len, t.name.data);

        if ty.is_struct(t.ty) {
            let s_ty = ty.as_struct(t.ty);
            for let i: u32 = 0; i < s_ty.num_fields(); i += 1 {
                if i > 0 {
                    io.printf(", ");
                }

                let field = s_ty.field_at(i);

                let ty_s = ty.to_string(field.ty);
                defer ty_s.free();

                io.printf(
                    "%.*s: %s",
                    ident.len(&field.name),
                    ident.start(&field.name),
                    ty_s.cstring()
                );
            }
        } else if ty.is_union(t.ty) {
            let u_ty = ty.as_union(t.ty);
            for let i: u32 = 0; i < u_ty.num_fields(); i += 1 {
                if i > 0 {
                    io.printf(", ");
                }

                let field = u_ty.field_at(i);

                let ty_s = ty.to_string(field.ty);
                defer ty_s.free();

                io.printf(
                    "%.*s: %s",
                    ident.len(&field.name),
                    ident.start(&field.name),
                    ty_s.cstring()
                );
            }
        } else if ty.is_enum(t.ty) {
            let e_ty = ty.as_enum(t.ty);

            for let i: u32 = 0; i < e_ty.num_values(); i += 1 {
                if i > 0 {
                    io.printf(", ");
                }

                let value = ty.value_at(e_ty, i);
                io.printf("%.*s", ident.len(&value.name), ident.start(&value.name));
            }
        }

        io.printf(" }\n");
        item = map.iter_next(&t_iter);
    }

    let g_iter = map.iter(&m.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let g = item.value as *GlobalVar;

        let ty_s = ty.to_string(g.ty);
        defer ty_s.free();

        let quote = "";
        let quote_len = 0;

        if ty.is_string(g.ty) && !g.value.is_name {
            let c = '"';
            quote = &c as string;
            quote_len = 1;
        }

        io.printf(
            "%.*s: %s = %.*s%.*s%.*s\n",
            g.mangled_name.len, g.mangled_name.data,
            ty_s.cstring(),
            quote_len, quote,
            g.value.len, g.value.data,
            quote_len, quote
        );

        item = map.iter_next(&g_iter);
    }

    let f_iter = map.iter(&m.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *Func;
        if f.is_extern {
            io.printf("extern def %.*s\n", f.name.len, f.name.data);
        } else {
            bm_dump(&f.blocks);
        }
        item = map.iter_next(&f_iter);
    }
}

type DeferedStmts struct {
    instructions: vec.Vec // vec.Vec<Inst>
}

def create_defered_stmts(): DeferedStmts {
    return DeferedStmts {
        instructions: vec.create(sizeof Inst)
    };
}

def (ds: *DeferedStmts) free() {
    for let i: usize = 0; i < ds.instructions.len; i += 1 {
        let instr = ds.get(i);
        if instr.push_count == 0 {
            free_inst(instr);
        }
    }
    ds.instructions.free();
}

def (ds: *DeferedStmts) len(): usize {
    return ds.instructions.len;
}

def (ds: *DeferedStmts) push(instr: *Inst) {
    ds.instructions.push(instr as *void);
}

def (ds: *DeferedStmts) get(idx: usize): *Inst {
    return ds.instructions.get_ptr(idx) as *Inst;
}

type Scopes struct {
    mir_scopes: vec.Vec, // vec.Vec<Scope>
    defered: vec.Vec // vec.Vec<DeferedStmts>
}

def create_scopes(): Scopes {
    return Scopes {
        mir_scopes: vec.create(sizeof Scope),
        defered: vec.create(sizeof DeferedStmts)
    };
}

def (s: *Scopes) free() {
    for let i: usize = 0; i < s.defered.len; i += 1 {
        (s.defered.get_ptr(i) as *DeferedStmts).free();
    }
    s.defered.free();
    s.mir_scopes.free();
}

def (s: *Scopes) open(scope: Scope) {
    s.mir_scopes.push(&scope as *void);
    let defered = create_defered_stmts();
    s.defered.push(&defered as *void);
}

def (s: *Scopes) push_defer(scope_id: isize, instr: *Inst) {
    let stmts = s.defered.get_ptr(scope_id as usize) as *DeferedStmts;
    dbg.assert(stmts != null, "pushing defer into non existing scope");
    stmts.push(instr);
}

def (s: *Scopes) defered_for(id: isize): *DeferedStmts {
    return s.defered.get_ptr(id as usize) as *DeferedStmts;
}

def (s: *Scopes) clear_defered_for(id: isize) {
    let defered = s.defered_for(id);
    defered.free();
    *defered = create_defered_stmts();
}

def (s: *Scopes) with_id(id: isize): *Scope {
    return s.mir_scopes.get_ptr(id as usize) as *Scope;
}

def (s: *Scopes) count(): usize {
    return s.mir_scopes.len;
}

def (s: *Scopes) is_empty(): bool {
    return s.count() <= 0;
}

type Func struct {
    name: name.Ref,
    blocks: BlockMap,
    ty: *ty.Type,
    meta: MetaData,
    is_extern: bool
}

def create_func(t: *ty.Type, mangled_name: name.Ref, meta: MetaData, is_extern: bool): Func {
    dbg.assert(ty.is_func(t), "func type was not func");

    let blocks = empty_block_map();
    if !is_extern {
        blocks = create_block_map(mangled_name);
    }

    return Func {
        name: mangled_name,
        blocks: blocks,
        ty: t,
        meta: meta,
        is_extern: is_extern
    };
}

def free_func(f: *Func): void {
    free_block_map(&f.blocks);
}

def func_ret_ty(f: *Func): *ty.Type {
    return ty.as_func(f.ty).ret;
}

def func_push_instr(f: *Func, inst: *Inst): void {
    bm_push_instr(&f.blocks, inst);
}

type UserDefinedType struct {
    name: name.Ref,
    ty: *ty.Type,
    meta: MetaData,
    is_extern: bool
}

def create_user_defined_type(
    t: *ty.Type,
    mangled_name: name.Ref,
    meta: MetaData,
    is_extern: bool
): UserDefinedType {
    dbg.assert(ty.is_user_defined(t), "UserDefinedType type was not user defined");

    return UserDefinedType {
        name: mangled_name,
        ty: t,
        meta: meta,
        is_extern: is_extern
    };
}

type ScopeKind enum {
    Function, Loop, Block, Variable
}

type Scope struct {
    kind: ScopeKind,
    id: isize,
    parent: isize,
    num_decls: usize
}

def scope(kind: ScopeKind): Scope {
    return Scope { kind: kind, id: -1, parent: -1, num_decls: 0 };
}

def (s: Scope) with_id(id: isize): Scope {
    s.id = id;
    return s;
}

def (s: Scope) with_parent(parent: isize): Scope {
    s.parent = parent;
    return s;
}

def (s: Scope) with_num_decls(num_decls: usize): Scope {
    s.num_decls = num_decls;
    return s;
}

type MetaData struct {
    pos: source.SourcePos,
    scope: Scope
}

def create_meta(pos: source.SourcePos, scope: Scope): MetaData {
    return MetaData { pos: pos, scope: scope };
}

type ValueBuffer struct {
    is_name: bool, // is this just a reference to another global variable
    needs_free: bool,
    len: usize,
    data: *void
}

def buffer_from_owned(n: name.Owned, is_name: bool): ValueBuffer {
    return ValueBuffer {
        is_name: is_name,
        needs_free: true,
        len: n.len,
        data: n.data as *void
    };
}

def buffer_from_ref(n: name.Ref, is_name: bool): ValueBuffer {
    return ValueBuffer {
        is_name: is_name,
        needs_free: false,
        len: n.len,
        data: n.data as *void
    };
}

def (buf: *ValueBuffer) as_ref(): name.Ref {
    return name.make_ref(buf.len, buf.data as string);
}

def (buf: *ValueBuffer) free() {
    if buf.needs_free {
        delete buf.data;
    }
}

type GlobalVar struct {
    original_name: ident.Ident,
    mangled_name: name.Owned,
    meta: MetaData,
    ty: *ty.Type,
    value: ValueBuffer
}

def create_global_var(
    original_name: ident.Ident,
    mangled_name: name.Owned,
    meta: MetaData,
    ty: *ty.Type,
    value: ValueBuffer
): GlobalVar {
    return GlobalVar {
        original_name: original_name,
        mangled_name: mangled_name,
        meta: meta,
        ty: ty,
        value: value
    };
}

def escape_char(c: i8): i8 {
    if c == '0' {
        return '\0';
    } else if c == 'n' {
        return '\n';
    } else if c == 'r' {
        return '\r';
    } else if c == 't' {
        return '\t';
    } else if c == '\\' {
        return '\\';
    } else if c == '"' {
        return '"';
    } else if c == '\'' {
        return '\'';
    }
    return c;
}

def escape_string(start: string, end: string): name.Owned {
    let value = name.make_copied((end - start) as usize, start);
    let actual_len = value.len;

    let out_pos: usize = 0;
    let in_pos: usize = 0;

    let n = (end - start) as usize;
    while in_pos < n {
        let c = *(start + in_pos);
        let inc: usize = 1;

        if c == '\\' {
            // \x are 2 chars, but we replace it with 1 escaped byte
            actual_len = actual_len - 1;
            let next = *(start + in_pos + 1);
            c = escape_char(next);

            // skip next
            inc = 2;
        }

        *(value.data + out_pos) = c;
        in_pos = in_pos + inc;
        out_pos = out_pos + 1;
    }

    value.len = actual_len;
    return value;
}

def create_string_literal(
    mangled_name: name.Owned,
    meta: MetaData,
    t: *ty.Type,
    s: span.Span
): GlobalVar {
    dbg.assert(ty.is_string(t), "trying to create_const_string for non string");

    let value = escape_string(s.start, s.end);

    return GlobalVar {
        original_name: ident.empty(),
        mangled_name: mangled_name,
        meta: meta,
        ty: t,
        value: buffer_from_owned(value, false)
    };
}

def (gc: *GlobalVar) free() {
    name.free_owned(&gc.mangled_name);
    gc.value.free();
}

type InstBlock struct {
    instructions: vec.Vec // vec.Vec<Inst>
}

def create_inst_block(): InstBlock {
    return InstBlock { instructions: vec.create(sizeof Inst) };
}

def push_instr(b: *InstBlock, inst: *Inst): void {
    b.instructions.push(inst as *void);
}

def get_instr(b: *InstBlock, idx: usize): *Inst {
    return b.instructions.get_ptr(idx) as *Inst;
}

def free_inst_block(b: *InstBlock) {
    for let i: usize = 0; i < b.instructions.len; i += 1 {
        free_inst(b.instructions.get_ptr(i) as *Inst);
    }
    b.instructions.free();
}

type BasicBlock struct {
    label: Label,
    instructions: InstBlock,
    terminator: Inst
}

def create_bb(label: Label): BasicBlock {
    return BasicBlock {
        label: label,
        instructions: create_inst_block(),
        terminator: create_inst_nop()
    };
}

// number of instructions excluding label and terminator
def bb_num_instr(bb: *BasicBlock): usize {
    return bb.instructions.instructions.len;
}

def bb_push_instr(bb: *BasicBlock, inst: *Inst): void {
    push_instr(&bb.instructions, inst);
}

def bb_get_instr(bb: *BasicBlock, idx: usize): *Inst {
    return get_instr(&bb.instructions, idx);
}

def free_bb(bb: *BasicBlock) {
    free_label(&bb.label);
    free_inst_block(&bb.instructions);
    free_inst(&bb.terminator);
}

type Label struct {
    name: name.Owned
}

def create_label(n: name.Owned): Label {
    return Label { name: n };
}

def clone_label(l: *Label): Label {
    return create_label(name.make_copied(l.name.len, l.name.data));
}

def free_label(l: *Label): void {
    name.free_owned(&l.name);
}

def label_name(l: *Label): name.Ref {
    return name.ref(l.name);
}

type AddressName struct {
    value: name.Ref // name table owns name
}

def make_addr_name(value: name.Ref, ty: *ty.Type): Address {
    let hi = std.int_to_ptr(value.len);
    let lo = value.data as *void;
    return create_addr(AddrKind.Name, ty, hi, lo);
}

def clone_addr_name(a: *Address): Address {
    dbg.assert_fmt(is_addr_name(a), "addr should be name, but was %d", a.kind);
    let name = as_addr_name(a);
    return make_addr_name(name.value, a.ty);
}

def as_addr_name(a: *Address): AddressName {
    let len = std.ptr_to_int(a.data_hi);
    let data = a.data_lo as string;
    let name = name.make_ref(len, data);
    return AddressName { value: name };
}

def is_addr_name(a: *Address): bool {
    return a.kind == AddrKind.Name;
}

type AddressConst struct {
    start: string,
    end: string
}

def make_addr_const(ty: *ty.Type, s: span.Span): Address {
    return make_addr_const_strings(ty, s.start, s.end);
}

def make_addr_const_strings(ty: *ty.Type, start: string, end: string): Address {
    dbg.assert(start < end, "start was larger than end");
    return create_addr(AddrKind.Const, ty, start as *void, end as *void);
}

def as_addr_const(a: *Address): AddressConst {
    return AddressConst { start: a.data_hi as string, end: a.data_lo as string };
}

def is_addr_const(a: *Address): bool {
    return a.kind == AddrKind.Const;
}

def const_len(c: *AddressConst): usize {
    return (c.end - c.start) as usize;
}

type AddressConstValue struct {
    value: i64
}

def make_addr_const_value(ty: *ty.Type, value: i64): Address {
    return create_addr(AddrKind.ConstValue, ty, std.int_to_ptr(value as usize), null);
}

def as_addr_const_value(a: *Address): AddressConstValue {
    return AddressConstValue { value: std.ptr_to_int(a.data_hi) as i64 };
}

def is_addr_const_value(a: *Address): bool {
    return a.kind == AddrKind.ConstValue;
}

type AddressGlobal struct {
    name: name.Ref
}

def make_addr_global(name: name.Ref, ty: *ty.Type): Address {
    let hi = std.int_to_ptr(name.len);
    let lo = name.data as *void;
    return create_addr(AddrKind.Global, ty, hi, lo);
}

def as_addr_global(a: *Address): AddressGlobal {
    let len = std.ptr_to_int(a.data_hi);
    let data = a.data_lo as string;
    let name = name.make_ref(len, data);
    return AddressGlobal { name: name };
}

def is_addr_global(a: *Address): bool {
    return a.kind == AddrKind.Global;
}

type AddressRef struct {
    name: name.Ref
}

def make_addr_ref(name: name.Ref, ty: *ty.Type): Address {
    let hi = std.int_to_ptr(name.len);
    let lo = name.data as *void;
    return create_addr(AddrKind.Ref, ty, hi, lo);
}

def as_addr_ref(a: *Address): AddressRef {
    let len = std.ptr_to_int(a.data_hi);
    let data = a.data_lo as string;
    let name = name.make_ref(len, data);
    return AddressRef { name: name };
}

def is_addr_ref(a: *Address): bool {
    return a.kind == AddrKind.Ref;
}

type AddressArg struct {
    idx: u32
}

def make_addr_arg(idx: u32, ty: *ty.Type): Address {
    let hi = std.int_to_ptr(idx as usize);
    return create_addr(AddrKind.Arg, ty, hi, null);
}

def as_addr_arg(a: *Address): AddressArg {
    let idx = std.ptr_to_int(a.data_hi);
    return AddressArg { idx: idx as u32 };
}

def is_addr_arg(a: *Address): bool {
    return a.kind == AddrKind.Arg;
}

def create_addr_empty(): Address {
    return create_addr(AddrKind.Empty, null, null, null);
}

def is_addr_empty(a: *Address): bool {
    return a.kind == AddrKind.Empty;
}

def create_addr_null(ty: *ty.Type): Address {
    return create_addr(AddrKind.Null, ty, null, null);
}

def is_addr_null(a: *Address): bool {
    return a.kind == AddrKind.Null;
}

def create_addr_undefined(ty: *ty.Type): Address {
    return create_addr(AddrKind.Undefined, ty, null, null);
}

def is_addr_undefined(a: *Address): bool {
    return a.kind == AddrKind.Undefined;
}

type AddrKind enum {
    Empty = 1,
    Null,
    Undefined,
    Name,
    Const,
    ConstValue,
    Global,
    Ref,
    Arg,
    Intrinsic
}

type Address struct {
    kind: AddrKind,
    ty: *ty.Type,
    // this is basically a poor mans union, since the current compiler
    // implementation does not support unions
    // TODO(#75): replace this with real unions
    data_hi: *void,
    data_lo: *void
}

def create_addr(kind: AddrKind, ty: *ty.Type, data_hi: *void, data_lo: *void): Address {
    return Address {
        kind: kind, ty: ty, data_hi: data_hi, data_lo: data_lo
    };
}

def addr_to_name(a: *Address): name.Owned {
    if is_addr_name(a) {
        let n= as_addr_name(a);
        return name.make_copied(n.value.len, n.value.data);
    }

    if is_addr_const(a) {
        let const = as_addr_const(a);
        let len: usize = 0;
        let s = std.l_format_str(
            &len, "const %.*s", const_len(&const), const.start
        );
        return name.make_owned(len, s);
    }

    if is_addr_const_value(a) {
        let const = as_addr_const_value(a);
        let len: usize = 0;
        let s = std.l_format_str(&len, "const %d", const.value);
        return name.make_owned(len, s);
    }

    if is_addr_global(a) {
        let global = as_addr_global(a);
        let len: usize = 0;
        let s = std.l_format_str(
            &len, "global %.*s", global.name.len, global.name.data
        );
        return name.make_owned(len, s);
    }

    if is_addr_ref(a) {
        let ref = as_addr_ref(a);
        let len: usize = 0;
        let s = std.l_format_str(
            &len, "&%.*s", ref.name.len, ref.name.data
        );
        return name.make_owned(len, s);
    }

    if is_addr_arg(a) {
        let arg = as_addr_arg(a);
        let len: usize = 0;
        let s = std.l_format_str(
            &len, "getarg(%d)", arg.idx
        );
        return name.make_owned(len, s);
    }

    if is_addr_empty(a) {
        return name.make_copied(1, "_");
    }

    if is_addr_null(a) {
        return name.make_copied(4, "null");
    }

    if is_addr_undefined(a) {
        return name.make_copied(9, "undefined");
    }

    return name.make_owned(0, null);
}

type BinaryKind enum {
    Add = 1,
    Sub,
    Mul,
    Div,
    Mod,
    BitAnd,
    BitOr,
    BitXor,

    ST,
    SE,
    GT,
    GE,
    EQ,
    NE,

    BoolAnd,
    BoolOr,

    LShift,
    RShift,

    AddScalar,
    SubScalar
}

type ExprBinary struct {
    kind: BinaryKind,
    left: Address,
    right: Address
}

def new_expr_binary(kind: BinaryKind, left: Address, right: Address): Expression {
    let binary = (new ExprBinary { kind: kind, left: left, right: right }) as *void;
    return create_expr(ExprKind.Binary, binary);
}

def binary_kind_to_static_string(kind: BinaryKind): string {
    return mir_binary2str(*(&kind as *i32));
}

def as_expr_binary(e: *Expression): *ExprBinary {
    return e.data as *ExprBinary;
}

def is_expr_binary(e: *Expression): bool {
    return e.kind == ExprKind.Binary;
}

type UnaryKind enum {
    Not = 1,
    NumNeg,
    Deref
}

type ExprUnary struct {
    kind: UnaryKind,
    addr: Address
}

def new_expr_unary_deref(addr: Address): Expression {
    let unary = (new ExprUnary { kind: UnaryKind.Deref, addr: addr }) as *void;
    return create_expr(ExprKind.Unary, unary);
}

def new_expr_unary_num_neg(addr: Address): Expression {
    let unary = (new ExprUnary { kind: UnaryKind.NumNeg, addr: addr }) as *void;
    return create_expr(ExprKind.Unary, unary);
}

def new_expr_unary_not(addr: Address): Expression {
    let unary = (new ExprUnary { kind: UnaryKind.Not, addr: addr }) as *void;
    return create_expr(ExprKind.Unary, unary);
}

def unary_kind_to_static_string(kind: UnaryKind): string {
    return mir_unary2str(*(&kind as *i32));
}

def as_expr_unary(e: *Expression): *ExprUnary {
    return e.data as *ExprUnary;
}

def is_expr_unary(e: *Expression): bool {
    return e.kind == ExprKind.Unary;
}

type ExprCopy struct {
    addr: Address
}

def new_expr_copy(addr: Address): Expression {
    let cpy = (new ExprCopy { addr: addr }) as *void;
    return create_expr(ExprKind.Copy, cpy);
}

def as_expr_copy(e: *Expression): *ExprCopy {
    return e.data as *ExprCopy;
}

def is_expr_copy(e: *Expression): bool {
    return e.kind == ExprKind.Copy;
}

type ExprCall struct {
    callee: Address,
    args: vec.Vec, // Vec<Address>
    varargs: bool
}

def new_expr_call(callee: Address, args: vec.Vec, varargs: bool): Expression {
    let call = (new ExprCall { callee: callee, args: args, varargs: varargs });
    return create_expr(ExprKind.Call, call as *void);
}

type IntrinsicFunction enum {
    MemSet
}

def (f: IntrinsicFunction) name(): name.Owned {
    return name.make_copied(13, "kantan.memset");
}

def new_intrinsic_call(f: IntrinsicFunction, args: vec.Vec, varargs: bool): Expression {
    let to_call = *(&f as *usize);
    let callee = create_addr(AddrKind.Intrinsic, null, std.int_to_ptr(to_call), null);
    return new_expr_call(callee, args, varargs);
}

def (call: *ExprCall) is_intrinsic(): bool {
    return call.callee.kind == AddrKind.Intrinsic;
}

def (call: *ExprCall) get_intrinsic(): IntrinsicFunction {
    let as_int = std.ptr_to_int(call.callee.data_hi);
    return *(&as_int as *IntrinsicFunction);
}

def call_arg_at(call: *ExprCall, idx: u32): *Address {
    return call.args.get_ptr(idx as usize) as *Address;
}

def as_expr_call(e: *Expression): *ExprCall {
    return e.data as *ExprCall;
}

def is_expr_call(e: *Expression): bool {
    return e.kind == ExprKind.Call;
}

type ExprGep struct {
    addr: Address,
    idx: u32
}

def new_expr_gep(addr: Address, idx: u32): Expression {
    let gep = (new ExprGep { addr: addr, idx: idx }) as *void;
    return create_expr(ExprKind.Gep, gep);
}

def as_expr_gep(e: *Expression): *ExprGep {
    return e.data as *ExprGep;
}

def is_expr_gep(e: *Expression): bool {
    return e.kind == ExprKind.Gep;
}

type ExprUnionAccess struct {
    addr: Address,
    as_type: *ty.Type
}

def new_expr_union_access(addr: Address, as_type: *ty.Type): Expression {
    let union_access = (new ExprUnionAccess { addr: addr, as_type: as_type }) as *void;
    return create_expr(ExprKind.UnionAccess, union_access);
}

def as_expr_union_access(e: *Expression): *ExprUnionAccess {
    return e.data as *ExprUnionAccess;
}

def is_expr_union_access(e: *Expression): bool {
    return e.kind == ExprKind.UnionAccess;
}

type ExprStructInit struct {
    name: name.Ref,
    args: vec.Vec // Vec<Address>
}

def new_expr_struct_init(name: name.Ref, args: vec.Vec): Expression {
    let init = (new ExprStructInit { name: name, args: args }) as *void;
    return create_expr(ExprKind.StructInit, init);
}

def init_arg_at(init: *ExprStructInit, idx: u32): *Address {
    return init.args.get_ptr(idx as usize) as *Address;
}

def as_expr_struct_init(e: *Expression): *ExprStructInit {
    return e.data as *ExprStructInit;
}

def is_expr_struct_init(e: *Expression): bool {
    return e.kind == ExprKind.StructInit;
}

type ExprNew struct {
    addr: Address
}

def new_expr_new(addr: Address): Expression {
    let new_e = (new ExprNew { addr: addr }) as *void;
    return create_expr(ExprKind.New, new_e);
}

def as_expr_new(e: *Expression): *ExprNew {
    return e.data as *ExprNew;
}

def is_expr_new(e: *Expression): bool {
    return e.kind == ExprKind.New;
}

type ExprSizeOf struct {
    ty: *ty.Type
}

def new_expr_sizeof(t: *ty.Type): Expression {
    let so = (new ExprSizeOf { ty: t }) as *void;
    return create_expr(ExprKind.SizeOf, so);
}

def as_expr_sizeof(e: *Expression): *ExprSizeOf {
    return e.data as *ExprSizeOf;
}

def is_expr_sizeof(e: *Expression): bool {
    return e.kind == ExprKind.SizeOf;
}

type ExprCast struct {
    kind: CastKind,
    addr: Address,
    into: *ty.Type
}

type CastKind enum {
    Bit, IntNoLoad, Int, Float, Bool
}

def (k: CastKind) to_string(): string {
    if k == CastKind.Bit {
        return "bitcast";
    }
    if k == CastKind.IntNoLoad {
        return "ias_nl";
    }
    if k == CastKind.Int {
        return "ias";
    }
    if k == CastKind.Float {
        return "fas";
    }
    if k == CastKind.Bool {
        return "bas";
    }

    return "invalid_cast";
}

def new_expr_cast(kind: CastKind, addr: Address, into: *ty.Type): Expression {
    let cast = (new ExprCast { kind: kind, addr: addr, into: into });
    return create_expr(ExprKind.Cast, cast as *void);
}

def new_expr_int_cast_no_load(addr: Address, into: *ty.Type): Expression {
    return new_expr_cast(CastKind.IntNoLoad, addr, into);
}

def as_expr_cast(e: *Expression): *ExprCast {
    return e.data as *ExprCast;
}

def is_expr_cast(e: *Expression): bool {
    return e.kind == ExprKind.Cast;
}

type ExprKind enum {
    Error,
    Binary,
    Unary,
    Copy,
    Call,
    Gep,
    UnionAccess,
    StructInit,
    New,
    SizeOf,
    Cast
}

// An expression is always on the right side of an assignment instruction
// In the comments, this assignment is denoted as 'x = '
//
// x = y op z:
//  Binary(Address, BinaryType, Address)
// x = op y
//  Unary(UnaryType, Address),
// x = y:
//  Copy(Address),
// x = call f (y, z):
//  Call(name.Ref, Vec<Address>, varargs: bool)
// Gets a pointer to the Xth element of a struct or array
// x = base + offset:
//  StructGep(Address, i32)
// x = test { 41, "test" }:
//  StructInit(name.Ref, Vec<Address>),
// allocates the value of its address on the heap
// x = new 5:
//  New(Address),
// x = sizeof(ty):
//  SizeOf(*ty.Type),
// x = param #y:
//  GetParam(i32),
// Cast the value at the address to the supplied type
// x = cast e to ty2:
//  Cast(i32, Address, Type),
type Expression struct {
    kind: ExprKind,
    data: *void
}

def create_expr(kind: ExprKind, data: *void): Expression {
    return Expression {kind: kind, data: data};
}

def empty_expr(): Expression {
    return create_expr(ExprKind.Error, null);
}

def free_expr(e: *Expression): void {
    if is_expr_call(e) {
        let c_expr = as_expr_call(e);
        c_expr.args.free();
    } else if is_expr_struct_init(e) {
        let i_expr = as_expr_struct_init(e);
        i_expr.args.free();
    }

    if e.data != null {
        delete e.data;
    }
}

def expr_to_name(e: *Expression): name.Owned {
    if is_expr_binary(e) {
        let bin = as_expr_binary(e);

        let left = addr_to_name(&bin.left);
        let right = addr_to_name(&bin.right);
        let op = binary_kind_to_static_string(bin.kind);

        let len: usize = 0;
        let s = std.l_format_str(
            &len, "(%.*s)%s(%.*s)", left.len, left.data, op, right.len, right.data
        );

        name.free_owned(&left);
        name.free_owned(&right);
        return name.make_owned(len, s);
    }

    if is_expr_unary(e) {
        let unary = as_expr_unary(e);

        let addr = addr_to_name(&unary.addr);
        let op = unary_kind_to_static_string(unary.kind);

        let len: usize = 0;
        let s = std.l_format_str(&len, "%s(%.*s)", op, addr.len, addr.data);

        name.free_owned(&addr);
        return name.make_owned(len, s);
    }

    if is_expr_copy(e) {
        let copy = as_expr_copy(e);

        let addr = addr_to_name(&copy.addr);
        let len: usize = 0;
        let s = std.l_format_str(&len, "copy %.*s", addr.len, addr.data);

        name.free_owned(&addr);
        return name.make_owned(len, s);
    }

    if is_expr_call(e) {
        let call = as_expr_call(e);

        let args_string = str.create();
        defer args_string.free();

        for let i: u32 = 0; i < call.args.len as u32; i += 1 {
            if i > 0 {
                args_string.push(str.view(2, ", "));
            }

            let arg = call_arg_at(call, i);
            let arg_n = addr_to_name(arg);

            args_string.push(str.view(arg_n.len as usize, arg_n.data));
            name.free_owned(&arg_n);
        }

        let n: name.Owned = undefined;
        if call.is_intrinsic() {
            n = call.get_intrinsic().name();
        } else {
            n = addr_to_name(&call.callee);
        }

        let len: usize = 0;
        let s = std.l_format_str(
            &len, "%.*s(%s)", n.len, n.data, args_string.cstring()
        );
        name.free_owned(&n);

        return name.make_owned(len, s);
    }

    if is_expr_gep(e) {
        let gep = as_expr_gep(e);
        let addr_n = addr_to_name(&gep.addr);

        let len: usize = 0;
        let s = std.l_format_str(
            &len, "gep(%.*s, %d)", addr_n.len, addr_n.data, gep.idx
        );

        name.free_owned(&addr_n);
        return name.make_owned(len, s);
    }

    if is_expr_union_access(e) {
        let union_access = as_expr_union_access(e);
        let addr_n = addr_to_name(&union_access.addr);

        let ty_s = ty.to_string(union_access.as_type);
        defer ty_s.free();

        let len: usize = 0;
        let s = std.l_format_str(
            &len, "union_access(%.*s, %s)", addr_n.len, addr_n.data, ty_s.cstring()
        );

        name.free_owned(&addr_n);
        return name.make_owned(len, s);
    }

    if is_expr_struct_init(e) {
        let init = as_expr_struct_init(e);

        let args_string = str.create();
        defer args_string.free();

        for let i: u32 = 0; i < init.args.len as u32; i += 1 {
            if i > 0 {
                args_string.push(str.view(2, ", "));
            }

            let arg = init_arg_at(init, i);
            let arg_n = addr_to_name(arg);

            args_string.push(str.view(arg_n.len as usize, arg_n.data));
            name.free_owned(&arg_n);
        }

        let n = init.name;
        let len: usize = 0;
        let s = std.l_format_str(
            &len, "%.*s{%s}", n.len, n.data, args_string.cstring()
        );

        return name.make_owned(len, s);
    }

    if is_expr_new(e) {
        let n = as_expr_new(e);
        let addr_n = addr_to_name(&n.addr);

        let len: usize = 0;
        let s = std.l_format_str(&len, "new %.*s", addr_n.len, addr_n.data);

        name.free_owned(&addr_n);
        return name.make_owned(len, s);
    }

    if is_expr_sizeof(e) {
        let so = as_expr_sizeof(e);

        let ty_s = ty.to_string(so.ty);
        defer ty_s.free();

        let len: usize = 0;
        let s = std.l_format_str(&len, "sizeof(%s)", ty_s.cstring());

        return name.make_owned(len, s);
    }

    if is_expr_cast(e) {
        let cast = as_expr_cast(e);
        let addr_n = addr_to_name(&cast.addr);

        let ty_s = ty.to_string(cast.into);
        defer ty_s.free();

        let len: usize = 0;
        let s = std.l_format_str(
            &len, "(%.*s %s %s)", addr_n.len, addr_n.data, cast.kind.to_string(), ty_s.cstring()
        );

        name.free_owned(&addr_n);

        return name.make_owned(len, s);
    }

    return name.make_owned(0, null);
}

type InstDecl struct {
    name: name.Ref, // The nametable owns the actual name
    ty: *ty.Type
}

def new_inst_decl(meta: MetaData, name: name.Ref, ty: *ty.Type): Inst {
    return create_inst(
        InstKind.Decl,
        meta,
        (new InstDecl {name: name, ty: ty}) as *void
    );
}

def is_inst_decl(inst: *Inst): bool {
    return inst.kind == InstKind.Decl;
}

def as_inst_decl(inst: *Inst): *InstDecl {
    return inst.data as *InstDecl;
}

type InstAssign struct {
    dest: Address,
    value: Expression,
    // TODO: convert this to a union
    param_idx: isize, // -1 if this is not a param
    var_scope: Scope, // every variable opens an implicit scope, after it was assigned
    original_ident: ident.Ident
}

def new_inst_assign(meta: MetaData, dest: Address, value: Expression, t: *ty.Type): Inst {
    return new_inst_assign_param(meta, dest, value, t, -1);
}

def assign_has_original_ident(a: *InstAssign): bool {
    return !ident.is_empty(&a.original_ident);
}

def new_inst_assign_param(
    meta: MetaData,
    dest: Address,
    value: Expression,
    t: *ty.Type,
    param_idx: isize
): Inst {
    return create_inst(
        InstKind.Assign,
        meta,
        (new InstAssign {
            dest: dest,
            value: value,
            param_idx: param_idx,
            var_scope: meta.scope,
            original_ident: ident.empty()
        }) as *void
    );
}

def new_inst_assign_decl(
    meta: MetaData,
    dest: Address,
    value: Expression,
    t: *ty.Type,
    var_scope: Scope,
    original_ident: ident.Ident
): Inst {
    return create_inst (
        InstKind.Assign,
        meta,
        (new InstAssign {
            dest: dest,
            value: value,
            param_idx: -1,
            var_scope: var_scope,
            original_ident: original_ident
        }) as *void
    );
}

def is_inst_assign(inst: *Inst): bool {
    return inst.kind == InstKind.Assign;
}

def as_inst_assign(inst: *Inst): *InstAssign {
    return inst.data as *InstAssign;
}

type InstJmp struct {
    target: Label
}

def new_inst_jmp(meta: MetaData, target: Label): Inst {
    return create_inst(
        InstKind.Jmp,
        meta,
        (new InstJmp {target: target}) as *void
    );
}

def is_inst_jmp(inst: *Inst): bool {
    return inst.kind == InstKind.Jmp;
}

def as_inst_jmp(inst: *Inst): *InstJmp {
    return inst.data as *InstJmp;
}

type InstJmpIf struct {
    condition: Address,
    if_target: Label,
    else_target: Label
}

def new_inst_jmpif(
    meta: MetaData,
    condition: Address,
    if_target: Label,
    else_target: Label
): Inst {
    return create_inst(
        InstKind.JmpIf,
        meta,
        (new InstJmpIf {
            condition: condition, if_target: if_target, else_target: else_target
        }) as *void
    );
}


def is_inst_jmpif(inst: *Inst): bool {
    return inst.kind == InstKind.JmpIf;
}

def as_inst_jmpif(inst: *Inst): *InstJmpIf {
    return inst.data as *InstJmpIf;
}

type InstReturn struct {
    value: Address // AddrKind.Empty if empty return: 'return;'
}

def new_inst_return(meta: MetaData): Inst {
    return new_inst_return_value(meta, create_addr_empty());
}

def new_inst_return_value(meta: MetaData, value: Address): Inst {
    return create_inst(
        InstKind.Return,
        meta,
        (new InstReturn { value: value }) as *void
    );
}

def is_inst_return(inst: *Inst): bool {
    return inst.kind == InstKind.Return;
}

def as_inst_return(inst: *Inst): *InstReturn {
    return inst.data as *InstReturn;
}

type InstLabel struct {
    value: Label
}

def new_inst_label(meta: MetaData, value: Label): Inst {
    return create_inst(
        InstKind.Label,
        meta,
        (new InstLabel { value: value }) as *void
    );
}

def is_inst_label(inst: *Inst): bool {
    return inst.kind == InstKind.Label;
}

def as_inst_label(inst: *Inst): *InstLabel {
    return inst.data as *InstLabel;
}

type InstDelete struct {
    addr: Address
}

def new_inst_delete(meta: MetaData, target: Address): Inst {
    return create_inst(
        InstKind.Delete,
        meta,
        (new InstDelete { addr: target }) as *void
    );
}

def is_inst_delete(inst: *Inst): bool {
    return inst.kind == InstKind.Delete;
}

def as_inst_delete(inst: *Inst): *InstDelete {
    return inst.data as *InstDelete;
}

def create_inst_nop(): Inst {
    return create_inst(
        InstKind.NOP,
        create_meta(source.empty_pos(), scope(ScopeKind.Variable)),
        null
    );
}

def is_inst_nop(inst: *Inst): bool {
    return inst.kind == InstKind.NOP;
}

type InstKind enum {
    Decl = 1,
    Assign,
    Jmp,
    JmpIf,
    Return,
    Label,
    Delete,
    NOP
}

// A single MIR instruction
//
// can be one of the following
// let x: i32:
//  Decl(name.Ref, Type),
// x = <expr>:
//  Assignment(Address, Expr),
// goto l:
//  Jmp(Label),
// if x goto l0 else goto l1:
//  JmpIf(Address, Label, Label),
// return x:
//  Return(Optional Address),
// .L0:
//  Label(Label),
// frees heap memory:
//  Delete(Address),
// No operation:
//  Nop,
type Inst struct {
    kind: InstKind,
    push_count: i32, // how often was this statement pushed (basically a ref count)
    meta: MetaData,
    data: *void
}

def create_inst(kind: InstKind, meta: MetaData, data: *void): Inst {
    return Inst {
        kind: kind, push_count: 0, meta: meta, data: data
    };
}

def inst_changes_ip(inst: *Inst): bool {
    return is_inst_jmp(inst) || is_inst_jmpif(inst) || is_inst_return(inst);
}

def inst_to_name(inst: *Inst): name.Owned {
    if is_inst_decl(inst) {
        let decl = as_inst_decl(inst);
        let ty_s = ty.to_string(decl.ty);
        defer ty_s.free();

        let len: usize = 0;
        let s = std.l_format_str(
            &len,
            "let %.*s: %s",
            decl.name.len,
            decl.name.data,
            ty_s.cstring()
        );

        return name.make_owned(len, s);
    }

    if is_inst_assign(inst) {
        let assign = as_inst_assign(inst);
        let a_n = addr_to_name(&assign.dest);
        let e_n = expr_to_name(&assign.value);

        let ty_s = str.from("void");
        defer ty_s.free();
        if !is_addr_empty(&assign.dest) {
            ty_s = ty.to_string(assign.dest.ty);
        }

        let len: usize = 0;
        let s = std.l_format_str(
            &len,
            "%.*s: %s = %.*s", a_n.len, a_n.data, ty_s.cstring(), e_n.len, e_n.data
        );

        name.free_owned(&a_n);
        name.free_owned(&e_n);

        return name.make_owned(len, s);
    }

    if is_inst_jmp(inst) {
        let jmp = as_inst_jmp(inst);
        let label = label_name(&jmp.target);

        let len: usize = 0;
        let s = std.l_format_str(
            &len, "jmp %.*s", label.len, label.data
        );

        return name.make_owned(len, s);
    }

    if is_inst_jmpif(inst) {
        let jmpif = as_inst_jmpif(inst);
        let if_label = label_name(&jmpif.if_target);
        let else_label = label_name(&jmpif.else_target);
        let condition = addr_to_name(&jmpif.condition);

        let len: usize = 0;
        let s = std.l_format_str(
            &len,
            "jmpif %.*s;%.*s;%.*s",
            condition.len,
            condition.data,
            if_label.len,
            if_label.data,
            else_label.len,
            else_label.data
        );

        name.free_owned(&condition);
        return name.make_owned(len, s);
    }

    if is_inst_return(inst) {
        let ret = as_inst_return(inst);
        if is_addr_empty(&ret.value) {
            return name.make_copied(6, "return");
        }

        let a_n = addr_to_name(&ret.value);
        let len: usize = 0;
        let s = std.l_format_str(&len, "return %.*s", a_n.len, a_n.data);

        name.free_owned(&a_n);
        return name.make_owned(len, s);
    }

    if is_inst_delete(inst) {
        let del = as_inst_delete(inst);
        let a_n = addr_to_name(&del.addr);

        let len: usize = 0;
        let s = std.l_format_str(&len, "delete %.*s", a_n.len, a_n.data);

        name.free_owned(&a_n);
        return name.make_owned(len, s);
    }

    if is_inst_nop(inst) {
        return name.make_copied(3, "nop");
    }

    return name.make_owned(0, null);
}

def free_inst(inst: *Inst) {
    inst.push_count -= 1;
    if inst.push_count > 0 {
        return;
    }

    if is_inst_assign(inst) {
        let assign = as_inst_assign(inst);
        free_expr(&assign.value);
    } if is_inst_jmp(inst) {
        let jmp = as_inst_jmp(inst);
        free_label(&jmp.target);
    } if is_inst_jmpif(inst) {
        let jmpif = as_inst_jmpif(inst);
        free_label(&jmpif.if_target);
        free_label(&jmpif.else_target);
    } if is_inst_label(inst) {
        let label = as_inst_label(inst);
        free_label(&label.value);
    }

    if inst.data != null {
        delete inst.data;
    }
}

type BlockMap struct {
    blocks: vmap.Map, // vmap.Map<name.Ref, BasicBlock>
    decls: vec.Vec    // vec.Vec<Inst>
}

def empty_block_map(): BlockMap {
    return BlockMap {
        blocks: vmap.create(sizeof BasicBlock),
        decls: vec.create(sizeof Inst)
    };
}

def create_block_map(func_name: name.Ref): BlockMap {
    let bm = BlockMap {
        blocks: vmap.create(sizeof BasicBlock),
        decls: vec.create(sizeof Inst)
    };

    let name = name.make_copied(func_name.len, func_name.data);
    let bb = create_bb(create_label(name));

    bm_push_block(&bm, &bb);

    return bm;
}

def bm_push_block(bm: *BlockMap, bb: *BasicBlock): void {
    let name = label_name(&bb.label);
    let key = map.create_key(name.len, name.data);
    vmap.insert(&bm.blocks, key, bb as *void);
}

def free_block_map(bm: *BlockMap) {
    for let i: usize = 0; i < vmap.len(&bm.blocks); i += 1 {
        free_bb(vmap.get_ptr_idx(&bm.blocks, i) as *BasicBlock);
    }

    vmap.free_m(&bm.blocks);

    for let i: usize = 0; i < bm.decls.len; i += 1 {
        free_inst(bm.decls.get_ptr(i) as *Inst);
    }

    bm.decls.free();
}

def bm_num_blocks(bm: *BlockMap): usize {
    return vmap.len(&bm.blocks);
}

def bm_get_bb_ptr(bm: *BlockMap, idx: usize): *BasicBlock {
    return vmap.get_ptr_idx(&bm.blocks, idx) as *BasicBlock;
}

def bm_last_bb_ptr(bm: *BlockMap): *BasicBlock {
    return bm_get_bb_ptr(bm, vmap.len(&bm.blocks) - 1);
}

def bm_decl_at(bm: *BlockMap, idx: usize): Inst {
    return *(bm.decls.get_ptr(idx) as *Inst);
}

def bm_push_instr_to_last_bb(bm: *BlockMap, inst: *Inst) {
    let last_bb = bm_last_bb_ptr(bm);
    bb_push_instr(last_bb, inst);
}

def bm_push_new_block(bm: *BlockMap) {
    let label_len: usize = 0;
    // TODO(#79): this id is not unique across modules
    let label = std.l_format_str(&label_len, ".block%d", vmap.len(&bm.blocks));
    let new_bb = create_bb(create_label(name.make_owned(label_len, label)));
    bm_push_block(bm, &new_bb);
}

def bm_push_new_labeled_block(bm: *BlockMap, label: Label) {
    let new_bb = create_bb(label);
    bm_push_block(bm, &new_bb);
}

def bm_push_instr(bm: *BlockMap, inst: *Inst) {
    // the last blocks was already closed, so we need to open a new one

    if is_inst_decl(inst) {
        bm.decls.push(inst as *void);
        return;
    }

    if is_inst_label(inst) {
        if is_inst_nop(&bm_last_bb_ptr(bm).terminator) {
            // Terminate last block with goto
            let target = clone_label(&as_inst_label(inst).value);
            let goto = new_inst_jmp(inst.meta, target);
            let last_bb = bm_last_bb_ptr(bm);
            last_bb.terminator = goto;
        }

        bm_push_new_labeled_block(bm, as_inst_label(inst).value);
        // the instruction iteself is now useless, since we moved the value out
        delete inst.data;
        return;
    }

    if inst_changes_ip(inst) {
        let last_bb = bm_last_bb_ptr(bm);
        // don't overwrite terminators
        if is_inst_nop(&last_bb.terminator) {
            last_bb.terminator = *inst;
        } else {
            free_inst(inst);
        }
        return;
    }

    bm_push_instr_to_last_bb(bm, inst);
}

// dump BlockMap to stdout for debug purposes
def bm_dump(bm: *BlockMap): void {
    let first_bb = vmap.get_ptr_idx(&bm.blocks, 0) as *BasicBlock;
    let n = label_name(&first_bb.label);
    io.printf("%.*s:\n", n.len, n.data);

    for let i: usize = 0; i < bm.decls.len; i += 1 {
        let decl = bm.decls.get_ptr(i) as *Inst;
        let n = inst_to_name(decl);
        io.printf("  %.*s\n", n.len, n.data);
        name.free_owned(&n);
    }

    for let i: usize = 0; i < vmap.len(&bm.blocks); i += 1 {
        let bb = vmap.get_ptr_idx(&bm.blocks, i) as *BasicBlock;

        let bb_name = label_name(&bb.label);
        if bb_name.data != n.data {
            io.printf("label: %.*s:\n", bb_name.len, bb_name.data);
        }

        for let j: usize = 0; j < bb_num_instr(bb); j += 1 {
            let inst = bb_get_instr(bb, j);
            let n = inst_to_name(inst);
            io.printf("  %.*s\n", n.len, n.data);
            name.free_owned(&n);
        }

        let n = inst_to_name(&bb.terminator);
        io.printf("  term: %.*s\n", n.len, n.data);
        name.free_owned(&n);
    }
}
