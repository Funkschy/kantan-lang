#include "mir_types.h"
#include "std.h"

import "span";
import "ty";
import "std";
import "source";
import "vec";

type MetaData struct {
    pos: source.SourcePos
}

type Name struct {
    owned: bool,
    len: i32,
    data: string
}

def free_name(n: *Name): void {
    if n.owned {
        delete n.data;
    }
}

type Label struct {
    name: Name
}

def label_name(l: *Label): Name {
    return Name { owned: false, len: l.name.len, data: l.name.data };
}

type AddressName struct {
    value: Name
}

type AddressConst struct {
    span: span.Span
}

type AddressTemp struct {
    value: i32
}

type AddressGlobal struct {
    name: Name
}

type AddressRef struct {
    name: Name
}

def is_addr_empty(a: *Address): bool {
    return a.kind == MIR_ADDR_EMPTY;
}

type Address struct {
    kind: i32,
    ty: *ty.Type,
    data: *void
}

def addr_to_string(a: *Address): string {
    return null;
}

type ExprBinary struct {
    kind: i32,
    left: Address,
    right: Address
}

type ExprUnary struct {
    kind: i32,
    addr: Address
}

type ExprCopy struct {
    addr: Address
}

type ExprCall struct {
    name: Name,
    args: vec.Vec // Vec<Address>
}

type ExprStrucGep struct {
    addr: Address,
    idx: i32
}

type ExprStructInit struct {
    name: Name,
    args: vec.Vec // Vec<Address>
}

type ExprNew struct {
    addr: Address
}

type ExprSizeOf struct {
    addr: Address
}

type ExprGetParam struct {
    idx: i32
}

type ExprBitCast struct {
    addr: Address,
    into: *ty.Type
}

// An expression is always on the right side of an assignment instruction
// In the comments, this assignment is denoted as 'x = '
//
// x = y op z:
//  Binary(Address, BinaryType, Address)
// x = op y
//  Unary(UnaryType, Address),
// x = y:
//  Copy(Address),
// x = call f (y, z):
//  Call(Name, Vec<Address>, return: Type, varargs: bool)
// Gets a pointer to the Xth element of a struct or array
// x = base + offset:
//  StructGep(Address, u32)
// x = test { 41, "test" }:
//  StructInit(UserIdent, Vec<Address>),
// allocates the value of its address on the heap
// x = new 5:
//  New(Address, Type),
// x = sizeof(ty):
//  SizeOf(Type),
// x = param #y:
//  GetParam(u32),
// Cast the value at the address to the supplied type
// x = bitcast e to ty2:
//  BitCast(Address, Type),
type Expression struct {
    kind: i32,
    data: *void
}

def expr_to_string(e: *Expression): string {
    return null;
}

type InstDecl struct {
    name: Name,
    ty: *ty.Type
}

def new_inst_decl(meta: MetaData, name: Name, ty: *ty.Type): Inst {
    return Inst {
        kind: MIR_INST_DECL,
        meta: meta,
        data: (new InstDecl {name: name, ty: ty}) as *void
    };
}

def is_inst_decl(inst: *Inst): bool {
    return inst.kind == MIR_INST_DECL;
}

def as_inst_decl(inst: *Inst): *InstDecl {
    return inst.data as *InstDecl;
}

type InstAssign struct {
    dest: Address,
    value: Expression
}

def is_inst_assign(inst: *Inst): bool {
    return inst.kind == MIR_INST_ASSIGN;
}

def as_inst_assign(inst: *Inst): *InstAssign {
    return inst.data as *InstAssign;
}

type InstJmp struct {
    target: Label
}

def is_inst_jmp(inst: *Inst): bool {
    return inst.kind == MIR_INST_JMP;
}

def as_inst_jmp(inst: *Inst): *InstJmp {
    return inst.data as *InstJmp;
}

type InstJmpIf struct {
    condition: Address,
    if_target: Label,
    else_target: Label
}

def is_inst_jmpif(inst: *Inst): bool {
    return inst.kind == MIR_INST_JMPIF;
}

def as_inst_jmpif(inst: *Inst): *InstJmpIf {
    return inst.data as *InstJmpIf;
}

type InstReturn struct {
    value: Address // MIR_ADDR_EMPTY if empty return: 'return;'
}

def is_inst_return(inst: *Inst): bool {
    return inst.kind == MIR_INST_RETURN;
}

def as_inst_return(inst: *Inst): *InstReturn {
    return inst.data as *InstReturn;
}

type InstLabel struct {
    value: Label
}

def is_inst_label(inst: *Inst): bool {
    return inst.kind == MIR_INST_LABEL;
}

def as_inst_label(inst: *Inst): *InstLabel {
    return inst.data as *InstLabel;
}

def is_inst_delete(inst: *Inst): bool {
    return inst.kind == MIR_INST_DELETE;
}

def as_inst_delete(inst: *Inst): *InstDelete {
    return inst.data as *InstDelete;
}

type InstDelete struct {
    addr: Address
}

// A single MIR instruction
//
// can be one of the following
// let x: i32:
//  Decl(Address, Type),
// x = <expr>:
//  Assignment(Address, Expr),
// goto l:
//  Jmp(Label),
// if x goto l0 else goto l1:
//  JmpIf(Address, Label, Label),
// return x:
//  Return(Optional Address),
// .L0:
//  Label(Label),
// frees heap memory:
//  Delete(Address),
// No operation:
//  Nop,
type Inst struct {
    kind: i32,
    meta: MetaData,
    data: *void
}

def inst_to_string(inst: *Inst): string {
    if is_inst_decl(inst) {
        let decl = as_inst_decl(inst);
        let ty_s: string = null;
        let free_ty_s = ty.to_string(decl.ty, &ty_s);

        let s = std.format_str(
            "let %.*s: %s",
            decl.name.len,
            decl.name.data

        );

        if free_ty_s {
            delete ty_s;
        }

        return s;
    }

    if is_inst_assign(inst) {
        let assign = as_inst_assign(inst);
        let a_s = addr_to_string(&assign.dest);
        let e_s = expr_to_string(&assign.value);

        let s = std.format_str("%s = %s", a_s, e_s);

        delete a_s;
        delete e_s;

        return s;
    }

    if is_inst_jmp(inst) {
        let jmp = as_inst_jmp(inst);
        let label = label_name(&jmp.target);

        // just copy the data, since this function is for debug only
        return std.strndup(label.data, label.len);
    }

    if is_inst_jmpif(inst) {
        let jmpif = as_inst_jmpif(inst);
        let if_label = label_name(&jmpif.if_target);
        let else_label = label_name(&jmpif.else_target);
        let condition = addr_to_string(&jmpif.condition);

        let s = std.format_str("jmp %s;%.*s;%.*s", condition, if_label, else_label);
        delete condition;

        return s;
    }

    if is_inst_return(inst) {
        let ret = as_inst_return(inst);
        if is_addr_empty(&ret.value) {
            return std.strdup("return");
        }

        let a_s = addr_to_string(&ret.value);
        let s = std.format_str("return %s", a_s);

        delete a_s;
        return s;
    }

    if is_inst_label(inst) {
        let label = as_inst_label(inst);
        let name = label_name(&label.value);
        return std.format_str("%.*s:", name.len, name.data);
    }

    if is_inst_delete(inst) {
        let del = as_inst_delete(inst);
        let a_s = addr_to_string(&del.addr);

        let s = std.format_str("delete %s", a_s);

        delete a_s;
        return s;
    }

    return null;
}

def free_inst(inst: *Inst): void {
    if inst.data != null {
        delete inst.data;
    }
}
