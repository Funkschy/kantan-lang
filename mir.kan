#include "mir_types.h"
#include "std.h"

import "io";
import "ty";
import "std";
import "vec";
import "str";
import "map";
import "dbg";
import "span";
import "source";

extern def mir_binary2str(kind: i32): string;
extern def mir_unary2str(kind: i32): string;

type Module struct {
    globals: map.Map, // map.Map<RefName, GlobalConst>
    functions: map.Map // map.Map<RefName, Func>
}

def create_mod(globals: map.Map, funcs: map.Map): Module {
    return Module {
        globals: globals,
        functions: funcs
    };
}

def free_mod(m: *Module): void {
    // free function names
    let f_iter = map.iter(&m.functions);
    let item = map.iter_next(&f_iter);
    while item != null {
        let f = item.value as *Func;
        free_func(f);
        delete f;

        item = map.iter_next(&f_iter);
    }

    // free globals
    let g_iter = map.iter(&m.globals);
    let item = map.iter_next(&g_iter);
    while item != null {
        let gc = item.value as *GlobalConst;
        free_global_const(gc);
        delete gc;

        item = map.iter_next(&g_iter);
    }

    map.free_m(&m.functions);
    map.free_m(&m.globals);
}

type Func struct {
    name: OwnedName,
    blocks: BlockMap,
    ty: *ty.Type
}

def create_func(t: *ty.Type, mangled_name: OwnedName): Func {
    dbg.assert(ty.is_func(t), "func type was not func");

    return Func {
        name: mangled_name,
        blocks: create_block_map(ref_name(mangled_name)),
        ty: t
    };
}

def free_func(f: *Func): void {
    free_name(&f.name);
    free_block_map(&f.blocks);
}

def func_push_instr(f: *Func, inst: *Inst): void {
    bm_push_instr(&f.blocks, inst);
}

type MetaData struct {
    pos: source.SourcePos
}

def create_meta(pos: source.SourcePos): MetaData {
    return MetaData { pos: pos };
}

type GlobalConst struct {
    name: OwnedName,
    meta: MetaData,
    ty: *ty.Type
}

def create_const(name: OwnedName, meta: MetaData, ty: *ty.Type): GlobalConst {
    return GlobalConst {
        name: name,
        meta: meta,
        ty: ty
    };
}

def free_global_const(gc: *GlobalConst): void {
    free_name(&gc.name);
}

def const_name(c: *GlobalConst): RefName {
    return ref_name(c.name);
}

type InstBlock struct {
    instructions: vec.Vec // vec.Vec<Inst>
}

def create_inst_block(): InstBlock {
    return InstBlock { instructions: vec.create(sizeof Inst) };
}

def push_instr(b: *InstBlock, inst: *Inst): void {
    vec.push(&b.instructions, inst as *void);
}

def get_instr(b: *InstBlock, idx: i32): *Inst {
    return vec.get_ptr(&b.instructions, idx) as *Inst;
}

def free_inst_block(b: *InstBlock): void {
    let i = 0;
    while i < b.instructions.len {
        free_inst(vec.get_ptr(&b.instructions, i) as *Inst);
        i = i + 1;
    }
    vec.free_v(&b.instructions);
}

type BasicBlock struct {
    label: Label,
    instructions: InstBlock,
    terminator: Inst
}

def create_bb(label: Label): BasicBlock {
    return BasicBlock {
        label: label,
        instructions: create_inst_block(),
        terminator: create_inst_nop()
    };
}

// number of instructions excluding label and terminator
def bb_num_instr(bb: *BasicBlock): i32 {
    return bb.instructions.instructions.len;
}

def bb_push_instr(bb: *BasicBlock, inst: *Inst): void {
    push_instr(&bb.instructions, inst);
}

def bb_get_instr(bb: *BasicBlock, idx: i32): *Inst {
    return get_instr(&bb.instructions, idx);
}

def free_bb(bb: *BasicBlock): void {
    free_label(&bb.label);
    free_inst_block(&bb.instructions);
    free_inst(&bb.terminator);
}

type OwnedName struct {
    len: i32,
    data: string
}

def free_name(n: *OwnedName): void {
    delete n.data;
}

type RefName struct {
    len: i32,
    data: string
}

def make_owned_name(len: i32, data: string): OwnedName {
    return OwnedName { len: len, data: data };
}

// like make_owned_name, but copies the data automatically
def make_copied_name(len: i32, data: string): OwnedName {
    return make_owned_name(len, std.strndup(data, len));
}

def make_ref_name(len: i32, data: string): RefName {
    return RefName { len: len, data: data };
}

def ref_name(owned: OwnedName): RefName {
    return make_ref_name(owned.len, owned.data);
}

def empty_name(): RefName {
    return make_ref_name(0, null);
}

type Label struct {
    name: OwnedName
}

def create_label(n: OwnedName): Label {
    return Label { name: n };
}

def clone_label(l: *Label): Label {
    return create_label(make_copied_name(l.name.len, l.name.data));
}

def free_label(l: *Label): void {
    free_name(&l.name);
}

def label_name(l: *Label): RefName {
    return ref_name(l.name);
}

type AddressName struct {
    value: RefName // name table owns name
}

def new_addr_name(value: RefName, ty: *ty.Type): Address {
    let n = (new AddressName { value: value }) as *void;
    return create_addr(MIR_ADDR_NAME, ty, n);
}

def as_addr_name(a: *Address): *AddressName {
    return a.data as *AddressName;
}

def is_addr_name(a: *Address): bool {
    return a.kind == MIR_ADDR_NAME;
}

type AddressConst struct {
    span: span.Span
}

def new_addr_const(ty: *ty.Type, s: span.Span): Address {
    let cnst = (new AddressConst { span: s }) as *void;
    return create_addr(MIR_ADDR_CONST, ty, cnst);
}

def as_addr_const(a: *Address): *AddressConst {
    return a.data as *AddressConst;
}

def is_addr_const(a: *Address): bool {
    return a.kind == MIR_ADDR_CONST;
}

type AddressTemp struct {
    value: i32
}

def as_addr_temp(a: *Address): *AddressTemp {
    return a.data as *AddressTemp;
}

def is_addr_temp(a: *Address): bool {
    return a.kind == MIR_ADDR_TEMP;
}

type AddressGlobal struct {
    name: RefName
}

def new_addr_global(name: RefName, ty: *ty.Type): Address {
    return Address {
        kind: MIR_ADDR_GLOBAL,
        ty: ty,
        data: (new AddressGlobal { name: name }) as *void
    };
}

def as_addr_global(a: *Address): *AddressGlobal {
    return a.data as *AddressGlobal;
}

def is_addr_global(a: *Address): bool {
    return a.kind == MIR_ADDR_GLOBAL;
}

type AddressRef struct {
    name: RefName
}

def new_addr_ref(name: RefName, ty: *ty.Type): Address {
    return create_addr(MIR_ADDR_REF, ty, (new AddressRef { name: name }) as *void);
}

def as_addr_ref(a: *Address): *AddressRef {
    return a.data as *AddressRef;
}

def is_addr_ref(a: *Address): bool {
    return a.kind == MIR_ADDR_REF;
}

def create_addr_empty(): Address {
    return create_addr(MIR_ADDR_EMPTY, null, null);
}

def is_addr_empty(a: *Address): bool {
    return a.kind == MIR_ADDR_EMPTY;
}

def create_addr_null(ty: *ty.Type): Address {
    return create_addr(MIR_ADDR_NULL, ty, null);
}

def is_addr_null(a: *Address): bool {
    return a.kind == MIR_ADDR_NULL;
}

type Address struct {
    kind: i32,
    ty: *ty.Type,
    data: *void
}

def create_addr(kind: i32, ty: *ty.Type, data: *void): Address {
    return Address {
        kind: kind, ty: ty, data: data
    };
}

def free_addr(a: *Address): void {
    if a.data != null {
        delete a.data;
    }
}

def addr_to_string(a: *Address): string {
    if is_addr_name(a) {
        let name = as_addr_name(a);
        return std.strndup(name.value.data, name.value.len);
    }

    if is_addr_const(a) {
        let const = as_addr_const(a);
        return std.format_str("const %.*s", span.len(const.span), const.span.start);
    }

    if is_addr_temp(a) {
        let tmp = as_addr_temp(a);
        return std.format_str("_t%d", tmp.value);
    }

    if is_addr_global(a) {
        let global = as_addr_global(a);
        return std.format_str("global %.*s", global.name.len, global.name.data);
    }

    if is_addr_ref(a) {
        let ref = as_addr_ref(a);
        return std.format_str("&%.*s", ref.name.len, ref.name.data);
    }

    if is_addr_empty(a) {
        return std.strdup("_");
    }

    if is_addr_null(a) {
        return std.strdup("null");
    }

    return null;
}

type ExprBinary struct {
    kind: i32,
    left: Address,
    right: Address
}

def binary_kind_to_static_string(kind: i32): string {
    return mir_binary2str(kind);
}

def as_expr_binary(e: *Expression): *ExprBinary {
    return e.data as *ExprBinary;
}

def is_expr_binary(e: *Expression): bool {
    return e.kind == MIR_EXPR_BINARY;
}

type ExprUnary struct {
    kind: i32,
    addr: Address
}

def unary_kind_to_static_string(kind: i32): string {
    return mir_unary2str(kind);
}

def as_expr_unary(e: *Expression): *ExprUnary {
    return e.data as *ExprUnary;
}

def is_expr_unary(e: *Expression): bool {
    return e.kind == MIR_EXPR_UNARY;
}

type ExprCopy struct {
    addr: Address
}

def new_copy_expr(addr: Address): Expression {
    let cpy = (new ExprCopy { addr: addr }) as *void;
    return create_expr(MIR_EXPR_COPY, cpy);
}

def as_expr_copy(e: *Expression): *ExprCopy {
    return e.data as *ExprCopy;
}

def is_expr_copy(e: *Expression): bool {
    return e.kind == MIR_EXPR_COPY;
}

type ExprCall struct {
    name: RefName,
    args: vec.Vec, // Vec<Address>
    varargs: bool
}

def call_arg_at(call: *ExprCall, idx: i32): *Address {
    return vec.get_ptr(&call.args, idx) as *Address;
}

def as_expr_call(e: *Expression): *ExprCall {
    return e.data as *ExprCall;
}

def is_expr_call(e: *Expression): bool {
    return e.kind == MIR_EXPR_CALL;
}

type ExprStructGep struct {
    addr: Address,
    idx: i32
}

def as_expr_struct_gep(e: *Expression): *ExprStructGep {
    return e.data as *ExprStructGep;
}

def is_expr_struct_gep(e: *Expression): bool {
    return e.kind == MIR_EXPR_STRUCTGEP;
}

type ExprStructInit struct {
    name: RefName,
    args: vec.Vec // Vec<Address>
}

def init_arg_at(init: *ExprStructInit, idx: i32): *Address {
    return vec.get_ptr(&init.args, idx) as *Address;
}

def as_expr_struct_init(e: *Expression): *ExprStructInit {
    return e.data as *ExprStructInit;
}

def is_expr_struct_init(e: *Expression): bool {
    return e.kind == MIR_EXPR_STRUCTINIT;
}

type ExprNew struct {
    addr: Address
}

def as_expr_new(e: *Expression): *ExprNew {
    return e.data as *ExprNew;
}

def is_expr_new(e: *Expression): bool {
    return e.kind == MIR_EXPR_NEW;
}

type ExprSizeOf struct {
    addr: Address
}

def as_expr_sizeof(e: *Expression): *ExprSizeOf {
    return e.data as *ExprSizeOf;
}

def is_expr_sizeof(e: *Expression): bool {
    return e.kind == MIR_EXPR_SIZEOF;
}

type ExprGetParam struct {
    idx: i32
}

def as_expr_getparam(e: *Expression): *ExprGetParam {
    return e.data as *ExprGetParam;
}

def is_expr_getparam(e: *Expression): bool {
    return e.kind == MIR_EXPR_GETPARAM;
}

type ExprBitCast struct {
    addr: Address,
    into: *ty.Type
}

def as_expr_bitcast(e: *Expression): *ExprBitCast {
    return e.data as *ExprBitCast;
}

def is_expr_bitcast(e: *Expression): bool {
    return e.kind == MIR_EXPR_BITCAST;
}

// An expression is always on the right side of an assignment instruction
// In the comments, this assignment is denoted as 'x = '
//
// x = y op z:
//  Binary(Address, BinaryType, Address)
// x = op y
//  Unary(UnaryType, Address),
// x = y:
//  Copy(Address),
// x = call f (y, z):
//  Call(RefName, Vec<Address>, varargs: bool)
// Gets a pointer to the Xth element of a struct or array
// x = base + offset:
//  StructGep(Address, i32)
// x = test { 41, "test" }:
//  StructInit(RefName, Vec<Address>),
// allocates the value of its address on the heap
// x = new 5:
//  New(Address),
// x = sizeof(ty):
//  SizeOf(Address),
// x = param #y:
//  GetParam(i32),
// Cast the value at the address to the supplied type
// x = bitcast e to ty2:
//  BitCast(Address, Type),
type Expression struct {
    kind: i32,
    data: *void
}

def create_expr(kind: i32, data: *void): Expression {
    return Expression {kind: kind, data: data};
}

def empty_expr(): Expression {
    return create_expr(0, null);
}

def free_expr(e: *Expression): void {
    if is_expr_binary(e) {
        let b_expr = as_expr_binary(e);
        free_addr(&b_expr.left);
        free_addr(&b_expr.right);
    } else if is_expr_unary(e) {
        let u_expr = as_expr_unary(e);
        free_addr(&u_expr.addr);
    } else if is_expr_copy(e) {
        let c_expr = as_expr_copy(e);
        free_addr(&c_expr.addr);
    } else if is_expr_call(e) {
        let c_expr = as_expr_call(e);
        let i = 0;
        while i < c_expr.args.len {
            free_addr(call_arg_at(c_expr, i));
            i = i + 1;
        }
    } else if is_expr_struct_gep(e) {
        let gep_expr = as_expr_struct_gep(e);
        free_addr(&gep_expr.addr);
    } else if is_expr_struct_init(e) {
        let i_expr = as_expr_struct_init(e);
        let i = 0;
        while i < i_expr.args.len {
            free_addr(init_arg_at(i_expr, i));
            i = i + 1;
        }
    } else if is_expr_new(e) {
        let new_expr = as_expr_new(e);
        free_addr(&new_expr.addr);
    } else if is_expr_sizeof(e) {
        let so_expr = as_expr_sizeof(e);
        free_addr(&so_expr.addr);
    } else if is_expr_bitcast(e) {
        let bc_expr = as_expr_bitcast(e);
        free_addr(&bc_expr.addr);
    }

    if e.data != null {
        delete e.data;
    }
}

def expr_to_string(e: *Expression): string {
    if is_expr_binary(e) {
        let bin = as_expr_binary(e);

        let left = addr_to_string(&bin.left);
        let right = addr_to_string(&bin.right);
        let op = binary_kind_to_static_string(bin.kind);

        let s = std.format_str("%s%s%s", left, op, right);

        delete left;
        delete right;
        return s;
    }

    if is_expr_unary(e) {
        let unary = as_expr_unary(e);

        let addr = addr_to_string(&unary.addr);
        let op = unary_kind_to_static_string(unary.kind);

        let s = std.format_str("%s%s", op, addr);

        delete addr;
        return s;
    }

    if is_expr_copy(e) {
        let copy = as_expr_copy(e);

        let addr = addr_to_string(&copy.addr);
        let s = std.format_str("copy %s", addr);

        delete addr;
        return s;
    }

    if is_expr_call(e) {
        let call = as_expr_call(e);

        let buf = str.create_buf();

        let i = 0;
        while i < call.args.len {
            let arg = call_arg_at(call, i);
            let arg_s = addr_to_string(arg);

            str.append(&buf, arg_s);
            if i < call.args.len - 1 {
                str.append(&buf, ", ");
            }

            delete arg_s;
            i = i + 1;
        }

        let name = call.name;
        let s = std.format_str("%.*s(%s)", name.len, name.data, buf.content);

        str.free_buf(&buf);

        return s;
    }

    if is_expr_struct_gep(e) {
        let gep = as_expr_struct_gep(e);
        let addr_s = addr_to_string(&gep.addr);

        let s = std.format_str("gep(%s, %d)", addr_s, gep.idx);

        delete addr_s;
        return s;
    }

    if is_expr_struct_init(e) {
        let init = as_expr_struct_init(e);

        let buf = str.create_buf();

        let i = 0;
        while i < init.args.len {
            let arg = init_arg_at(init, i);
            let arg_s = addr_to_string(arg);

            str.append(&buf, arg_s);
            if i < init.args.len - 1 {
                str.append(&buf, ", ");
            }

            delete arg_s;
            i = i + 1;
        }

        let name = init.name;
        let s = std.format_str("%.*s{%s}", name.len, name.data, buf.content);

        str.free_buf(&buf);

        return s;
        return s;
    }

    if is_expr_new(e) {
        let n = as_expr_new(e);
        let addr_s = addr_to_string(&n.addr);

        let s = std.format_str("new %s", addr_s);

        delete addr_s;
        return s;
    }

    if is_expr_sizeof(e) {
        let so = as_expr_sizeof(e);
        let addr_s = addr_to_string(&so.addr);

        let s = std.format_str("sizeof(%s)", addr_s);

        delete addr_s;
        return s;
    }

    if is_expr_getparam(e) {
        let gp = as_expr_getparam(e);
        return std.format_str("getparam(%d)", gp.idx);
    }

    if is_expr_bitcast(e) {
        let cast = as_expr_bitcast(e);
        let addr_s = addr_to_string(&cast.addr);
        let ty_s: string = null;
        let free_ty_s = ty.to_string(cast.into, &ty_s);

        let s = std.format_str("(%s as %s)", addr_s, ty_s);

        delete addr_s;
        if free_ty_s {
            delete ty_s;
        }

        return s;
    }

    return null;
}

type InstDecl struct {
    name: RefName, // The nametable owns the actual name
    ty: *ty.Type
}

def new_inst_decl(meta: MetaData, name: RefName, ty: *ty.Type): Inst {
    return Inst {
        kind: MIR_INST_DECL,
        meta: meta,
        data: (new InstDecl {name: name, ty: ty}) as *void
    };
}

def is_inst_decl(inst: *Inst): bool {
    return inst.kind == MIR_INST_DECL;
}

def as_inst_decl(inst: *Inst): *InstDecl {
    return inst.data as *InstDecl;
}

type InstAssign struct {
    dest: Address,
    value: Expression
}

def new_inst_assign(meta: MetaData, dest: Address, value: Expression, t: *ty.Type): Inst {
    return Inst {
        kind: MIR_INST_ASSIGN,
        meta: meta,
        data: (new InstAssign { dest: dest, value: value }) as *void
    };
}

def is_inst_assign(inst: *Inst): bool {
    return inst.kind == MIR_INST_ASSIGN;
}

def as_inst_assign(inst: *Inst): *InstAssign {
    return inst.data as *InstAssign;
}

type InstJmp struct {
    target: Label
}

def new_inst_jmp(meta: MetaData, target: Label): Inst {
    return Inst {
        kind: MIR_INST_JMP,
        meta: meta,
        data: (new InstJmp {target: target}) as *void
    };
}

def is_inst_jmp(inst: *Inst): bool {
    return inst.kind == MIR_INST_JMP;
}

def as_inst_jmp(inst: *Inst): *InstJmp {
    return inst.data as *InstJmp;
}

type InstJmpIf struct {
    condition: Address,
    if_target: Label,
    else_target: Label
}

def is_inst_jmpif(inst: *Inst): bool {
    return inst.kind == MIR_INST_JMPIF;
}

def as_inst_jmpif(inst: *Inst): *InstJmpIf {
    return inst.data as *InstJmpIf;
}

type InstReturn struct {
    value: Address // MIR_ADDR_EMPTY if empty return: 'return;'
}

def is_inst_return(inst: *Inst): bool {
    return inst.kind == MIR_INST_RETURN;
}

def as_inst_return(inst: *Inst): *InstReturn {
    return inst.data as *InstReturn;
}

type InstLabel struct {
    value: Label
}

def is_inst_label(inst: *Inst): bool {
    return inst.kind == MIR_INST_LABEL;
}

def as_inst_label(inst: *Inst): *InstLabel {
    return inst.data as *InstLabel;
}

type InstDelete struct {
    addr: Address
}

def is_inst_delete(inst: *Inst): bool {
    return inst.kind == MIR_INST_DELETE;
}

def as_inst_delete(inst: *Inst): *InstDelete {
    return inst.data as *InstDelete;
}

def create_inst_nop(): Inst {
    return Inst {
        kind: MIR_INST_NOP,
        meta: create_meta(source.empty_pos()),
        data: null
    };
}

def is_inst_nop(inst: *Inst): bool {
    return inst.kind == MIR_INST_NOP;
}

// A single MIR instruction
//
// can be one of the following
// let x: i32:
//  Decl(RefName, Type),
// x = <expr>:
//  Assignment(Address, Expr),
// goto l:
//  Jmp(Label),
// if x goto l0 else goto l1:
//  JmpIf(Address, Label, Label),
// return x:
//  Return(Optional Address),
// .L0:
//  Label(Label),
// frees heap memory:
//  Delete(Address),
// No operation:
//  Nop,
type Inst struct {
    kind: i32,
    meta: MetaData,
    data: *void
}

def inst_to_string(inst: *Inst): string {
    if is_inst_decl(inst) {
        let decl = as_inst_decl(inst);
        let ty_s: string = null;
        let free_ty_s = ty.to_string(decl.ty, &ty_s);

        let s = std.format_str(
            "let %.*s: %s",
            decl.name.len,
            decl.name.data,
            ty_s
        );

        if free_ty_s {
            delete ty_s;
        }

        return s;
    }

    if is_inst_assign(inst) {
        let assign = as_inst_assign(inst);
        let a_s = addr_to_string(&assign.dest);
        let e_s = expr_to_string(&assign.value);

        let s = std.format_str("%s = %s", a_s, e_s);

        delete a_s;
        delete e_s;

        return s;
    }

    if is_inst_jmp(inst) {
        let jmp = as_inst_jmp(inst);
        let label = label_name(&jmp.target);

        // just copy the data, since this function is for debug only
        return std.strndup(label.data, label.len);
    }

    if is_inst_jmpif(inst) {
        let jmpif = as_inst_jmpif(inst);
        let if_label = label_name(&jmpif.if_target);
        let else_label = label_name(&jmpif.else_target);
        let condition = addr_to_string(&jmpif.condition);

        let s = std.format_str("jmp %s;%.*s;%.*s", condition, if_label, else_label);
        delete condition;

        return s;
    }

    if is_inst_return(inst) {
        let ret = as_inst_return(inst);
        if is_addr_empty(&ret.value) {
            return std.strdup("return");
        }

        let a_s = addr_to_string(&ret.value);
        let s = std.format_str("return %s", a_s);

        delete a_s;
        return s;
    }

    if is_inst_delete(inst) {
        let del = as_inst_delete(inst);
        let a_s = addr_to_string(&del.addr);

        let s = std.format_str("delete %s", a_s);

        delete a_s;
        return s;
    }

    if is_inst_nop(inst) {
        return std.strdup("nop");
    }

    return null;
}

def free_inst(inst: *Inst): void {
    if is_inst_assign(inst) {
        let assign = as_inst_assign(inst);
        free_addr(&assign.dest);
        free_expr(&assign.value);
    } if is_inst_jmp(inst) {
        let jmp = as_inst_jmp(inst);
        free_label(&jmp.target);
    } if is_inst_jmpif(inst) {
        let jmpif = as_inst_jmpif(inst);
        free_addr(&jmpif.condition);
        free_label(&jmpif.if_target);
        free_label(&jmpif.else_target);
    } if is_inst_return(inst) {
        let ret = as_inst_return(inst);
        free_addr(&ret.value);
    } if is_inst_delete(inst) {
        let del = as_inst_delete(inst);
        free_addr(&del.addr);
    }

    if inst.data != null {
        delete inst.data;
    }
}

type BlockMap struct {
    mappings: map.Map, // map.Map<RefName, i32>
    decls: vec.Vec,    // vec.Vec<Inst>
    blocks: vec.Vec    // vec.Vec<BasicBlock>
}

def create_block_map(func_name: RefName): BlockMap {
    let bm = BlockMap {
        mappings: map.create(),
        decls: vec.create(sizeof Inst),
        blocks: vec.create(sizeof BasicBlock)
    };

    let name = make_copied_name(func_name.len, func_name.data);
    let bb = create_bb(create_label(name));

    push_block(&bm, &bb);

    return bm;
}

def push_block(bm: *BlockMap, bb: *BasicBlock): void {
    let idx = bm.blocks.len;
    vec.push(&bm.blocks, bb as *void);

    let name = label_name(&bb.label);
    let key = map.create_key(name.len, name.data);
    map.insert(&bm.mappings, key, std.int_to_ptr(idx));
}

def free_block_map(bm: *BlockMap): void {
    map.free_m(&bm.mappings);

    let i = 0;
    while i < bm.blocks.len {
        free_bb(vec.get_ptr(&bm.blocks, i) as *BasicBlock);
        i = i + 1;
    }

    vec.free_v(&bm.blocks);

    i = 0;
    while i < bm.decls.len {
        free_inst(vec.get_ptr(&bm.decls, i) as *Inst);
        i = i + 1;
    }

    vec.free_v(&bm.decls);
}

def bm_get_bb_ptr(bm: *BlockMap, idx: i32): *BasicBlock {
    return vec.get_ptr(&bm.blocks, idx) as *BasicBlock;
}

def bm_push_instr_to_last_bb(bm: *BlockMap, inst: *Inst): void {
    let last_bb = bm_get_bb_ptr(bm, bm.blocks.len - 1);
    bb_push_instr(last_bb, inst);
}

def bm_push_instr(bm: *BlockMap, inst: *Inst): void {
    if is_inst_decl(inst) {
        vec.push(&bm.decls, inst as *void);
        return;
    }

    if is_inst_label(inst) {
        // Terminate last block with goto
        let target = clone_label(&as_inst_label(inst).value);
        let goto = new_inst_jmp(inst.meta, target);
        bm_push_instr_to_last_bb(bm, &goto);
        return;
    }

    bm_push_instr_to_last_bb(bm, inst);
}

// dump BlockMap to stdout for debug purposes
def bm_dump(bm: *BlockMap): void {
    let first_bb = vec.get_ptr(&bm.blocks, 0) as *BasicBlock;
    let name = label_name(&first_bb.label);
    io.printf("%.*s:\n", name.len, name.data);

    let i = 0;
    while i < bm.decls.len {
        let decl = vec.get_ptr(&bm.decls, i) as *Inst;
        let s = inst_to_string(decl);
        io.printf("  %s\n", s);
        delete s;
        i =  i + 1;
    }

    let iter = map.iter(&bm.mappings);
    let item = map.iter_next(&iter);
    while item != null {
        if item.key.value != name.data {
            io.printf("%.*s:\n", item.key.len, item.key.value);
        }
        let idx = std.ptr_to_int(item.value);
        let bb = bm_get_bb_ptr(bm, idx);

        i = 0;
        while i < bb_num_instr(bb) {
            let inst = bb_get_instr(bb, i);
            let s = inst_to_string(inst);
            io.printf("  %s\n", s);
            delete s;
            i = i + 1;
        }

        item = map.iter_next(&iter);
    }
}
