#include "std.h"

import "io";
import "ty";
import "nt";
import "mod";
import "mir";
import "ast";
import "map";
import "std";
import "dbg";
import "path";
import "scope";
import "ident";
import "ptrvec";

// TODO(#62): implement mir compiler

// Data which is shared between all the MirCompiler instances
type CompilationData struct {
    mods: *mod.Map,
    proj_root: path.Path,
    global_types: map.Map // map.Map<ident.Ident, *ty.Type>
}

def compile_all(data: CompilationData, types: ptrvec.Vec): void {
    // TODO(#64): the mir compilation can be done in parallel
    let i = 0;
    let n = mod.num_mods(data.mods);
    while i < n {
        let m = mod.get_mod(data.mods, i);

        let mirc = create_mirc(m, &data);
        let mir_mod = compile(&mirc);

        free_mirc(&mirc);
        mir.free_mod(&mir_mod);

        i = i + 1;
    }
}

// Compiles a single *mod.Module to a mir.Module
type MirCompiler struct {
    mod: *mod.Module,
    data: *CompilationData,
    names: nt.NameTable,
    functions: map.Map, // map.Map<mir.Name, mir.Func>
    globals: map.Map, // map.Map<mir.Name, mir.GlobalConst>
    current_func: *mir.Func
}

def create_mirc(m: *mod.Module, data: *CompilationData): MirCompiler {
    return MirCompiler {
        mod: m,
        data: data,
        names: nt.create(),
        functions: map.create(),
        globals: map.create(),
        current_func: null
    };
}

def free_mirc(c: *MirCompiler): void {
    nt.free_nt(&c.names);
}

def compile(c: *MirCompiler): mir.Module {
    let i = 0;
    let n = mod.num_stmts(c.mod);

    nt.open_scope(&c.names);

    while i < n {
        let s = mod.get_stmt_at(c.mod, i);
        compile_stmt(c, s);
        i = i + 1;
    }

    nt.close_scope(&c.names);

    return mir.create_mod(c.globals, c.functions);
}

def compile_stmt(c: *MirCompiler, s: *ast.Stmt): void {
    if ast.is_func_decl_stmt(s) {
        let decl_stmt = ast.as_func_decl_stmt(s);
        let decl = &decl_stmt.decl;

        let name = mangle_func_name(c, &decl.name, decl.func_ty);
        io.printf("name: %.*s\n", name.len, name.data);

        let mir_func = mir.create_func(decl.func_ty);

        if decl_stmt.block != null {
            let prev_func = c.current_func;

            c.current_func = &mir_func;
            compile_stmt(c, decl_stmt.block as *ast.Stmt);
            c.current_func = prev_func;
        }

        mir.free_name(&name);
        return;
    }

    if ast.is_block_stmt(s) {
        dbg.assert(c.current_func != null, "current_func was null");

        let block_stmt = ast.as_block_stmt(s);
        bind_s(c, 5, "block");

        nt.open_scope(&c.names);

        let i = 0;
        while i < block_stmt.stmts.len {
            let s = ast.stmt_at(block_stmt, i);
            compile_stmt(c, s);
            i = i + 1;
        }

        nt.close_scope(&c.names);

        return;
    }
}

def bind_s(c: *MirCompiler, len: i32, s: string): void {
    nt.bind(&c.names, mir.ref_name(len, s));
}

def mod_at(c: *MirCompiler, i: i32): *mod.Module {
    return mod.get_mod(c.data.mods, i);
}

def add_expr(c: *MirCompiler, b: *mir.InstBlock, e: *ast.Expr): mir.Address {
    if ast.is_ident_expr(e) {
        // TODO: lookup
        dbg.not_implemented();
    }

    let a = mir.create_addr_empty();
    if rvalue_expr(c, e, &a) {
        return a;
    }

    return mir.create_addr_null(null);
}

// Checks if the expression (e) is a rvalue. If it is, the out_address is filled
// with the correct mir.Address for this value
// (e.g. AddressConst for an int literal)
def rvalue_expr(c: *MirCompiler, e: *ast.Expr, out: *mir.Address): bool {
    if ast.is_int_expr(e) {
        *out = mir.create_addr_const(e.ty, e.span);
        return true;
    }

    if ast.is_float_expr(e) {
        *out = mir.create_addr_const(e.ty, e.span);
        return true;
    }

    if ast.is_null_expr(e) {
        *out = mir.create_addr_null(e.ty);
        return true;
    }

    if ast.is_string_expr(e) {
        let name = string_lit(c, e);
        *out = mir.new_address_global(name, e.ty);
        return true;
    }

    if ast.is_char_expr(e) {
        *out = mir.create_addr_const(e.ty, e.span);
        return true;
    }

    return false;
}

def string_lit(c: *MirCompiler, e: *ast.Expr): mir.Name {
    return add_global(c, mir.create_global_data(e.span, e.ty));
}

def add_global(c: *MirCompiler, data: mir.GlobalData): mir.Name {
    return mir.ref_name(0, null);
}

def mangle_func_name(c: *MirCompiler, name: *ident.Ident, t: *ty.Type): mir.Name {
    dbg.assert(t != null, "type was null");
    dbg.assert(ty.is_func(t), "type was not a function");

    let f_ty = ty.as_func(t);
    let declared_in = mod_at(c, f_ty.declared_in);

    if f_ty.is_extern {
        return mir.ref_name(ident.len(name), ident.start(name));
    }

    return mangle_name(c, name, declared_in);
}

def mangle_struct_name(c: *MirCompiler, name: *ident.Ident, t: *ty.Type): mir.Name {
    dbg.assert(t != null, "type was null");
    dbg.assert(ty.is_struct(t), "type was not a struct");

    let s_ty = ty.as_struct(t);
    let declared_in = mod_at(c, s_ty.declared_in);

    return mangle_name(c, name, declared_in);
}

def mangle_name(c: *MirCompiler, name: *ident.Ident, declared_in: *mod.Module): mir.Name {
    let name_len = 0;
    let name_data = "";
    let p = declared_in.path;

    // TODO(#72): this name mangling algorithm assumes the existence of a global
    //  file path root. This does not necessarily exist in windows

    let file_ending_len = 0;
    mod.kantan_file_ending(&file_ending_len);

    if !declared_in.is_std_lib {
        let mod_len = p.len - c.data.proj_root.len - file_ending_len;
        let mod_name = p.inner + c.data.proj_root.len;

        // +1 for '.'
        name_len = mod_len + ident.len(name) + 1;
        name_data = std.malloc(name_len + 1) as string;

        let i = 0;
        let sep = path.sys_separator();
        while i < mod_len {
            let c = *(mod_name + i);
            if c == sep {
                c = '.';
            }
            *(name_data + i) = c;
            i = i + 1;
        }
        *(name_data + mod_len) = '.';

        let dest = name_data + mod_len + 1;
        let src = ident.start(name);
        std.memcpy(dest as *void, src as *void, ident.len(name));
        *(name_data + name_len) = '\0';
    } else {
        let file_name_len = p.len - file_ending_len;
        let file_name = p.inner;

        name_len = 4 + file_name_len + 1 + ident.len(name);
        name_data = std.format_str(
            "std.%.*s.%.*s", file_name_len, file_name, ident.len(name), ident.start(name)
        );
        io.printf("%d\n", name_len);
    }

    return mir.make_owned_name(name_len, name_data);
}

def ident_to_mir_name(i: *ident.Ident): mir.Name {
    return mir.ref_name(ident.len(i), ident.start(i));
}

