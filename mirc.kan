#include "std.h"

import "io";
import "ty";
import "nt";
import "vec";
import "mod";
import "mir";
import "ast";
import "map";
import "std";
import "dbg";
import "span";
import "path";
import "scope";
import "ident";
import "source";
import "ptrvec";

// TODO(#62): implement mir compiler

// Data which is shared between all the MirCompiler instances
type CompilationData struct {
    mods: *mod.Map,
    proj_root: path.Path,
    global_types: map.Map // map.Map<ident.Ident, *ty.Type>
}

def compile_all(data: CompilationData, types: ptrvec.Vec): void {
    // TODO(#64): the mir compilation can be done in parallel
    let i = 0;
    let n = mod.num_mods(data.mods);
    while i < n {
        let m = mod.get_mod(data.mods, i);

        let mirc = create_mirc(m, &data);
        let mir_mod = compile(&mirc);

        free_mirc(&mirc);
        mir.free_mod(&mir_mod);

        i = i + 1;
    }
}

// Compiles a single *mod.Module to a mir.Module
type MirCompiler struct {
    mod: *mod.Module,
    data: *CompilationData,
    names: nt.NameTable,
    functions: map.Map, // map.Map<mir.RefName, *mir.Func>
    globals: map.Map, // map.Map<mir.RefName, *mir.GlobalConst>
    current_func: *mir.Func
}

def create_mirc(m: *mod.Module, data: *CompilationData): MirCompiler {
    return MirCompiler {
        mod: m,
        data: data,
        names: nt.create(),
        functions: map.create(),
        globals: map.create(),
        current_func: null
    };
}

def free_mirc(c: *MirCompiler): void {
    nt.free_nt(&c.names);
}

def compile(c: *MirCompiler): mir.Module {
    let i = 0;
    let n = mod.num_stmts(c.mod);

    nt.open_scope(&c.names);

    while i < n {
        let s = mod.get_stmt_at(c.mod, i);
        compile_stmt(c, s);
        i = i + 1;
    }

    nt.close_scope(&c.names);

    return mir.create_mod(c.globals, c.functions);
}

def add_function(c: *MirCompiler, f: *mir.Func): void {
    let key = map.create_key(f.name.len, f.name.data);
    map.insert(&c.functions, key, f as *void);
}

def lookup_function(c: *MirCompiler, mangled_name: mir.RefName): *mir.Func {
    let key = map.create_key(mangled_name.len, mangled_name.data);
    return map.get(&c.functions, key) as *mir.Func;
}

def get_meta(c: *MirCompiler, s: span.Span): mir.MetaData {
    let pos = source.span_to_pos(c.mod.source, s);
    return mir.create_meta(pos);
}

def lookup_or_declare_function(c: *MirCompiler, t: *ty.Type): *mir.Func {
    dbg.assert(ty.is_func(t), "non function type passed to lookup");

    // TODO(#77): this creates a lot of unnecessary malloc calls
    //  maybe cache the mangled func names
    //  i decided against saving them in a global map to make multithreading
    //  easier in the futures
    let name = mangle_func_name(c, t);
    let mir_func = lookup_function(c, mir.ref_name(name));

    if mir_func == null {
        mir_func = new mir.create_func(t, name);
        add_function(c, mir_func);
    } else {
        mir.free_name(&name);
    }

    return mir_func;
}

def compile_stmt(c: *MirCompiler, s: *ast.Stmt): void {
    if ast.is_struct_decl_stmt(s) {
    }

    if ast.is_func_decl_stmt(s) {
        let decl_stmt = ast.as_func_decl_stmt(s);
        let decl = &decl_stmt.decl;

        let mir_func = lookup_or_declare_function(c, decl.func_ty);

        if decl_stmt.block != null {
            let prev_func = c.current_func;

            c.current_func = mir_func;
            compile_stmt(c, decl_stmt.block as *ast.Stmt);
            c.current_func = prev_func;
        }

        dump_function(mir_func);
        return;
    }

    if ast.is_let_stmt(s) {
        let let_stmt = ast.as_let_stmt(s);
        let ty = let_stmt.value.ty;

        let a = mir.create_addr_empty();
        let mir_expr = mir.empty_expr();

        if address_expression(c, let_stmt.value, &a) {
            mir_expr = mir.new_copy_expr(a);
        } else {
            mir_expr = complex_expr(c, let_stmt.value, true);
        }

        let name = bind_ident(c, &let_stmt.ident);

        // TODO(#73): implement logic for global variables
        if c.current_func != null {
            let meta = get_meta(c, let_stmt.ident.span);
            push_decl(c, name, ty, meta);
        } else {
            mir.free_expr(&mir_expr);
            return;
        }

        let meta = get_meta(c, let_stmt.ident.span);
        let target = mir.make_addr_name(name, ty);
        push_assign(c, target, mir_expr, meta);

        return;
    }

    if ast.is_block_stmt(s) {
        dbg.assert(c.current_func != null, "current_func was null");

        let block_stmt = ast.as_block_stmt(s);
        bind_s(c, 5, "block");

        nt.open_scope(&c.names);

        let i = 0;
        while i < block_stmt.stmts.len {
            let s = ast.stmt_at(block_stmt, i);
            compile_stmt(c, s);
            i = i + 1;
        }

        nt.close_scope(&c.names);

        return;
    }

    if ast.is_expr_stmt(s) {
        let e = ast.as_expr_stmt(s);
        expr_instruction(c, e.expr, true);
        return;
    }

    if ast.is_delete_stmt(s) {
        let target = expr_instruction(c, ast.as_delete_stmt(s).expr, false);
        let meta = get_meta(c, s.span);
        push_instr(c, mir.new_inst_delete(target, meta));
        return;
    }

    if ast.is_if_stmt(s) {
    }

    if ast.is_while_stmt(s) {
    }

    if ast.is_return_stmt(s) {
    }
}

def push_decl(c: *MirCompiler, n: mir.RefName, ty: *ty.Type, m: mir.MetaData): void {
    push_instr(c, mir.new_inst_decl(m, n, ty));
}

def push_instr_p(c: *MirCompiler, instr: *mir.Inst): void {
    mir.func_push_instr(c.current_func, instr);
}

def push_instr(c: *MirCompiler, instr: mir.Inst): void {
    mir.func_push_instr(c.current_func, &instr);
}

def temp_addr(c: *MirCompiler, ty: *ty.Type): mir.Address {
    let name = bind_s(c, 2, "_t");
    return mir.make_addr_name(name, ty);
}

def bind_ident(c: *MirCompiler, i: *ident.Ident): mir.RefName {
    return nt.bind(&c.names, mir.make_ref_name(ident.len(i), ident.start(i)));
}

def bind_s(c: *MirCompiler, len: i32, s: string): mir.RefName {
    return nt.bind(&c.names, mir.make_ref_name(len, s));
}

def mod_at(c: *MirCompiler, i: i32): *mod.Module {
    return mod.get_mod(c.data.mods, i);
}

def push_assign(
    c: *MirCompiler,
    target: mir.Address,
    value: mir.Expression,
    m: mir.MetaData
): void {
    let assign = mir.new_inst_assign(m, target, value, target.ty);
    push_instr_p(c, &assign);
}

def push_temp_assign(
    c: *MirCompiler,
    value: mir.Expression,
    ty: *ty.Type,
    meta: mir.MetaData,
    out_name: *mir.Address // has to be freed if wanted
): void {
    let target = temp_addr(c, ty);
    let assign = mir.new_inst_assign(meta, target, value, target.ty);
    push_instr_p(c, &assign);

    if out_name != null {
        *out_name = mir.clone_addr_name(&target);
    }
}

def compile_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let a = mir.create_addr_empty();
    if address_expression(c, e, &a) {
        return mir.new_copy_expr(a);
    }

    return complex_expr(c, e, rhs);
}

def assign_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let assign = ast.as_assign_expr(e);
    let target = expr_instruction(c, assign.left, rhs);
    let value = compile_expr(c, assign.right, true);

    let meta = get_meta(c, e.span);
    push_assign(c, target, value, meta);
    return mir.new_copy_expr(target);
}

def unary_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let unary = ast.as_unary_expr(e);
    let value_addr = expr_instruction(c, unary.right, rhs);
    let meta = get_meta(c, e.span);

    if ast.unary_is_deref(unary) {
        // Expressions on the right side of an assignment have to be derefed twice
        if rhs {
            let value = mir.new_unary_expr_deref(value_addr);
            push_temp_assign(c, value, e.ty, meta, &value_addr);
        }

        return mir.new_unary_expr_deref(value_addr);
    }

    dbg.assert(rhs, "These unary types should not appear on the left side of =");

    if ast.unary_is_ref(unary) {
        let ref_name = mir.as_addr_name(&value_addr).value;
        let ref = mir.make_addr_ref(ref_name, e.ty);
        return mir.new_copy_expr(ref);
    }


    if ast.unary_is_neg_bool(unary) {

    }

    if ast.unary_is_neg_num(unary) {

    }

    return mir.empty_expr();
}

def binary_expr(c: *MirCompiler, e: *ast.Expr): mir.Expression {
    let binary = ast.as_binary_expr(e);

    let left = expr_instruction(c, binary.left, true);
    let right = expr_instruction(c, binary.right, true);

    let kind = mir_binary_kind_from_expr(binary);
    return mir.new_binary_expr(kind, left, right);
}

def call_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    // The left side may be an arbitrary expression, so we need to be careful
    // here. Example:
    // f()()
    // _t0 = f()
    // _t1 = _t0()

    let call = ast.as_call_expr(e);
    let func_addr = expr_instruction(c, call.callee, rhs);
    let varargs = ty.as_func(call.callee.ty).is_varargs;

    let i = 0;
    let n = ast.num_args(&call.args);
    let args = vec.with_cap(sizeof mir.Address, n);
    while i < n {
        let arg = ast.get_arg_at(&call.args, i);
        let arg_addr = expr_instruction(c, arg, true);
        vec.push(&args, &arg_addr as *void);
        i = i + 1;
    }

    return mir.new_call_expr(func_addr, args, varargs);
}

def complex_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    // EXPR_ACCESS
    if ast.is_access_expr(e) {
    }

    // EXPR_BINARY
    if ast.is_binary_expr(e) {
        return binary_expr(c, e);
    }

    // EXPR_ASSIGN
    if ast.is_assign_expr(e) {
        return assign_expr(c, e, rhs);
    }

    // EXPR_UNARY
    if ast.is_unary_expr(e) {
        return unary_expr(c, e, rhs);
    }

    // EXPR_NEW
    if ast.is_new_expr(e) {
    }

    // EXPR_SIZEOF
    if ast.is_sizeof_expr(e) {
    }

    // EXPR_AS
    if ast.is_as_expr(e) {
    }

    // EXPR_CALL
    if ast.is_call_expr(e) {
        return call_expr(c, e, rhs);
    }

    // EXPR_INIT
    if ast.is_init_expr(e) {
    }

    // dbg.assert_fmt(false, "expr kind %d not handled", e.tag);
    return mir.empty_expr();
}

// creates one or multiple instructions for the given expression and returns
// the address of the result
def expr_instruction(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Address {
    let a = mir.create_addr_empty();
    if address_expression(c, e, &a) {
        return a;
    }

    let mir_expr = complex_expr(c, e, rhs);
    if mir.is_expr_copy(&mir_expr) {
        a = mir.as_expr_copy(&mir_expr).addr;
        mir.free_expr(&mir_expr);
        return a;
    }

    let meta = get_meta(c, e.span);

    // the result of a void function should be assigned to an empty address
    if mir.is_expr_call(&mir_expr) {
        let f_ty = ty.as_func(mir.as_expr_call(&mir_expr).callee.ty);
        if ty.is_void(f_ty.ret) {
            // assign result to empty address (a is always empty here)
            push_assign(c, a, mir_expr, meta);
            return a;
        }
    }

    push_temp_assign(c, mir_expr, e.ty, meta, &a);
    push_decl(c, mir.as_addr_name(&a).value, e.ty, meta);
    return a;
}

// checks if the supplied expression is an "address expression", so either
// a name, or an rvalue. If it is, returns true and fills the out parameter
// with the correct address
def address_expression(c: *MirCompiler, e: *ast.Expr, out: *mir.Address): bool {
    if ty.is_func(e.ty) {
        // currently all functions are static, this has to change, when we introduce
        // function pointers

        let mir_func = lookup_or_declare_function(c, e.ty);
        *out = mir.make_addr_name(mir.ref_name(mir_func.name), e.ty);
        return true;
    }

    if ast.is_ident_expr(e) {
        let ident = &ast.as_ident_expr(e).ident;
        let name = name_from_ident(ident);
        let mangled = mir.empty_name();
        if nt.lookup(&c.names, name, &mangled) {
            *out = mir.make_addr_name(mangled, e.ty);
            return true;
        }

        if c.current_func != null {
            let f = ty.as_func(c.current_func.ty);
            let p_idx = ty.find_param_idx(f, ident);
            if p_idx >= 0 {
                *out = mir.make_addr_arg(p_idx, e.ty);
                return true;
            }
        }

        dbg.assert_fmt(false, "undefined: %.*s", name.len, name.data);
    }

    return rvalue_expr(c, e, out);
}

// Checks if the expression (e) is a rvalue. If it is, the out_address is filled
// with the correct mir.Address for this value
// (e.g. AddressConst for an int literal)
def rvalue_expr(c: *MirCompiler, e: *ast.Expr, out: *mir.Address): bool {
    if ast.is_int_expr(e) {
        *out = mir.make_addr_const(e.ty, e.span);
        return true;
    }

    if ast.is_float_expr(e) {
        *out = mir.make_addr_const(e.ty, e.span);
        return true;
    }

    if ast.is_null_expr(e) {
        *out = mir.create_addr_null(e.ty);
        return true;
    }

    if ast.is_string_expr(e) {
        let name = string_lit(c, e);
        *out = mir.make_addr_global(name, e.ty);
        return true;
    }

    if ast.is_char_expr(e) {
        *out = mir.make_addr_const(e.ty, e.span);
        return true;
    }

    return false;
}

def string_lit(c: *MirCompiler, e: *ast.Expr): mir.RefName {
    return add_global(c, get_meta(c, e.span), e.ty);
}

def add_global(c: *MirCompiler, meta: mir.MetaData, ty: *ty.Type): mir.RefName {
    let idx = c.globals.len;
    let s_len = 0;
    let s = std.l_format_str(&s_len, "_g%d", idx);
    let name = s_mangle_name(c, s_len, s, c.mod);

    let key = map.create_key(name.len, name.data);
    map.insert(&c.globals, key, (new mir.create_const(name, meta, ty)) as *void);

    delete s;
    return mir.make_ref_name(name.len, name.data);
}

def mangle_func_name(c: *MirCompiler, t: *ty.Type): mir.OwnedName {
    dbg.assert(t != null, "type was null");
    dbg.assert(ty.is_func(t), "type was not a function");

    let f_ty = ty.as_func(t);
    let name = &f_ty.name;
    let declared_in = mod_at(c, f_ty.declared_in);

    if f_ty.is_extern {
        // function names must be owned, so just copy data here
        // there aren't many extern functions anyway
        let len = ident.len(name);
        return mir.make_copied_name(len, ident.start(name));
    }

    return mangle_name(c, name, declared_in);
}

def mangle_struct_name(c: *MirCompiler, name: *ident.Ident, t: *ty.Type): mir.OwnedName {
    dbg.assert(t != null, "type was null");
    dbg.assert(ty.is_struct(t), "type was not a struct");

    let s_ty = ty.as_struct(t);
    let declared_in = mod_at(c, s_ty.declared_in);

    return mangle_name(c, name, declared_in);
}

def mangle_name(c: *MirCompiler, name: *ident.Ident, declared_in: *mod.Module): mir.OwnedName {
    return s_mangle_name(c, ident.len(name), ident.start(name), declared_in);
}

def s_mangle_name(c: *MirCompiler, len: i32, s: string, declared_in: *mod.Module): mir.OwnedName {
    let name_len = 0;
    let name_data = "";
    let p = mod.get_path(declared_in);

    // TODO(#72): this name mangling algorithm assumes the existence of a global
    //  file path root. This does not necessarily exist in windows

    let file_ending_len = 0;
    mod.kantan_file_ending(&file_ending_len);

    if !mod.is_std_lib(declared_in) {
        let mod_len = p.len - c.data.proj_root.len - file_ending_len;
        let mod_name = p.inner + c.data.proj_root.len;

        // +1 for '.'
        name_len = mod_len + len + 1;
        name_data = std.malloc(name_len + 1) as string;

        let i = 0;
        let sep = path.sys_separator();
        while i < mod_len {
            let c = *(mod_name + i);
            if c == sep {
                c = '.';
            }
            *(name_data + i) = c;
            i = i + 1;
        }
        *(name_data + mod_len) = '.';

        let dest = name_data + mod_len + 1;
        std.memcpy(dest as *void, s as *void, len);
        *(name_data + name_len) = '\0';
    } else {
        let file_name_len = p.len - file_ending_len;
        let file_name = p.inner;

        name_len = 4 + file_name_len + 1 + len;
        name_data = std.format_str(
            "std.%.*s.%.*s", file_name_len, file_name, len, s
        );
    }

    return mir.make_owned_name(name_len, name_data);
}

def name_from_ident(i: *ident.Ident): mir.RefName {
    return mir.make_ref_name(ident.len(i), ident.start(i));
}

def dump_function(f: *mir.Func): void {
    mir.bm_dump(&f.blocks);
}

#include "mir_types.h"
#include "expr_types.h"

def mir_binary_kind_from_expr(binary: *ast.BinaryExpr): i32 {
    let k = binary.kind;
    let left = binary.left;
    let right = binary.right;

    // the binary kinds for ast and mir only differ for the scalar addition
    // and subtraction...
    if k == BINARY_ADD {
        // the following combinations are possible:
        // left | right
        //  num |  num
        //  int |  ptr
        //  ptr |  int
        if ty.is_num(left.ty) && ty.is_num(right.ty) {
            return MIR_BIN_ADD;
        }

        return MIR_BIN_ADD_SCALAR;
    } else if k == BINARY_SUB {
        // the following combinations are possible:
        // left | right
        //  num |  num
        //  int |  ptr
        //  ptr |  int
        //  ptr |  ptr   <- this is not allowed for addtion

        if ty.is_num(left.ty) && ty.is_num(right.ty) {
            return MIR_BIN_SUB;
        }

        if ty.is_ptr_type(left.ty) && ty.is_ptr_type(right.ty) {
            return MIR_BIN_SUB;
        }

        return MIR_BIN_SUB_SCALAR;
    }

    // ...everything else is identical
    return k;
}
