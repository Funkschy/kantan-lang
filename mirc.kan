import "ty";
import "nt";
import "vec";
import "mod";
import "mir";
import "ast";
import "map";
import "std";
import "dbg";
import "span";
import "name";
import "path";
import "scope";
import "ident";
import "scope";
import "config";
import "source";

// Data which is shared between all the MirCompiler instances
type CompilationData struct {
    config: *config.Config,
    mods: *mod.Map,
    proj_root: path.Path,
    global_types: scope.Scope
}

type LoopContext struct {
    current_loop: *ast.WhileStmt,
    current_condition_label: *mir.Label, // label to jump to, in case of continue
    current_break_label: *mir.Label // label to jump to, in case of break
}

def (ctx: *LoopContext) swap_loop(new_loop: *ast.WhileStmt): *ast.WhileStmt {
    let temp = ctx.current_loop;
    ctx.current_loop = new_loop;
    return temp;
}

def (ctx: *LoopContext) swap_condition(new_condition: *mir.Label): *mir.Label {
    let temp = ctx.current_condition_label;
    ctx.current_condition_label = new_condition;
    return temp;
}

def (ctx: *LoopContext) swap_break(new_break: *mir.Label): *mir.Label {
    let temp = ctx.current_break_label;
    ctx.current_break_label = new_break;
    return temp;
}

type CompilerState enum {
    Normal, Defer
}

// Compiles a single *mod.Module to a mir.Module
// TODO: make single context like in tychk
type MirCompiler struct {
    state: CompilerState,
    label_count: usize,
    current_scope: isize,
    mod: *mod.Module,
    data: *CompilationData,
    names: nt.NameTable,
    functions: map.Map, // map.Map<name.Ref, *mir.Func>
    user_defined_types: map.Map, // map.Map<name.Ref, *mir.UserDefinedType>
    globals: map.Map, // map.Map<name.Ref, *mir.GlobalVar>
    global_names: map.Map, // map.Map<ident.Ident, *mir.GlobalVar>
    current_func: *mir.Func,
    loop_context: LoopContext,
    scopes: mir.Scopes
}

def create_mirc(m: *mod.Module, data: *CompilationData): MirCompiler {
    return MirCompiler {
        state: CompilerState.Normal,
        label_count: 0,
        current_scope: -1,
        mod: m,
        data: data,
        names: nt.create(),
        functions: map.create(),
        user_defined_types: map.create(),
        globals: map.create(),
        global_names: map.create(),
        current_func: null,
        loop_context: LoopContext {
            current_loop: null,
            current_condition_label: null,
            current_break_label: null
        },
        scopes: mir.create_scopes()
    };
}

def free_compiler(c: *MirCompiler): void {
    nt.free_nt(&c.names);
    map.free_m(&c.global_names);
}

def compile(c: *MirCompiler): mir.Module {
    let n = mod.num_stmts(c.mod);

    open_block_scope(c);

    for let i: usize = 0; i < n; i += 1 {
        let s = mod.get_stmt_at(c.mod, i);
        compile_stmt(c, s);
    }

    close_scope(c);

    // TODO: theses things should probably be a struct
    return mir.create_mod(c.globals, c.functions, c.user_defined_types, c.scopes, c.mod);
}

def add_function(c: *MirCompiler, f: *mir.Func): void {
    let key = map.create_key(f.name.len, f.name.data);
    map.insert(&c.functions, key, f as *void);
}

def add_user_defined_type(c: *MirCompiler, t: *mir.UserDefinedType): void {
    let key = map.create_key(t.name.len, t.name.data);
    map.insert(&c.user_defined_types, key, t as *void);
}

def lookup_user_defined_type(c: *MirCompiler, mangled_name: name.Ref): *mir.UserDefinedType {
    let key = map.create_key(mangled_name.len, mangled_name.data);
    return map.get(&c.user_defined_types, key) as *mir.UserDefinedType;
}

def lookup_function(c: *MirCompiler, mangled_name: name.Ref): *mir.Func {
    let key = map.create_key(mangled_name.len, mangled_name.data);
    return map.get(&c.functions, key) as *mir.Func;
}

def get_meta(c: *MirCompiler, s: span.Span): mir.MetaData {
    return get_meta_mod(c, s, c.mod);
}

def get_meta_mod(c: *MirCompiler, s: span.Span, mod: *mod.Module): mir.MetaData {
    let pos = mod.source.span_to_pos(s);
    return mir.create_meta(pos, scope_at(c, c.current_scope));
}

def scope_at(c: *MirCompiler, id: isize): mir.Scope {
    let s = c.scopes.with_id(id);
    dbg.assert_fmt(s != null, "no scope at %d", id);
    return *s;
}

// open_block_scope opens a real semantic scope (so in our case a {} block statement)
def open_block_scope(c: *MirCompiler) {
    open_scope(c, mir.ScopeKind.Block);
}

def open_loop_scope(c: *MirCompiler) {
    open_scope(c, mir.ScopeKind.Loop);
}

def open_func_scope(c: *MirCompiler) {
    open_scope(c, mir.ScopeKind.Function);
}

def open_scope(c: *MirCompiler, kind: mir.ScopeKind) {
    nt.open_scope(&c.names);
    let s = mir.scope(kind)
        .with_id(c.scopes.count() as isize)
        .with_parent(c.current_scope);

    c.current_scope = s.id;
    c.scopes.open(s);
}

// open_var_scope opens a local variable scope
// each variable declaration opens an implicit scope, since we don't want the debugger
// to display variables before they are initialized
def open_var_scope(c: *MirCompiler) {
    let current = scope_at(c, c.current_scope);
    let s = mir.scope(mir.ScopeKind.Variable)
        .with_id(c.scopes.count() as isize)
        .with_parent(c.current_scope)
        .with_num_decls(current.num_decls + 1);

    c.current_scope = s.id;
    c.scopes.open(s);
}

def close_scope(c: *MirCompiler) {
    nt.close_scope(&c.names);

    let current = scope_at(c, c.current_scope);
    c.push_defered_instructions(current);

    while current.num_decls > 0 {
        current = scope_at(c, current.parent);
        c.push_defered_instructions(current);
    }

    c.current_scope = current.parent;
}

def lookup_global_type(c: *MirCompiler, len: usize, name: string): *ty.Type {
    return c.data.global_types.get(len, name).sym.ty;
}

def lookup_or_declare_type(c: *MirCompiler, t: *ty.Type): *mir.UserDefinedType {
    dbg.assert(ty.is_user_defined(t), "non user defined type passed to lookup");

    let defined = ty.get_user_defined(t);
    let mangled_name = name.ref(defined.mangled_name);
    let mir_type = lookup_user_defined_type(c, mangled_name);

    if mir_type == null {
        let is_extern = defined.declared_in != c.mod;

        // we may override this, in compile_stmt, if the type was used, before
        // it was declared
        let meta = get_meta_mod(c, defined.original_name.span, defined.declared_in);
        mir_type = new mir.create_user_defined_type(t, mangled_name, meta, is_extern);
        add_user_defined_type(c, mir_type);

        if ty.is_struct(t) {
            let s_ty = ty.as_struct(t);
            for let i: u32 = 0; i < s_ty.num_fields(); i += 1 {
                declare_type(c, s_ty.field_at(i).ty);
            }
        } else if ty.is_union(t) {
            let u_ty = ty.as_union(t);
            for let i: u32 = 0; i < u_ty.num_fields(); i += 1 {
                declare_type(c, u_ty.field_at(i).ty);
            }
        }
    }

    return mir_type;
}

def lookup_or_declare_function(c: *MirCompiler, t: *ty.Type): *mir.Func {
    dbg.assert(ty.is_signature(t), "non function signature type passed to lookup");

    let sig = ty.as_signature(t);
    let f_ty = ty.as_func(t);
    ty.patch_receiver_into_params(f_ty);

    let mangled_name = name.ref(sig.mangled_name);
    let mir_func = lookup_function(c, mangled_name);

    if mir_func == null {
        let is_extern = sig.declared_in != c.mod || f_ty.is_extern;
        let is_main = std.strcmp(sig.mangled_name.data, "main") == 0;

        // "patch" main return type to be i32
        if is_main {
            f_ty.ret = lookup_global_type(c, 3, "i32");
        }

        // we may override this, in compile_stmt, if the function was called, before
        // it was declared
        let meta = get_meta_mod(c, sig.name.span, sig.declared_in);
        mir_func = new mir.create_func(t, mangled_name, meta, is_extern);
        add_function(c, mir_func);
    }

    return mir_func;
}

// everything, that uses an explicit type identifier (tyid.Type), needs to be declared,
// since the type could be from another module
def declare_type(c: *MirCompiler, t: *ty.Type) {
    if ty.is_ptr(t) && ty.is_user_defined(ty.as_ptr(t).inner) {
        lookup_or_declare_type(c, ty.as_ptr(t).inner);
    }

    // the order here is important, since lookup_or_declare_type does an
    // explicit check for is_struct/is_union
    if ty.is_user_defined(t) {
        lookup_or_declare_type(c, t);
    }

    if ty.is_ptr(t) && ty.is_func(ty.as_ptr(t).inner) {
        let f_ty = ty.as_func(ty.as_ptr(t).inner);
        declare_type(c, f_ty.ret);

        // Declare arguments
        for let i: u32= 0; i < f_ty.num_params(); i = i + 1 {
            let p = f_ty.param_at(i);
            declare_type(c, p.ty);
        }
    }
}

def compile_stmt(c: *MirCompiler, s: *ast.Stmt) {
    // TODO: remove duplicate code
    if ast.is_struct_decl_stmt(s) {
        let decl_stmt = ast.as_struct_decl_stmt(s);
        let decl = &decl_stmt.decl;

        // override the meta information, since it could be wrong, if the struct
        // was used before it was declared
        let mir_struct = lookup_or_declare_type(c, decl.struct_ty);
        let meta = get_meta(c, decl.name.span);
        mir_struct.meta = meta;

        return;
    }

    if ast.is_enum_decl_stmt(s) {
        let decl_stmt = ast.as_enum_decl_stmt(s);
        let decl = &decl_stmt.decl;

        // override the meta information, since it could be wrong, if the enum
        // was used before it was declared
        let mir_enum = lookup_or_declare_type(c, decl.enum_ty);
        let meta = get_meta(c, decl.name.span);
        mir_enum.meta = meta;

        return;
    }

    if ast.is_union_decl_stmt(s) {
        let decl_stmt = ast.as_union_decl_stmt(s);
        let decl = &decl_stmt.decl;

        // override the meta information, since it could be wrong, if the union
        // was used before it was declared
        let mir_union = lookup_or_declare_type(c, decl.union_ty);
        let meta = get_meta(c, decl.name.span);
        mir_union.meta = meta;

        return;
    }

    if ast.is_func_decl_stmt(s) {
        let decl_stmt = ast.as_func_decl_stmt(s);
        let decl = &decl_stmt.decl;

        open_func_scope(c);
        defer close_scope(c);

        if decl.is_delegate() {
            let f_ty = ty.as_func(decl.signature);
            declare_type(c, f_ty.ret);

            // Declare arguments
            for let i: u32= 0; i < f_ty.num_params(); i = i + 1 {
                let p = f_ty.param_at(i);
                declare_type(c, p.ty);
            }

            return;
        }

        let mir_func = lookup_or_declare_function(c, decl.signature);
        // override the meta information, since it could be wrong, if the function
        // was called before it was declared
        let meta = get_meta(c, decl.name.span);
        mir_func.meta = meta;

        if decl_stmt.block == null {
            return;
        }

        let prev_func = c.current_func;

        c.current_func = mir_func;

        let f_ty = ty.as_func(decl.signature);
        declare_type(c, f_ty.ret);

        ty.patch_receiver_into_params(f_ty);

        // Declare arguments
        for let i: u32= 0; i < f_ty.num_params(); i = i + 1 {
            let p = f_ty.param_at(i);
            let meta = get_meta(c, p.name.span);

            let name = bind_ident(c, &p.name);
            push_decl(c, name, p.ty, meta);

            declare_type(c, p.ty);

            let value = mir.new_expr_copy(mir.make_addr_arg(i, p.ty));
            let meta = get_meta(c, p.name.span);
            let target = mir.make_addr_name(name, p.ty);
            push_assign_param(c, target, value, meta, i);
        }

        // compile function code
        compile_stmt(c, decl_stmt.block as *ast.Stmt);
        let last_bb = mir.bm_last_bb_ptr(&mir_func.blocks);
        if mir.is_inst_nop(&last_bb.terminator) {
            open_block_scope(c);
            let is_main = std.strcmp(mir_func.name.data, "main") == 0;
            dbg.assert(
                is_main || ty.is_void(mir.func_ret_ty(mir_func)),
                "nop terminator in non void function"
            );

            let block_end = decl_stmt.s.span.end;
            let meta = get_meta(c, span.create(block_end, block_end));

            if is_main {
                let ret_lit = "0";
                let ret_val = mir.make_addr_const_strings(
                    mir.func_ret_ty(mir_func), ret_lit, ret_lit + 1
                );
                last_bb.terminator = mir.new_inst_return_value(meta, ret_val);
            } else {
                last_bb.terminator = mir.new_inst_return(meta);
            }
            close_scope(c);
        }

        c.current_func = prev_func;

        return;
    }

    if ast.is_let_stmt(s) {
        let let_stmt = ast.as_let_stmt(s);
        let value_ty = let_stmt.value.ty;
        declare_type(c, value_ty);

        // TODO(#73): implement logic for global variables
        // global variable
        if c.current_func == null {
            c.global_variable(let_stmt.ident, let_stmt.value);
            return;
        }

        let a = mir.create_addr_empty();
        let mir_expr = mir.empty_expr();

        if address_expression(c, let_stmt.value, &a) {
            mir_expr = mir.new_expr_copy(a);
        } else {
            mir_expr = complex_expr(c, let_stmt.value, true);
        }

        let name = bind_ident(c, &let_stmt.ident);
        let meta = get_meta(c, let_stmt.ident.span);

        push_decl(c, name, value_ty, meta);
        let target = mir.make_addr_name(name, value_ty);

        if ty.is_struct(value_ty) || ty.is_union(value_ty) {
            // structs must be zero initialized
            // TODO: this should use usize
            let i64_ty = lookup_global_type(c, 3, "i64");
            let i8_ty = lookup_global_type(c, 2, "i8");

            let storage = mir.make_addr_ref(name, value_ty);
            let value = mir.make_addr_const_value(i8_ty, 0);
            let width = mir.make_addr_const_value(i64_ty, value_ty.width as i64);

            let args = vec.with_cap(sizeof mir.Address, 3);
            args.push(&storage as *void);
            args.push(&value as *void);
            args.push(&width as *void);

            let memset = mir.new_intrinsic_call(mir.IntrinsicFunction.MemSet, args, false);
            push_assign(c, mir.create_addr_empty(), memset, meta);
        }

        push_assign_decl(c, target, mir_expr, meta, let_stmt.ident);

        return;
    }

    if ast.is_block_stmt(s) {
        dbg.assert(c.current_func != null, "current_func was null");

        let block_stmt = ast.as_block_stmt(s);

        open_block_scope(c);

        for let i: usize = 0; i < block_stmt.stmts.len; i += 1 {
            let s = ast.stmt_at(block_stmt, i);
            compile_stmt(c, s);
        }

        close_scope(c);

        return;
    }

    if ast.is_expr_stmt(s) {
        let e = ast.as_expr_stmt(s);
        // this has to be true, so that we deref pointers twice
        // otherwise this will cause the llvm module to be broken
        expr_instruction(c, e.expr, true);
        return;
    }

    if ast.is_delete_stmt(s) {
        let target = expr_instruction(c, ast.as_delete_stmt(s).expr, false);
        let meta = get_meta(c, s.span);
        push_instr(c, mir.new_inst_delete(meta, target));
        return;
    }

    if ast.is_if_stmt(s) {
        let end_label = label(c);
        push_if_stmt(c, s, &end_label);
        // TODO(#89): wrong meta for if-stmt-endlabel
        let end_meta = get_meta(c, ast.as_if_stmt(s).block.s.span);
        push_instr(c, mir.new_inst_label(end_meta, end_label));
        return;
    }

    if ast.is_while_stmt(s) {
        let end_label = label(c);
        let old_end_label = c.loop_context.swap_break(&end_label);

        open_loop_scope(c);

        push_while_stmt(c, s, &end_label);
        // TODO(#91): wrong meta for while-stmt-endlabel
        let end_meta = get_meta(c, ast.as_while_stmt(s).block.s.span);
        push_instr(c, mir.new_inst_label(end_meta, end_label));

        close_scope(c);

        c.loop_context.swap_break(old_end_label);
        return;
    }

    if ast.is_continue_stmt(s) {
        let loop = c.loop_context.current_loop;
        dbg.assert(loop != null, "continue outside of loop");

        c.push_defered_until_kind(mir.ScopeKind.Loop);

        if loop.end_block != null {
            compile_stmt(c, loop.end_block as *ast.Stmt);
        }

        let cloned = mir.clone_label(c.loop_context.current_condition_label);
        let meta = get_meta(c, s.span);
        let end_jmp = mir.new_inst_jmp(meta, cloned);
        push_instr(c, end_jmp);

        let after_continue_label = label(c);
        push_instr(c, mir.new_inst_label(meta, after_continue_label));

        return;
    }

    if ast.is_break_stmt(s) {
        dbg.assert(c.loop_context.current_break_label != null, "current_break_label was null");

        c.push_defered_until_kind(mir.ScopeKind.Loop);

        let cloned = mir.clone_label(c.loop_context.current_break_label);
        let end_jmp = mir.new_inst_jmp(get_meta(c, s.span), cloned);
        push_instr(c, end_jmp);
        return;
    }

    if ast.is_defer_stmt(s) {
        let defer_stmt = ast.as_defer_stmt(s);

        let old_state = c.state;
        c.state = CompilerState.Defer;
        compile_stmt(c, defer_stmt.stmt);
        c.state = old_state;

        return;
    }

    if ast.is_return_stmt(s) {
        let ret = ast.as_return_stmt(s);
        let meta = get_meta(c, s.span);

        c.push_defered_until_kind(mir.ScopeKind.Function);

        if ret.expr == null {
            // we actually allow the main function to be declared as
            // main(): void, which leads to undefined return codes, so we need
            // to replace every return inside the main function with return 0;
            let is_main = std.strcmp(c.current_func.name.data, "main") == 0;
            if is_main {
                let ret_ty = ty.as_func(c.current_func.ty).ret;
                let ret_lit = "0";
                let ret_val = mir.make_addr_const_strings(
                    ret_ty, ret_lit, ret_lit + 1
                );
                push_instr(c, mir.new_inst_return_value(meta, ret_val));
                return;
            }

            push_instr(c, mir.new_inst_return(meta));
            return;
        }

        let value = expr_instruction(c, ret.expr, true);
        push_instr(c, mir.new_inst_return_value(meta, value));
        return;
    }
}

def (c: *MirCompiler) push_defered_instructions(scope: mir.Scope) {
    let defered = c.scopes.defered_for(scope.id);
    let len = defered.len();
    for let i = len - 1; i as isize >= 0; i -= 1 {
        let instr = defered.get(i);
        push_instr_p(c, instr);
    }
}

def (c: *MirCompiler) push_defered_until_kind(kind: mir.ScopeKind) {
    let scope = scope_at(c, c.current_scope);
    // don't defer into variables scopes. This will lead to duplicated statements
    while scope.kind == mir.ScopeKind.Variable {
        scope = scope_at(c, scope.parent);
    }

    c.push_defered_instructions(scope);
    // return/break/continue end the scope prematurely. If we didn't clear this,
    // the instruction would also be emitted for the end of the block and therefore
    // be duplicated
    c.scopes.clear_defered_for(scope.id);

    while scope.kind != kind {
        scope = scope_at(c, scope.parent);
        c.push_defered_instructions(scope);
    }
}

def push_decl(c: *MirCompiler, n: name.Ref, ty: *ty.Type, m: mir.MetaData) {
    push_instr(c, mir.new_inst_decl(m, n, ty));
}

def push_instr(c: *MirCompiler, instr: mir.Inst) {
    push_instr_p(c, &instr);
}

def push_instr_p(c: *MirCompiler, instr: *mir.Inst) {
    if c.state == CompilerState.Defer {
        c.scopes.push_defer(c.current_scope, instr);
        return;
    }

    instr.push_count += 1;
    mir.func_push_instr(c.current_func, instr);
}

def push_assign(
    c: *MirCompiler,
    target: mir.Address,
    value: mir.Expression,
    m: mir.MetaData
): void {
    let assign = mir.new_inst_assign(m, target, value, target.ty);
    push_instr_p(c, &assign);
}

def push_assign_decl(
    c: *MirCompiler,
    target: mir.Address,
    value: mir.Expression,
    m: mir.MetaData,
    original_ident: ident.Ident
): void {
    open_var_scope(c);
    let scope = scope_at(c, c.current_scope);
    let assign = mir.new_inst_assign_decl(m, target, value, target.ty, scope, original_ident);
    push_instr_p(c, &assign);
}

def push_assign_param(
    c: *MirCompiler,
    target: mir.Address,
    value: mir.Expression,
    m: mir.MetaData,
    param_idx: u32
): void {
    let assign = mir.new_inst_assign_param(m, target, value, target.ty, param_idx as isize);
    push_instr_p(c, &assign);
}

def push_temp_assign(
    c: *MirCompiler,
    value: mir.Expression,
    ty: *ty.Type,
    meta: mir.MetaData,
    out_name: *mir.Address // has to be freed if wanted
): void {
    let target = temp_addr(c, ty);
    let assign = mir.new_inst_assign(meta, target, value, target.ty);
    push_instr_p(c, &assign);

    if out_name != null {
        *out_name = mir.clone_addr_name(&target);
    }
}

def push_if_stmt(c: *MirCompiler, s: *ast.Stmt, end_label: *mir.Label): void {
    let if_stmt = ast.as_if_stmt(s);
    let condition = expr_instruction(c, if_stmt.condition, true);
    let has_else = if_stmt.else_stmt != null;
    let has_else_if = false;
    if has_else {
        has_else_if = ast.is_if_stmt(if_stmt.else_stmt);
    }

    let else_label = mir.create_label(name.make_owned(0, null));
    if has_else {
        else_label = label(c);
    } else {
        else_label = mir.clone_label(end_label);
    }

    let then_label = label(c);
    let cond_jmp = mir.new_inst_jmpif(
        get_meta(c, s.span),
        condition,
        mir.clone_label(&then_label),
        mir.clone_label(&else_label)
    );
    push_instr(c, cond_jmp);

    let then_meta = get_meta(c, if_stmt.block.s.span);
    push_instr(c, mir.new_inst_label(then_meta, then_label));

    compile_stmt(c, if_stmt.block as *ast.Stmt);
    let end_jmp = mir.new_inst_jmp(get_meta(c, s.span), mir.clone_label(end_label));
    push_instr(c, end_jmp);

    if has_else {
        let else_meta = get_meta(c, if_stmt.else_stmt.span);
        push_instr(c, mir.new_inst_label(else_meta, else_label));

        if has_else_if {
            push_if_stmt(c, if_stmt.else_stmt, end_label);
        } else {
            compile_stmt(c, if_stmt.else_stmt);
        }
    } else {
        mir.free_label(&else_label);
    }
}

def push_while_stmt(c: *MirCompiler, s: *ast.Stmt, end_label: *mir.Label) {
    let while_stmt = ast.as_while_stmt(s);

    let condition_label = label(c);

    let old_condition_label = c.loop_context.swap_condition(&condition_label);
    let old_loop = c.loop_context.swap_loop(while_stmt);

    let condition_meta = get_meta(c, while_stmt.condition.span);
    let condition_label_clone = mir.clone_label(&condition_label);
    push_instr(c, mir.new_inst_label(condition_meta, condition_label_clone));

    let condition = expr_instruction(c, while_stmt.condition, true);

    let then_label = label(c);
    let cond_jmp = mir.new_inst_jmpif(
        get_meta(c, s.span),
        condition,
        mir.clone_label(&then_label),
        mir.clone_label(end_label)
    );
    push_instr(c, cond_jmp);

    let then_meta = get_meta(c, while_stmt.block.s.span);
    push_instr(c, mir.new_inst_label(then_meta, then_label));

    compile_stmt(c, while_stmt.block as *ast.Stmt);
    if while_stmt.end_block != null {
        compile_stmt(c, while_stmt.end_block as *ast.Stmt);
    }

    push_instr(c, mir.new_inst_jmp(condition_meta, condition_label));

    let end_jmp = mir.new_inst_jmp(get_meta(c, s.span), mir.clone_label(end_label));
    push_instr(c, end_jmp);

    c.loop_context.swap_loop(old_loop);
    c.loop_context.swap_condition(old_condition_label);
}

def temp_addr(c: *MirCompiler, ty: *ty.Type): mir.Address {
    let name = bind_s(c, 2, "_t");
    return mir.make_addr_name(name, ty);
}

def bind_ident(c: *MirCompiler, i: *ident.Ident): name.Ref {
    return nt.bind(&c.names, name.make_ref(ident.len(i), ident.start(i)));
}

def bind_s(c: *MirCompiler, len: usize, s: string): name.Ref {
    return nt.bind(&c.names, name.make_ref(len, s));
}

def (c: *MirCompiler) bind(name: name.Ref): name.Ref {
    return nt.bind(&c.names, name);
}

def mod_at(c: *MirCompiler, i: u32): *mod.Module {
    return mod.get_mod(c.data.mods, i);
}

def compile_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let a = mir.create_addr_empty();
    if address_expression(c, e, &a) {
        return mir.new_expr_copy(a);
    }

    return complex_expr(c, e, rhs);
}

def assign_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let assign = ast.as_assign_expr(e);
    let value = compile_expr(c, assign.right, true);
    let target = expr_instruction_decl(c, assign.left, false, false);

    let meta = get_meta(c, e.span);
    push_assign(c, target, value, meta);
    return mir.new_expr_copy(target);
}

def unary_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let unary = ast.as_unary_expr(e);
    let value_addr = expr_instruction(c, unary.right, rhs);
    let meta = get_meta(c, e.span);

    if unary.kind == ast.UnaryKind.Deref {
        // Expressions on the right side of an assignment have to be derefed twice
        // since a deref is just load instruction
        if rhs {
            let value = mir.new_expr_unary_deref(value_addr);
            push_temp_assign(c, value, e.ty, meta, &value_addr);
        }

        return mir.new_expr_unary_deref(value_addr);
    }

    if unary.kind == ast.UnaryKind.Ref {
        let ref_name = mir.as_addr_name(&value_addr).value;
        let ref = mir.make_addr_ref(ref_name, e.ty);
        return mir.new_expr_copy(ref);
    }

    if unary.kind == ast.UnaryKind.NegBool || unary.kind == ast.UnaryKind.BitNot {
        return mir.new_expr_unary_not(value_addr);
    }

    if unary.kind == ast.UnaryKind.NegNum {
        return mir.new_expr_unary_num_neg(value_addr);
    }

    return mir.empty_expr();
}

def binary_expr(c: *MirCompiler, e: *ast.Expr): mir.Expression {
    let binary = ast.as_binary_expr(e);
    let short_circuit = 0;
    let kind = mir_binary_kind_from_expr(binary, &short_circuit);

    if short_circuit != 0 {
        let result = temp_addr(c, e.ty);
        push_decl(c, mir.as_addr_name(&result).value, e.ty, get_meta(c, e.span));

        let end_label = label(c);
        let else_label = label(c);

        let left = expr_instruction(c, binary.left, true);
        let left_meta = get_meta(c, binary.left.span);
        push_assign(c, result, mir.new_expr_copy(left), get_meta(c, binary.left.span));

        let then_target = mir.clone_label(&end_label);
        let else_target = mir.clone_label(&else_label);
        // for && we need to short circuit, if the left expr is false
        if short_circuit == 1 {
            let temp = else_target;
            else_target = then_target;
            then_target = temp;
        }

        let cond_jmp = mir.new_inst_jmpif(
            left_meta,
            left,
            then_target,
            else_target
        );
        push_instr(c, cond_jmp);

        let else_meta = get_meta(c, binary.right.span);
        push_instr(c, mir.new_inst_label(else_meta, else_label));
        let right = expr_instruction(c, binary.right, true);
        push_assign(c, result, mir.new_expr_copy(right), get_meta(c, binary.right.span));

        let end_meta = get_meta(c, e.span);
        push_instr(c, mir.new_inst_label(end_meta, end_label));
        return mir.new_expr_copy(result);
    }

    let left = expr_instruction(c, binary.left, true);
    let right = expr_instruction(c, binary.right, true);

    let expr = mir.new_expr_binary(kind, left, right);

    if !ty.equals(left.ty, e.ty) {
        let meta = get_meta(c, e.span);
        let bin_result = mir.create_addr_empty();
        push_temp_assign(c, expr, left.ty, meta, &bin_result);
        return mir.new_expr_int_cast_no_load(bin_result, e.ty);
    }

    return expr;
}

def call_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    // The left side may be an arbitrary expression, so we need to be careful
    // here. Example:
    // f()()
    // _t0 = f()
    // _t1 = _t0()

    let call = ast.as_call_expr(e);
    let func_addr = expr_instruction(c, call.callee, rhs);
    let varargs = ty.callable_as_func(call.callee.ty).is_varargs;
    let f_ty = ty.as_func(call.callee.ty);
    let is_method = f_ty.is_method;

    let n = call.args.count();
    let recv_addr: mir.Address = undefined;
    if is_method {
        let access = ast.as_access_expr(call.callee);
        let recv_expr = access.left; // receiver should be lhs of the callee access
        recv_addr = expr_instruction(c, recv_expr, rhs);

        if ty.should_auto_ref_receiver(f_ty) && !ty.is_ptr(recv_addr.ty) {
            let ref_name = mir.as_addr_name(&recv_addr).value;
            // the recv_addr.ty is alredy a pointer, so this should be correct
            recv_addr = mir.make_addr_ref(ref_name, recv_addr.ty);
        }

        n += 1;
    }

    let args = vec.with_cap(sizeof mir.Address, n as usize);
    if is_method {
        args.push(&recv_addr as *void);
    }


    for let i: u32 = 0; i < call.args.count(); i += 1 {
        let arg = ast.get_arg_at(&call.args, i);
        let arg_addr = expr_instruction(c, arg, true);
        args.push(&arg_addr as *void);
    }

    return mir.new_expr_call(func_addr, args, varargs);
}

def access_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let access = ast.as_access_expr(e);
    let ident = access.right.ident;

    if ty.is_enum(access.left.ty) {
        let e_ty = ty.as_enum(access.left.ty);
        let enum_value = ty.enum_value_by_name(e_ty, access.right.ident);
        let const = mir.make_addr_const_value(e.ty, enum_value as i64);
        return mir.new_expr_copy(const);
    }

    // the only other option currently is a module, which we can't really compile
    if !ty.is_struct(access.left.ty) && !ty.is_ptr(access.left.ty) && !ty.is_union(access.left.ty) {
        return compile_expr(c, access.right as *ast.Expr, rhs);
    }

    let left_meta = get_meta(c, access.left.span);
    let left_addr = expr_instruction(c, access.left, rhs);
    let left_ty = left_addr.ty;

    if ty.is_ptr(left_ty) {
        dbg.assert(!ty.is_string(left_ty), "strings are not accessible with '.'");
        dbg.assert(ty.as_ptr(left_ty).count == 1, "invalid pointer count");

        push_temp_assign(
            c,
            mir.new_expr_copy(left_addr),
            left_ty,
            left_meta,
            &left_addr
        );

        left_ty = ty.as_ptr(left_ty).inner;
    }

    if ty.is_union(left_ty) {
        let field_ty = ty.as_union(left_ty).field_with_name(ident);
        let access = mir.new_expr_union_access(left_addr, field_ty);
        let a = mir.create_addr_empty();
        // Deref by default. This copy has to be removed if the value
        // should be assigned
        push_temp_assign(c, access, field_ty, left_meta, &a);
        return mir.new_expr_copy(a);
    }

    dbg.assert_fmt(
        ty.is_struct(left_ty),
        "Expected struct, but got %s",
        ty.to_static_string(left_ty)
    );

    let struct_ty = ty.as_struct(left_ty);
    let field_ty: *ty.Type = null;
    let field_idx = ty.field_idx(struct_ty, ident, &field_ty);
    dbg.assert(field_idx >= 0, "no field with this name");

    let gep = mir.new_expr_gep(left_addr, field_idx as u32);
    let a = mir.create_addr_empty();
    // Deref by default. This copy has to be removed if the value
    // should be assigned
    push_temp_assign(c, gep, field_ty, left_meta, &a);
    return mir.new_expr_copy(a);
}

def init_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    let struct_init = ast.as_init_expr(e);

    let mir_struct = lookup_or_declare_type(c, e.ty);

    let n = struct_init.inits.count();
    let inits = vec.with_cap(sizeof mir.Address, n as usize);

    for let i: u32 = 0; i < n; i += 1 {
        let init = ast.init_expr_at(&struct_init.inits, i);
        let init_addr = expr_instruction(c, init, true);
        inits.push(&init_addr as *void);
    }

    return mir.new_expr_struct_init(mir_struct.name, inits);
}

def new_expr(c: *MirCompiler, e: *ast.Expr): mir.Expression {
    let new_e = ast.as_new_expr(e);
    let meta = get_meta(c, e.span);

    let value = mir.empty_expr();
    let a = mir.create_addr_empty();
    if !address_expression(c, new_e.expr, &a) {
        value = complex_expr(c, new_e.expr, true);
    } else {
        value = mir.new_expr_copy(a);
    }

    push_temp_assign(c, value, new_e.expr.ty, meta, &a);
    dbg.assert(mir.is_addr_name(&a), "address should be a name");
    // since new internally uses memcpy, we always need a pointer to the
    // actual value. Therefore it needs to be alloca'd
    push_decl(c, mir.as_addr_name(&a).value, new_e.expr.ty, meta);
    return mir.new_expr_new(a);
}

def complex_expr(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Expression {
    // EXPR_ACCESS
    if ast.is_access_expr(e) {
        return access_expr(c, e, rhs);
    }

    // EXPR_BINARY
    if ast.is_binary_expr(e) {
        return binary_expr(c, e);
    }

    // EXPR_ASSIGN
    if ast.is_assign_expr(e) {
        return assign_expr(c, e, rhs);
    }

    // EXPR_UNARY
    if ast.is_unary_expr(e) {
        return unary_expr(c, e, rhs);
    }

    // EXPR_NEW
    if ast.is_new_expr(e) {
        return new_expr(c, e);
    }

    // EXPR_SIZEOF
    if ast.is_sizeof_expr(e) {
        let so = ast.as_sizeof_expr(e);
        declare_type(c, so.actual_ty);
        return mir.new_expr_sizeof(so.actual_ty);
    }

    // EXPR_AS
    if ast.is_as_expr(e) {
        let e_as = ast.as_as_expr(e);
        declare_type(c, e.ty);
        let addr = expr_instruction(c, e_as.expr, rhs);
        let kind = cast_kind(e);

        return mir.new_expr_cast(kind, addr, e.ty);
    }

    // EXPR_CALL
    if ast.is_call_expr(e) {
        return call_expr(c, e, rhs);
    }

    // EXPR_INIT
    if ast.is_init_expr(e) {
        return init_expr(c, e, rhs);
    }

    // dbg.assert_fmt(false, "expr kind %d not handled", e.tag);
    return mir.empty_expr();
}

// creates one or multiple instructions for the given expression and returns
// the address of the result
def expr_instruction(c: *MirCompiler, e: *ast.Expr, rhs: bool): mir.Address {
    return expr_instruction_decl(c, e, rhs, true);
}

def expr_instruction_decl(
    c: *MirCompiler,
    e: *ast.Expr,
    rhs: bool,
    decl: bool
): mir.Address {
    let a = mir.create_addr_empty();
    if address_expression(c, e, &a) {
        return a;
    }

    let mir_expr = complex_expr(c, e, rhs);
    if mir.is_expr_copy(&mir_expr) {
        a = mir.as_expr_copy(&mir_expr).addr;
        mir.free_expr(&mir_expr);
        return a;
    }

    let meta = get_meta(c, e.span);

    // the result of a void function should be assigned to an empty address
    if mir.is_expr_call(&mir_expr) {
        let f_ty = ty.callable_as_func(mir.as_expr_call(&mir_expr).callee.ty);
        if ty.is_void(f_ty.ret) {
            // assign result to empty address (a is always empty here)
            push_assign(c, a, mir_expr, meta);
            return a;
        }
    }

    push_temp_assign(c, mir_expr, e.ty, meta, &a);
    if decl {
        dbg.assert(mir.is_addr_name(&a), "address should be a name");
        push_decl(c, mir.as_addr_name(&a).value, e.ty, meta);
    }
    return a;
}

// checks if the supplied expression is an "address expression", so either
// a name, or an rvalue. If it is, returns true and fills the out parameter
// with the correct address
def address_expression(c: *MirCompiler, e: *ast.Expr, out: *mir.Address): bool {
    if ty.is_signature(e.ty) {
        // all functions are static, function pointers are no functions, but pointers, so they
        // are not compiled here

        let mir_func = lookup_or_declare_function(c, e.ty);
        *out = mir.make_addr_name(mir_func.name, e.ty);
        return true;
    }

    if ast.is_ident_expr(e) {
        let id = &ast.as_ident_expr(e).ident;
        let ref_name = name_from_ident(id);
        let mangled = name.empty();
        if nt.lookup(&c.names, ref_name, &mangled) {
            *out = mir.make_addr_name(mangled, e.ty);
            return true;
        }

        // replace boolean literals with constant values
        if ty.is_bool(e.ty) {
            if ident.eq_lit(id, "true") {
                let lit = "1";
                *out = mir.make_addr_const_strings(e.ty, lit, lit + 1);
                return true;
            }

            if ident.eq_lit(id, "false") {
                let lit = "0";
                *out = mir.make_addr_const_strings(e.ty, lit, lit + 1);
                return true;
            }
        }

        let key = map.create_key(id.len(), id.start());
        let global = map.get(&c.global_names, key) as *mir.GlobalVar;
        if global != null {
            *out = mir.make_addr_global(global.mangled_name.ref(), e.ty);
            return true;
        }

        dbg.assert_fmt(false, "undefined: %.*s", ref_name.len, ref_name.data);
    }

    return rvalue_expr(c, e, out);
}

// Checks if the expression (e) is a rvalue. If it is, the out_address is filled
// with the correct mir.Address for this value
// (e.g. AddressConst for an int literal)
def rvalue_expr(c: *MirCompiler, e: *ast.Expr, out: *mir.Address): bool {
    if ast.is_int_expr(e) {
        *out = mir.make_addr_const(e.ty, e.span);
        return true;
    }

    if ast.is_float_expr(e) {
        *out = mir.make_addr_const(e.ty, e.span);
        return true;
    }

    if ast.is_null_expr(e) {
        *out = mir.create_addr_null(e.ty);
        return true;
    }

    if ast.is_undefined_expr(e) {
        *out = mir.create_addr_undefined(e.ty);
        return true;
    }

    if ast.is_string_expr(e) {
        let name = string_lit(c, e);
        *out = mir.make_addr_global(name, e.ty);
        return true;
    }

    if ast.is_char_expr(e) {
        let char_expr = ast.as_char_expr(e);

        if *char_expr.ptr == '\\' {
            let next = *(char_expr.ptr + 1);
            let c = mir.escape_char(next);

            *out = mir.make_addr_const_value(e.ty, c as i64);
            return true;
        }

        *out = mir.make_addr_const_value(e.ty, *char_expr.ptr as i64);
        return true;
    }

    return false;
}

def string_lit(c: *MirCompiler, e: *ast.Expr): name.Ref {
    let idx = c.globals.len;
    let s_len: usize = 0;
    let s = std.l_format_str(&s_len, "_g%d", idx);
    let mangled_name = s_mangle(c, s_len, s);

    let meta = get_meta(c, e.span);
    let lit = new mir.create_string_literal(mangled_name, meta, e.ty, e.span);
    c.add_global(lit);
    delete s;

    return mangled_name.ref();
}

def (c: *MirCompiler) eval_expr(e: *ast.Expr): mir.ValueBuffer {
    // TODO: this should be a real vm
    if ast.is_string_expr(e) {
        let lit_name = string_lit(c, e);
        return mir.buffer_from_ref(lit_name, true);
    }

    if ast.is_int_expr(e) {
        let lit_int = name.make_ref(e.span.len(), e.span.start);
        return mir.buffer_from_ref(lit_int, false);
    }

    dbg.assert(false, "invalid expression for compile time evaluation");
    return undefined;
}

def (c: *MirCompiler) global_variable(n: ident.Ident, init: *ast.Expr): name.Ref {
    let mangled_name = c.mangle_ident(n);

    let meta = get_meta(c, n.span.merge(init.span));
    let value = c.eval_expr(init);

    let global = new mir.create_global_var(n, mangled_name, meta, init.ty, value);
    c.add_global(global);

    return mangled_name.ref();
}

def (c: *MirCompiler) add_global(global: *mir.GlobalVar) {
    let key = map.create_key(global.mangled_name.len, global.mangled_name.data);
    map.insert(&c.globals, key, global as *void);

    key = map.create_key(global.original_name.len(), global.original_name.start());
    map.insert(&c.global_names, key, global as *void);
}

def label(c: *MirCompiler): mir.Label {
    let s_len: usize = 0;
    let s = std.l_format_str(&s_len, "L_%d", c.label_count);
    c.label_count = c.label_count + 1;

    let mangled_name = s_mangle(c, s_len, s);
    delete s;

    return mir.create_label(mangled_name);
}

def s_mangle(c: *MirCompiler, len: usize, s: string): name.Owned {
    return name.s_mangle(c.data.proj_root, len, s, c.mod);
}

def (c: *MirCompiler) mangle_ident(id: ident.Ident): name.Owned {
    return name.mangle_ident(c.data.proj_root, &id, c.mod);
}

def name_from_ident(i: *ident.Ident): name.Ref {
    return name.make_ref(ident.len(i), ident.start(i));
}

def cast_kind(e: *ast.Expr): mir.CastKind {
    let cast = ast.as_as_expr(e);
    let from = cast.expr.ty;
    let into = e.ty;

    if ty.is_ptr(from) || ty.is_ptr(into) {
        return mir.CastKind.Bit;
    }

    if ty.is_bool(from) || ty.is_bool(into) {
        return mir.CastKind.Bool;
    }

    if from.is_integer() || into.is_integer() {
        return mir.CastKind.Int;
    }

    if from.is_float() || into.is_float() {
        return mir.CastKind.Float;
    }

    return mir.CastKind.Bit;
}

// sets short circuit to 1 for && and 2 for ||
def mir_binary_kind_from_expr(binary: *ast.BinaryExpr, short_circuit: *i32): mir.BinaryKind {
    let k = binary.kind;
    let left = binary.left;
    let right = binary.right;

    // the binary kinds for ast and mir only differ for the scalar addition
    // and subtraction...
    if k == ast.BinaryKind.Add {
        // the following combinations are possible:
        // left | right
        //  num |  num
        //  int |  ptr
        //  ptr |  int
        if ty.equals(left.ty, right.ty) {
            return mir.BinaryKind.Add;
        }

        return mir.BinaryKind.AddScalar;
    } else if k == ast.BinaryKind.Sub {
        // the following combinations are possible:
        // left | right
        //  num |  num
        //  int |  ptr
        //  ptr |  int
        //  ptr |  ptr   <- this is not allowed for addtion

        if ty.equals(left.ty, right.ty) {
            return mir.BinaryKind.Sub;
        }

        return mir.BinaryKind.SubScalar;
    }

    if k == ast.BinaryKind.LogAnd {
        *short_circuit = 1;
    } else if k == ast.BinaryKind.LogOr {
        *short_circuit = 2;
    }

    // ...everything else is identical
    return *(&k as *mir.BinaryKind);
}
