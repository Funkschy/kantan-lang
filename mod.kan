import "ptrvec";
import "vec";
import "ast";
import "path";

type Module struct {
    statements: ptrvec.Vec,
    path: path.Path,
     // the following vecs just contain indices into the statements ptrvec
    imports: vec.Vec,
    functions: vec.Vec,
    structs: vec.Vec
}

def create(p: path.Path): Module {
    return Module {
        statements: ptrvec.create(),
        path: p,
        imports: vec.create(sizeof i32),
        functions: vec.create(sizeof i32),
        structs: vec.create(sizeof i32)
    };
}

def get_special_stmt_at(mod: *Module, indices: *vec.Vec, i: i32): *ast.Stmt {
    let idx = 0;
    if !vec.get(indices, i, &idx as *void) {
        return null;
    }

    let s: *ast.Stmt = get_stmt(mod, idx);
    if s == null {
        return null;
    }

    return s;
}

def get_import_at(mod: *Module, i: i32): *ast.ImportStmt {
    return ast.as_import_stmt(get_special_stmt_at(mod, &mod.imports, i));
}

def num_imports(mod: *Module): i32 {
    return mod.imports.len;
}

def get_function_at(mod: *Module, i: i32): *ast.FuncDeclStmt {
    return ast.as_func_decl_stmt(get_special_stmt_at(mod, &mod.functions, i));
}

def num_functions(mod: *Module): i32 {
    return mod.functions.len;
}

def get_struct_at(mod: *Module, i: i32): *ast.StructDeclStmt {
    return ast.as_struct_decl_stmt(get_special_stmt_at(mod, &mod.structs, i));
}

def num_structs(mod: *Module): i32 {
    return mod.structs.len;
}

def push_stmt(mod: *Module, stmt: *ast.Stmt): void {
    if ast.is_import_stmt(stmt) {
        let idx = mod.statements.len;
        vec.push(&mod.imports, &idx as *void);
    } else if ast.is_func_decl_stmt(stmt) {
        let idx = mod.statements.len;
        vec.push(&mod.functions, &idx as *void);
    } else if ast.is_struct_decl_stmt(stmt) {
        let idx = mod.statements.len;
        vec.push(&mod.structs, &idx as *void);
    }

    ptrvec.push_ptr(&mod.statements, stmt as *void);
}

def get_stmt(mod: *Module, i: i32): *ast.Stmt {
    return ptrvec.get(&mod.statements, i) as *ast.Stmt;
}

def free_m(mod: *Module): void {
    let i = 0;
    while i < mod.statements.len {
        ast.stmt_free(get_stmt(mod, i));
        i = i + 1;
    }

    ptrvec.free_v(&mod.statements);
    vec.free_v(&mod.imports);
    vec.free_v(&mod.functions);
    vec.free_v(&mod.structs);

    delete mod;
}

type Map struct {
    mods: ptrvec.Vec
}

def map_with_cap(size: i32): Map {
    return Map { mods: ptrvec.with_cap(size) };
}

def num_mods(mm: *Map): i32 {
    return mm.mods.len;
}

def add_mod(mm: *Map, mod: *Module): void {
    ptrvec.push_ptr(&mm.mods, mod as *void);
}

def get_mod(mm: *Map, idx: i32): *Module {
    return ptrvec.get(&mm.mods, idx) as *Module;
}

def map_free(mm: *Map): void {
    let i = 0;
    while i < num_mods(mm) {
        let m = get_mod(mm, i);
        free_m(m);
        i = i + 1;
    }
    ptrvec.free_v(&mm.mods);
}

