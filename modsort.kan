import "std";

def swap(values: *i32, indices: *i32, i: i32, j: i32) {
    let tmp_value = *(values + i);
    let tmp_index = *(indices + i);

    *(values + i) = *(values + j);
    *(indices + i) = *(indices + j);

    *(values + j) = tmp_value;
    *(indices + j) = tmp_index;
}

def inner_sort(values: *i32, indices: *i32, len: i32) {
    if len <= 1 {
        return;
    }

    // last element as pivot
    // TODO: pick better pivot element
    let pivot_idx = len / 2;
    let pivot = values + pivot_idx;

    let j = len - 1;
    let i = -1;

    let running = true;
    while running {
        while *(values + (i+=1)) < *pivot {}
        while *(values + (j-=1)) > *pivot && j > 0 {}

        if i < j {
            swap(values, indices, i, j);
        } else {
            running = false;
        }
    }

    swap(values, indices, i, pivot_idx);
    inner_sort(values, indices, i);
    let end = i + 1;
    inner_sort(values + end, indices + end, len - end);
}

// returns an array (with length len) with the original indices of import_nums
//                     0  1  2  3
//                     ----------
// e.g. import_coutns: 2, 4, 1, 2
// returns:            2, 3, 0, 1
def sort(import_counts: *i32, len: i32): *i32 {
    let indices = std.malloc(len * sizeof i32) as *i32;
    for let i = 0; i < len; i+= 1 {
        *(indices + i) = i;
    }

    inner_sort(import_counts, indices, len);

    return indices;
}
