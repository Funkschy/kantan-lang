import "mod";
import "dbg";
import "std";
import "path";
import "ident";
import "source";

type Owned struct {
    data: string,
    len: i32
}

def free_owned(n: *Owned): void {
    delete n.data;
}

def make_owned(len: i32, data: string): Owned {
    if data != null {
        dbg.assert(*(data + len) == '\0', "owned names should be null terminated");
    }
    return Owned { data: data, len: len };
}

// like make_owned, but copies the data automatically
def make_copied(len: i32, data: string): Owned {
    return make_owned(len, std.strndup(data, len));
}

def (n: *Owned) clone(): Owned {
    return make_copied(n.len, n.data);
}

type Ref struct {
    len: i32,
    data: string
}

def make_ref(len: i32, data: string): Ref {
    return Ref { len: len, data: data };
}

def ref(owned: Owned): Ref {
    return make_ref(owned.len, owned.data);
}

def empty(): Ref {
    return make_ref(0, null);
}

def mangle_ident(
    proj_root: path.Path,
    name: *ident.Ident,
    declared_in: *mod.Module
): Owned {
    return s_mangle(
        proj_root,
        ident.len(name),
        ident.start(name),
        declared_in
    );
}

def s_mangle(
    proj_root: path.Path,
    len: i32,
    s: string,
    declared_in: *mod.Module
): Owned {
    let name_len = 0;
    let name_data = "";

    // TODO(#72): this name mangling algorithm assumes the existence of a global
    //  file path root. This does not necessarily exist in windows

    let file_ending_len = 0;
    source.kantan_file_ending(&file_ending_len);

    let p = mod.get_path(declared_in);

    if !mod.is_std_lib(declared_in) {
        let mod_len = p.len - proj_root.len - file_ending_len;
        let mod_name = p.inner + proj_root.len;

        // this is currently the only invalid identifier, so we just handle
        // it as an edge case
        let is_invalid_identifier = std.strncmp(mod_name, "llvm", 4) == 0;
        if is_invalid_identifier {
            mod_len = mod_len + 1;
        }

        // +1 for '.'
        name_len = mod_len + len + 1;
        name_data = std.malloc(name_len + 1) as string;

        let out_idx = 0;
        if is_invalid_identifier {
            // escape the invalid name with '_'
            *name_data = '_';
            out_idx = 1;
        }

        let in_idx = 0;
        let sep = path.sys_separator();
        while in_idx < mod_len {
            let c = *(mod_name + in_idx);
            if c == sep {
                c = '.';
            }
            *(name_data + out_idx) = c;
            in_idx = in_idx + 1;
            out_idx = out_idx + 1;
        }
        *(name_data + mod_len) = '.';

        let dest = name_data + mod_len + 1;
        std.memcpy(dest as *void, s as *void, len);
        *(name_data + name_len) = '\0';
    } else {
        let file_name_len = p.len - file_ending_len;
        let file_name = p.inner;

        name_len = 4 + file_name_len + 1 + len;
        name_data = std.format_str(
            "std.%.*s.%.*s", file_name_len, file_name, len, s
        );
    }

    return make_owned(name_len, name_data);
}

