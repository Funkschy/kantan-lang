// This modules defines NameTables which are used by mirc to define variable names.

// This define toogles between debug and prod NameTable
// the debug NT uses the original names from the source code (with some
// minor changes), while the prod one just uses numbers as variable names
#define DBG_MIR_NAMES 1

#include "std.h"

import "map";
import "vec";
import "mir";
import "dbg";
import "std";

type NameScope struct {
    // maps from a source name to a index into mangled_names
    bindings: map.Map, // map.Map<mir.Name(borrowed), i32>
    mangled_names: vec.Vec // vec.Vec<mir.Name(owned)>
}

def create_scope(): NameScope {
    return NameScope{
        bindings: map.create(),
        mangled_names: vec.create(sizeof mir.Name)
    };
}

def free_s(ns: *NameScope): void {
    let i = 0;
    while i < ns.mangled_names.len {
        let name = vec.get_ptr(&ns.mangled_names, i) as *mir.Name;

        dbg.assert(name != null, "name was null");
        dbg.assert(name.owned, "mangled names should be owned");

        mir.free_name(name);
        i = i + 1;
    }

    map.free_m(&ns.bindings);
    vec.free_v(&ns.mangled_names);
}

def bind_in(ns: *NameScope, original: mir.Name, mangled: mir.Name): void {
    dbg.assert(!original.owned, "original should not be owned");
    dbg.assert(mangled.owned, "mangled should be owned");

    let key = map.create_key(original.len, original.data);
    let idx = ns.mangled_names.len;
    vec.push(&ns.mangled_names, &mangled as *void);
    map.insert(&ns.bindings, key, std.int_to_ptr(idx));
}

def get_in(ns: *NameScope, name: mir.Name, out: *mir.Name): bool {
    let key = map.create_key(name.len, name.data);
    let index = map.get(&ns.bindings, key);
    if index == null {
        return false;
    }

    let found = vec.get_ptr(&ns.mangled_names, std.ptr_to_int(index)) as *mir.Name;
    *out = *found;
    return true;
}

// Debug NameTable
#if DBG_MIR_NAMES

// A NameTable for human readable names
// Binds the original name of a variable to a new one, to allow scopes.
// {
//     let x = 5;
//     {
//         let x = "test";
//     }
// }
//
// In the outer scope, lookup(nt, "x") will return x.
// In the inner scope, is will return `x_1`
type NameTable struct {
    scopes: vec.Vec, // vec.Vec<NameScope>
    // this counts how many versions of each name are in scope right now
    in_scope: map.Map // map.Map<mir.Name(borrowed), i32>
}

def create(): NameTable {
    return NameTable {
        scopes: vec.create(sizeof NameScope),
        in_scope: map.create()
    };
}

def free_nt(nt: *NameTable): void {
    dbg.assert_fmt(nt.scopes.len == 0, "%d open scopes left", nt.scopes.len);

    vec.free_v(&nt.scopes);
    map.free_m(&nt.in_scope);
}

def top(nt: *NameTable): *NameScope {
    return scope_at(nt, nt.scopes.len - 1);
}

def scope_at(nt: *NameTable, i: i32): *NameScope {
    return vec.get_ptr(&nt.scopes, i) as *NameScope;
}

def bind(nt: *NameTable, name: mir.Name): void {
    dbg.assert(!name.owned, "only name refs should be bound");
    let value = num_in_scope(nt, name);

    let new_name = name.data;
    let new_name_len = name.len;

    // check if this is a new name, which is not yet in scope
    if value == 0 {
        // the mangled name should be owned, so just copy it here
        new_name = std.strndup(new_name, new_name_len);
        set_in_scope(nt, name, 1);
    } else {
        new_name = std.format_str("%.*s_%d", new_name_len, new_name, value);
        new_name_len = new_name_len + 1 + std.int_num_digits(value);
    }

    let mangled = mir.make_owned_name(new_name_len, new_name);
    let top = top(nt);
    dbg.assert(top != null, "top was null");

    bind_in(top, name, mangled);
}

def open_scope(nt: *NameTable): void {
    let scope = create_scope();
    push_scope(nt, &scope);
}

def num_in_scope(nt: *NameTable, name: mir.Name): i32 {
    let key = map.create_key(name.len, name.data);
    return std.ptr_to_int(map.get(&nt.in_scope, key));
}

def set_in_scope(nt: *NameTable, name: mir.Name, count: i32): void {
    let key = map.create_key(name.len, name.data);
    let item = map.get_item(&nt.in_scope, key);
    let count = std.int_to_ptr(count);
    if item == null {
        map.insert(&nt.in_scope, key, count);
        return;
    }
    item.value = count;
}

def close_scope(nt: *NameTable): void {
    let top = top(nt);
    let top_iter = map.iter(&top.bindings);

    // reduce the 'in_scope' count of the dropped variables
    let bind = map.iter_next(&top_iter);
    while bind != null {
        let item = map.get_item(&nt.in_scope, bind.key);
        dbg.assert(item != null, "item was null");

        // update value in map
        let value = std.ptr_to_int(item.value);
        item.value = std.int_to_ptr(value - 1);

        bind = map.iter_next(&top_iter);
    }

    free_s(top);
    nt.scopes.len = nt.scopes.len - 1;
}

def push_scope(s: *NameTable, scope: *NameScope): void {
    vec.push(&s.scopes, scope as *void);
}

def lookup(nt: *NameTable, name: mir.Name, out: *mir.Name): bool {
    dbg.assert(!name.owned, "name should not be owned");

    let i = nt.scopes.len - 1;
    while i >= 0 {
        let scope = scope_at(nt, i);
        let mangled = mir.empty_name();
        if get_in(scope, name, &mangled) {
            *out = mangled;
            return true;
        }
        i = i - 1;
    }

    return false;
}

#endif
