// This modules defines NameTables which are used by mirc to define variable names.

// This define toogles between debug and prod NameTable
// the debug NT uses the original names from the source code (with some
// minor changes), while the prod one just uses numbers as variable names
#define DBG_MIR_NAMES 1

import "map";
import "vec";
import "mir";
import "dbg";
import "std";

type NameScope struct {
    // maps from a source name to a index into mangled_names
    bindings: map.Map, // map.Map<mir.Name(borrowed), i32>
    mangled_names: vec.Vec // vec.Vec<mir.Name(owned)>
}

def create_scope(): NameScope {
    return NameScope{
        bindings: map.create(),
        mangled_names: vec.create(sizeof mir.Name)
    };
}

def free_s(ns: *NameScope): void {
    let ns_iter = map.iter(&ns.bindings);

    let bind = map.iter_next(&ns_iter);
    while bind != null {
        let idx = std.ptr_to_int(map.get(&ns.bindings, bind.key));
        let name = vec.get_ptr(&ns.mangled_names, idx) as *mir.Name;
        dbg.assert(name != null, "name was null");
        mir.free_name(name);

        bind = map.iter_next(&ns_iter);
    }

    map.free_m(&ns.bindings);
    vec.free_v(&ns.mangled_names);
}

def bind_in(ns: *NameScope, original: mir.Name, mangled: mir.Name): void {
    dbg.assert(!original.owned, "original should not be owned");
    dbg.assert(mangled.owned, "mangled should be owned");

    let key = map.create_key(original.len, original.data);
    let idx = ns.mangled_names.len;
    vec.push(&ns.mangled_names, &mangled as *void);
    map.insert(&ns.bindings, key, std.int_to_ptr(idx));
}

// Debug NameTable
#if DBG_MIR_NAMES

// A NameTable for human readable names
// Binds the original name of a variable to a new one, to allow scopes.
// {
//     let x = 5;
//     {
//         let x = "test";
//     }
// }
//
// In the outer scope, lookup(nt, "x") will return x.
// In the inner scope, is will return `x_1`
type NameTable struct {
    scopes: vec.Vec, // vec.Vec<NameScope>
    // this counts how many versions of each name are in scope right now
    in_scope: map.Map // map.Map<mir.Name(borrowed), i32>
}

def create(): NameTable {
    return NameTable {
        scopes: vec.create(sizeof NameScope),
        in_scope: map.create()
    };
}

def free_nt(nt: *NameTable): void {
    let i = 0;
    while i < nt.scopes.len {
        let scope = scope_at(nt, i);
        free_s(scope);
        i = i + 1;
    }
    vec.free_v(&nt.scopes);
    map.free_m(&nt.in_scope);
}

def top(nt: *NameTable): *NameScope {
    return scope_at(nt, nt.scopes.len - 1);
}

def scope_at(nt: *NameTable, i: i32): *NameScope {
    return vec.get_ptr(&nt.scopes, i) as *NameScope;
}

def bind(nt: *NameTable, name: mir.Name): void {
    dbg.assert(!name.owned, "only name refs should be bound");
    let value = num_in_scope(nt, name);

    let new_name = name.data;
    let new_name_len = name.len;

    // check if this is a new name, which is not yet in scope
    if value == 0 {
        // the mangled name should be owned, so just copy it here
        new_name = std.strndup(new_name, new_name_len);
        set_in_scope(nt, name, 1);
    } else {
        new_name = std.format_str("%.*s_%d", new_name_len, new_name, value);
        new_name_len = new_name_len + 1 + std.int_num_digits(value);
    }

    let mangled = mir.make_owned_name(new_name_len, new_name);
    let top = top(nt);
    dbg.assert(top != null, "top was null");

    bind_in(top, name, mangled);
}

def open_scope(nt: *NameTable): void {
    let scope = create_scope();
    push_scope(nt, &scope);
}

def num_in_scope(nt: *NameTable, name: mir.Name): i32 {
    let key = map.create_key(name.len, name.data);
    return std.ptr_to_int(map.get(&nt.in_scope, key));
}

def set_in_scope(nt: *NameTable, name: mir.Name, count: i32): void {
    let key = map.create_key(name.len, name.data);
    map.get_item(&nt.in_scope, key).value = std.int_to_ptr(count);
}

def close_scope(nt: *NameTable): void {
    let top = top(nt);
    let top_iter = map.iter(&top.bindings);

    // reduce the 'in_scope' count of the dropped variables
    let bind = map.iter_next(&top_iter);
    while bind != null {
        let item = map.get_item(&nt.in_scope, bind.key);
        dbg.assert(item != null, "item was null");

        // update value in map
        let value = std.ptr_to_int(item.value);
        item.value = std.int_to_ptr(value - 1);

        bind = map.iter_next(&top_iter);
    }

    free_s(top);
    nt.scopes.len = nt.scopes.len - 1;
}

def push_scope(s: *NameTable, scope: *NameScope): void {
    vec.push(&s.scopes, scope as *void);
}

#endif
