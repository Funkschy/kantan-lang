// This modules defines NameTables which are used by mirc to define variable names.

// This define toogles between debug and prod NameTable
// the debug NT uses the original names from the source code (with some
// minor changes), while the prod one just uses numbers as variable names
#define DBG_MIR_NAMES 1

#include "std.h"

import "map";
import "vec";
import "mir";
import "dbg";
import "std";

type NameScope struct {
    // maps from a source name to a index into mangled_names of the NameTable
    bindings: map.Map // map.Map<mir.Name(borrowed), i32>
}

def create_scope(): NameScope {
    return NameScope{
        bindings: map.create()
    };
}

def free_s(ns: *NameScope): void {
    map.free_m(&ns.bindings);
}

def bind_in(ns: *NameScope, original: mir.RefName, idx: i32): void {
    let key = map.create_key(original.len, original.data);
    // differentiate index 0 from null
    map.insert(&ns.bindings, key, std.int_to_ptr(idx + 1));
}

def get_in(ns: *NameScope, name: mir.RefName, out: *i32): bool {
    let key = map.create_key(name.len, name.data);
    let index = map.get(&ns.bindings, key);
    if index == null {
        return false;
    }

    // differentiate index 0 from null
    *out = std.ptr_to_int(index) - 1;
    return true;
}

// Debug NameTable
#if DBG_MIR_NAMES

// A NameTable for human readable names
// Binds the original name of a variable to a new one, to allow scopes.
// 1 {
// 2     let x = 5;
// 3     {
// 4         let x = "test";
// 5     }
// 6     let x = "";
// 7 }
//
// In the outer scope, lookup(nt, "x") will return x before line 6 (x_1 after).
// In the inner scope, is will return `x_1`
type NameTable struct {
    scopes: vec.Vec, // vec.Vec<NameScope>
    // this counts how many versions of each name are in scope right now
    in_scope: map.Map, // map.Map<mir.RefName, i32>
    mangled_names: vec.Vec // vec.Vec<mir.OwnedName>
}

def create(): NameTable {
    return NameTable {
        scopes: vec.create(sizeof NameScope),
        in_scope: map.create(),
        mangled_names: vec.create(sizeof mir.OwnedName)
    };
}

def free_nt(nt: *NameTable): void {
    dbg.assert_fmt(nt.scopes.len == 0, "%d open scopes left", nt.scopes.len);

    vec.free_v(&nt.scopes);

    let i = 0;
    while i < nt.mangled_names.len {
        let name = vec.get_ptr(&nt.mangled_names, i) as *mir.OwnedName;
        dbg.assert(name != null, "name was null");

        mir.free_name(name);
        i = i + 1;
    }

    vec.free_v(&nt.mangled_names);
    map.free_m(&nt.in_scope);
}

def top(nt: *NameTable): *NameScope {
    return scope_at(nt, nt.scopes.len - 1);
}

def scope_at(nt: *NameTable, i: i32): *NameScope {
    return vec.get_ptr(&nt.scopes, i) as *NameScope;
}

def bind(nt: *NameTable, name: mir.RefName): mir.RefName {
    let value = num_in_scope(nt, name);

    let new_name = name.data;
    let new_name_len = name.len;

    // check if this is a new name, which is not yet in scope
    if value == 0 {
        // the mangled name should be owned, so just copy it here
        new_name = std.strndup(new_name, new_name_len);
    } else {
        new_name = std.format_str("%.*s_%d", new_name_len, new_name, value);
        new_name_len = new_name_len + 1 + std.int_num_digits(value);
    }

    let mangled = mir.make_owned_name(new_name_len, new_name);
    let top = top(nt);
    dbg.assert(top != null, "top was null");

    let idx = nt.mangled_names.len;

    vec.push(&nt.mangled_names, &mangled as *void);
    set_in_scope(nt, name, value + 1);
    bind_in(top, name, idx);

    return mir.make_ref_name(mangled.len, mangled.data);
}

def open_scope(nt: *NameTable): void {
    let scope = create_scope();
    push_scope(nt, &scope);
}

def num_in_scope(nt: *NameTable, name: mir.RefName): i32 {
    let key = map.create_key(name.len, name.data);
    return std.ptr_to_int(map.get(&nt.in_scope, key));
}

def set_in_scope(nt: *NameTable, name: mir.RefName, count: i32): void {
    let key = map.create_key(name.len, name.data);
    let item = map.get_item(&nt.in_scope, key);
    let count = std.int_to_ptr(count);
    if item == null {
        map.insert(&nt.in_scope, key, count);
        return;
    }
    item.value = count;
}

def close_scope(nt: *NameTable): void {
    let top = top(nt);
    let top_iter = map.iter(&top.bindings);

    // reduce the 'in_scope' count of the dropped variables
    let bind = map.iter_next(&top_iter);
    while bind != null {
        let item = map.get_item(&nt.in_scope, bind.key);
        dbg.assert(item != null, "item was null");

        // update value in map
        let value = std.ptr_to_int(item.value);
        item.value = std.int_to_ptr(value - 1);

        bind = map.iter_next(&top_iter);
    }

    free_s(top);
    nt.scopes.len = nt.scopes.len - 1;
}

def push_scope(s: *NameTable, scope: *NameScope): void {
    vec.push(&s.scopes, scope as *void);
}

def lookup(nt: *NameTable, name: mir.RefName, out: *mir.RefName): bool {
    let i = nt.scopes.len - 1;
    while i >= 0 {
        let scope = scope_at(nt, i);
        let idx = 0;
        if get_in(scope, name, &idx) {
            let mangled = vec.get_ptr(&nt.mangled_names, idx) as *mir.OwnedName;

            *out = mir.ref_name(*mangled);
            return true;
        }
        i = i - 1;
    }

    return false;
}

#endif
