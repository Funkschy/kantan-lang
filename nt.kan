// This modules defines NameTables which are used by mirc to define variable names.

// This define toogles between debug and prod NameTable
// the debug NT uses the original names from the source code (with some
// minor changes), while the prod one just uses numbers as variable names
#define DBG_MIR_NAMES 1

import "map";
import "vec";
import "dbg";
import "std";
import "name";

type NameScope struct {
    // maps from a source name to a index into mangled_names of the NameTable
    bindings: map.Map // map.Map<name.Ref, i32>
}

def create_scope(): NameScope {
    return NameScope{
        bindings: map.create()
    };
}

def free_s(ns: *NameScope): void {
    map.free_m(&ns.bindings);
}

def bind_in(ns: *NameScope, original: name.Ref, idx: i32): void {
    let key = map.create_key(original.len, original.data);
    // differentiate index 0 from null
    map.insert(&ns.bindings, key, std.int_to_ptr(idx + 1));
}

def get_in(ns: *NameScope, name: name.Ref, out: *i32): bool {
    let key = map.create_key(name.len, name.data);
    let index = map.get(&ns.bindings, key);
    if index == null {
        return false;
    }

    // differentiate index 0 from null
    *out = std.ptr_to_int(index) - 1;
    return true;
}

// Debug NameTable
#if DBG_MIR_NAMES

// A NameTable for human readable names
// Binds the original name of a variable to a new one, to allow scopes.
// 1 {
// 2     let x = 5;
// 3     {
// 4         let x = "test";
// 5     }
// 6     let x = "";
// 7 }
//
// In the outer scope, lookup(nt, "x") will return x before line 6 (x_1 after).
// In the inner scope, is will return `x_1`
type NameTable struct {
    scopes: vec.Vec, // vec.Vec<NameScope>
    // this counts how many versions of each name were at one point in scope
    in_scope: map.Map, // map.Map<name.Ref, i32>
    mangled_names: vec.Vec // vec.Vec<name.Owned>
}

def create(): NameTable {
    return NameTable {
        scopes: vec.create(sizeof NameScope),
        in_scope: map.create(),
        mangled_names: vec.create(sizeof name.Owned)
    };
}

def free_nt(nt: *NameTable): void {
    dbg.assert_fmt(nt.scopes.len == 0, "%d open scopes left", nt.scopes.len);

    vec.free_v(&nt.scopes);

    let i = 0;
    while i < nt.mangled_names.len {
        let n = vec.get_ptr(&nt.mangled_names, i) as *name.Owned;
        dbg.assert(n != null, "name was null");

        name.free_owned(n);
        i = i + 1;
    }

    vec.free_v(&nt.mangled_names);
    map.free_m(&nt.in_scope);
}

def top(nt: *NameTable): *NameScope {
    return scope_at(nt, nt.scopes.len - 1);
}

def scope_at(nt: *NameTable, i: i32): *NameScope {
    return vec.get_ptr(&nt.scopes, i) as *NameScope;
}

def bind(nt: *NameTable, to_bind: name.Ref): name.Ref {
    let value = num_in_scope(nt, to_bind);

    let new_name = to_bind.data;
    let new_name_len = to_bind.len;

    // check if this is a new name, which is not yet in scope
    if value == 0 {
        // the mangled name should be owned, so just copy it here
        new_name = std.strndup(new_name, new_name_len);
    } else {
        new_name = std.format_str("%.*s_%d", new_name_len, new_name, value);
        new_name_len = new_name_len + 1 + std.int_num_digits(value);
    }

    let mangled = name.make_owned(new_name_len, new_name);
    let top = top(nt);
    dbg.assert(top != null, "top was null");

    let idx = nt.mangled_names.len;
    bind_in(top, to_bind, idx);
    vec.push(&nt.mangled_names, &mangled as *void);

    set_in_scope(nt, to_bind, value + 1);

    return name.ref(mangled);
}

def open_scope(nt: *NameTable): void {
    let scope = create_scope();
    push_scope(nt, &scope);
}

def num_in_scope(nt: *NameTable, name: name.Ref): i32 {
    let key = map.create_key(name.len, name.data);
    return std.ptr_to_int(map.get(&nt.in_scope, key));
}

def set_in_scope(nt: *NameTable, name: name.Ref, count: i32): void {
    let key = map.create_key(name.len, name.data);
    let count = std.int_to_ptr(count);
    map.insert(&nt.in_scope, key, count);
}

def close_scope(nt: *NameTable): void {
    let top = top(nt);
    free_s(top);
    nt.scopes.len = nt.scopes.len - 1;
}

def push_scope(s: *NameTable, scope: *NameScope): void {
    vec.push(&s.scopes, scope as *void);
}

def lookup(nt: *NameTable, needle: name.Ref, out: *name.Ref): bool {
    let i = nt.scopes.len - 1;
    while i >= 0 {
        let scope = scope_at(nt, i);
        let idx = 0;
        if get_in(scope, needle, &idx) {
            let mangled = vec.get_ptr(&nt.mangled_names, idx) as *name.Owned;

            *out = name.ref(*mangled);
            return true;
        }
        i = i - 1;
    }

    return false;
}

#endif
