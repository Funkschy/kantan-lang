import "io";

import "std";
import "ptrvec";

type Config struct {
    had_errors: bool,
    files: ptrvec.Vec,
    opt_level: i32,
    output_filename: string
}

def free_config(c: *Config) {
    ptrvec.free_v(&c.files);
}

def parse(argc: i32, argv: *string): Config {
    let config = Config {
        had_errors: false,
        files: ptrvec.with_cap(argc),
        opt_level: 0,
        output_filename: null
    };

    for let i = 1; i < argc; i = i + 1 {
        let arg = *(argv + i);

        if *arg != '-' {
            ptrvec.push_ptr(&config.files, arg as *void);
        } else if *(arg + 1) != '-' {
            let set_to_next: *string = null;
            if parse_short(&config, arg + 1, &config.had_errors, &set_to_next) {
                if argc - i <= 1 {
                    config.had_errors = true;
                    io.printf("ERROR: Expected argument after '%s'\n", arg);
                }
                // skip next argument
                i = i + 1;
                *set_to_next = *(argv + i);
            }
        }
    }

    return config;
}

// if this returns true, the following argument is interpreted as a value
// set_to_next will be set to the field in config, which needs to be set to the next command line
// argument (if available)
def parse_short(config: *Config, arg: string, had_errors: *bool, set_to_next: **string): bool {
    let len = std.strlen(arg);

    if len == 2 && *arg == 'O' {
        let num = *(arg + 1) - '0';

        if num < 0 || num > 3 {
            io.printf("ERROR: Invalid optimization level: %d\n", num);
            *had_errors = true;
        } else {
            config.opt_level = num;
        }

        return false;
    }

    if len == 1 && *arg == 'o' {
        *set_to_next = &config.output_filename;
        return true;
    }


    io.printf("ERROR: Invalid flag '%s'\n", arg);
    *had_errors = true;
    return false;
}
