import "io";

import "std";
import "ptrvec";

extern def get_sys(linux: *bool, darwin: *bool, win32: *bool);

type Config struct {
    had_errors: bool,
    exit_immediately: bool,
    debug_info: bool,
    files: ptrvec.Vec,
    opt_level: i32,
    output_filename: string,
    target_os: string,
    is_same_target_as_os: bool
}

def free_config(c: *Config) {
    ptrvec.free_v(&c.files);
}

def parse(argc: i32, argv: *string): Config {
    let config = Config {
        had_errors: false,
        exit_immediately: false,
        debug_info: false,
        files: ptrvec.with_cap(argc),
        opt_level: 0,
        output_filename: null,
        target_os: null,
        is_same_target_as_os: true
    };

    for let i = 1; i < argc; i = i + 1 {
        let arg = *(argv + i);

        if *arg != '-' {
            ptrvec.push_ptr(&config.files, arg as *void);
        } else {
            let set_to_next: *string = null;
            let takes_argument = false;

            if *(arg + 1) != '-' {
                takes_argument = parse_short(&config, arg + 1, &config.had_errors, &set_to_next);
            } else if std.strlen(arg) < 3 {
                io.printf("ERROR: Invalid flag '--'\n");
                config.had_errors = true;
            } else {
                takes_argument = parse_long(&config, arg + 2, &config.had_errors, &set_to_next);
            }

            if takes_argument {
                if argc - i <= 1 {
                    config.had_errors = true;
                    io.printf("ERROR: Expected argument after '%s'\n", arg);
                }
                // skip next argument
                i = i + 1;
                *set_to_next = *(argv + i);
            }
        }
    }

    config.had_errors = error_in_config_values(&config);

    if !config.had_errors {
        let linux = false;
        let darwin = false;
        let win32 = false;

        get_sys(&linux, &darwin, &win32);
        if config.target_os != null {
            if std.strcmp(config.target_os, "linux") == 0 {
                config.is_same_target_as_os = linux;
            } else if std.strcmp(config.target_os, "win32") == 0 {
                config.is_same_target_as_os = win32;
            } else if std.strcmp(config.target_os, "darwin") == 0 {
                config.is_same_target_as_os = darwin;
            }
        } else {
            config.is_same_target_as_os = true;

            if linux {
                config.target_os = "linux";
            } else if darwin {
                config.target_os = "darwin";
            } else if win32 {
                config.target_os = "win32";
            }
        }
    }

    return config;
}

// if this returns true, the following argument is interpreted as a value
// set_to_next will be set to the field in config, which needs to be set to the next command line
// argument (if available)
def parse_short(config: *Config, arg: string, had_errors: *bool, set_to_next: **string): bool {
    let len = std.strlen(arg);

    if len == 2 && *arg == 'O' {
        let num = *(arg + 1) - '0';

        if num < 0 || num > 3 {
            io.printf("ERROR: Invalid optimization level: %d\n", num);
            *had_errors = true;
        } else {
            config.opt_level = num;
        }

        return false;
    }

    if len == 1 && *arg == 'o' {
        *set_to_next = &config.output_filename;
        return true;
    }

    if len == 1 && *arg == 'h' {
        print_usage();
        config.exit_immediately = true;
        return false;
    }

    if len == 1 && *arg == 'g' {
        config.debug_info = true;
        return false;
    }

    io.printf("ERROR: Invalid flag '%s'\n", arg);
    *had_errors = true;
    return false;
}

def parse_long(config: *Config, arg: string, had_errors: *bool, set_to_next: **string): bool {
    if std.strcmp(arg, "help") == 0 {
        print_usage();
        config.exit_immediately = true;
        return false;
    }

    if std.strcmp(arg, "sys") == 0 {
        *set_to_next = &config.target_os;
        return true;
    }

    io.printf("ERROR: Invalid flag '%s'\n", arg);
    *had_errors = true;
    return false;
}

def error_in_config_values(config: *Config): bool {
    if config.target_os != null {
        if std.strcmp(config.target_os, "win32") == 0 {}
        else if std.strcmp(config.target_os, "linux") == 0 {}
        else if std.strcmp(config.target_os, "darwin") == 0 {}
        else {
            io.printf("ERROR: Invalid target system '%s'\n", config.target_os);
            return true;
        }
    }

    return false;
}

def print_usage() {
    io.printf("kantan\nFelix Schoeller <felix.schoeller@protonmail.com>\n");
    io.printf("The official compiler for the Kantan programming language\n\n");
    io.printf("USAGE:\n");
    io.printf("    kantan [OPTIONS] <source-file>...\n\n");
    io.printf("OPTIONS:\n");
    io.printf("    -o <file>\tthe output file (end with .s for assembly output)\n");
    io.printf("    -O<level>\tthe optimization level\t[possible values 0, 1, 2, 3]\n");
    io.printf("    -h / --help\tprint this message\n");
    io.printf("    --sys\tset the target OS\t[possible values 'linux', 'darwin', 'win32']\n");
    io.printf("\n");
    io.printf("ARGS:\n");
    io.printf("    <source-file>...\n");
}
