import "std";
import "dbg";

type Vec struct {
    len: i32,
    cap: i32,
    elements: **void
}

def create(): Vec {
    return Vec { len: 0, cap: 0, elements: null };
}

def with_cap(cap: i32): Vec {
    let vec = create();
    resize_s(&vec, cap);
    return vec;
}

def zero(v: *Vec) {
    std.memset(v.elements as *void, 0, v.len * sizeof *void);
}

def is_empty(v: *Vec): bool {
    return v.len <= 0;
}

def pop(v: *Vec): *void {
    if !is_empty(v) {
        let elem = get(v, 0);
        v.len = v.len - 1;
        std.memmove(
            v.elements as *void,
            (v.elements + 1) as *void,
            v.len * sizeof **void
        );
        return elem;
    }
    return null;
}

def append(v: *Vec, other: *Vec): void {
    if is_empty(other) {
        return;
    }

    let new_len = v.len + other.len;
    resize_s(v, new_len);
    std.memcpy(
        (v.elements + v.len) as *void,
        other.elements as *void,
        other.len * sizeof *void
    );
    v.len = new_len;
}

def push_ptr(v: *Vec, elem: *void): void {
    if v.len + 1 > v.cap {
        resize(v);
    }

    *(v.elements + v.len) = elem;
    v.len = v.len + 1;
}

def get(v: *Vec, i: i32): *void {
    if i < v.len {
        return *(v.elements + i);
    }

    return null;
}

def unsafe_get(v: *Vec, i: i32): *void {
    return *(v.elements + i);
}

def set(v: *Vec, i: i32, elem: *void): void {
    dbg.assert_fmt(i >= 0 && i < v.cap, "out of bounds set: %d", i);

    // sizeof(*v.elements) is already 8, so we don't need to multiply
    *(v.elements + i) = elem;
    // assume all values in between to be initialized
    if i >= v.len {
        v.len = i + 1;
    }
}

def resize_s(v: *Vec, size: i32): void {
    if size <= v.cap {
        return;
    }

    v.cap = size;
    if v.elements == null {
        v.elements = std.calloc(v.cap, sizeof **void) as **void;
    } else {
        v.elements = std.realloc(v.elements as *void, v.cap * sizeof **void) as **void;
        std.memset((v.elements + v.len) as *void, v.cap * sizeof **void, 0);
    }
}

def resize(v: *Vec): void {
    if v.elements == null {
        resize_s(v, 2);
    } else {
        resize_s(v, v.cap * 2);
    }
}

def free_v(v: *Vec): void {
    if v.elements == null {
        return;
    }
    delete v.elements;
}
