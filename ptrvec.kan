#include "std.h"

import "std";
import "io"; // TODO only debug

type Vec struct {
    len: i32,
    cap: i32,
    elements: **void
}

def create(): Vec {
    return Vec { len: 0, cap: 0, elements: null };
}

def with_cap(cap: i32): Vec {
    return Vec { len: 0, cap: cap, elements: std.calloc(cap, sizeof *void) as **void };
}

def is_empty(v: *Vec): bool {
    return v.len <= 0;
}

def pop(v: *Vec): *void {
    if !is_empty(v) {
        let elem = get(v, 0);
        v.len = v.len - 1;
        std.memmove(
            v.elements as *void,
            (v.elements + 1) as *void,
            v.len * sizeof **void
        );
        return elem;
    }
    return null;
}

def append(v: *Vec, other: *Vec): void {
    if is_empty(other) {
        return;
    }

    let new_len = v.len + other.len;
    resize_s(v, new_len);
    std.memcpy(
        (v.elements + v.len) as *void,
        other.elements as *void,
        other.len * sizeof *void
    );
    v.len = new_len;
}

def push_ptr(v: *Vec, elem: *void): void {
    if v.len + 1 > v.cap {
        resize(v);
    }

    *(v.elements + v.len) = elem;
    v.len = v.len + 1;
}

def get(v: *Vec, i: i32): *void {
    if i < v.len {
        return *(v.elements + i);
    }

    return null;
}

def set(v: *Vec, i: i32, elem: *void): void {
    if i < v.len {
        *(v.elements + i) = elem;
    }
}

def resize_s(v: *Vec, size: i32): void {
    size = size * sizeof **void;
    if size <= v.cap {
        return;
    }

    v.cap = size;
    if v.elements == null {
        v.elements = std.malloc(v.cap * sizeof **void) as **void;
    } else {
        v.elements = std.realloc(v.elements as *void, v.cap * sizeof **void) as **void;
    }
}

def resize(v: *Vec): void {
    if v.elements == null {
        resize_s(v, 2);
    } else {
        resize_s(v, v.cap * 2);
    }
}

def free_v(v: *Vec): void {
    delete v.elements;
}
