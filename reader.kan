import "vec";
import "std";
import "dbg";
import "path";
import "span";
import "file";
import "source";
import "error" as err;

extern def num_builtin_files(): i32;
extern def get_builtin_files(): *string;

type FileAddResult struct {
    file_name: string,
    err_code: err.CompileError
}

type FileMap struct {
    files: vec.Vec, // vec.Vec<source.SourceFile>
    // the largest shared path of all source files
    // Example:
    // The following files have a common root of '/home/'
    // /home/user/test.kan
    // /home/user/kantan/other.kan
    // /home/program.kan
    //
    // if we removed program.kan, the common root would be '/home/user/'
    proj_root: path.PathBuf
}

def create(): FileMap {
    return FileMap {
        files: vec.create(sizeof source.SourceFile),
        proj_root: path.buf_from(path.empty())
    };
}

def num_files(m: *FileMap): i32 {
    return m.files.len;
}

def get_ptr_by_idx(m: *FileMap, idx: i32): *source.SourceFile {
    return m.files.get_ptr(idx) as *source.SourceFile;
}

def get_ptr_from_span(m: *FileMap, span: span.Span): *source.SourceFile {
    // TODO(#60): this should use a binary search or some kind of tree

    let i = 0;
    while i < m.files.len {
        let file = get_ptr_by_idx(m, i);
        dbg.assert(file != null, "File was null");

        if span.start >= file.code && span.end <= file.code + file.len {
            return file;
        }

        i = i + 1;
    }

    return null;
}

def free_fm(m: *FileMap): void {
    let i = 0;
    while i < m.files.len {
        let s: source.SourceFile = undefined;
        if m.files.get(i, &s as *void) {
            source.free_sf(&s);
        }
        i = i + 1;
    }

    m.files.free();
    path.free_pb(&m.proj_root);
}

def add_std_lib(m: *FileMap, rel_path: *path.Path, std_dir: string): FileAddResult {
    let len = num_builtin_files();
    let file_names = get_builtin_files();

    let i = 0;
    while i < len {
        let file_name = *(file_names + i);
        let full_file_name = std.format_str("%s/%s", std_dir, file_name);

        let res = add_file(m, rel_path, full_file_name, true);
        if res.is_not_ok() {
            delete full_file_name;
            return FileAddResult { file_name: file_name, err_code: res };
        }

        let idx = num_files(m) - 1;
        let sptr = get_ptr_by_idx(m, idx);

        if sptr != null {
            let new_path = path.new_path_buf(file_name);
            file.free_f(&sptr.file);
            sptr.file.path = new_path;
        }

        delete full_file_name;

        i = i + 1;
    }

    return FileAddResult { file_name: null, err_code: err.CompileError.OK };
}

def add_all(m: *FileMap, rel_path: *path.Path, len: i32, file_names: *string): FileAddResult {
    // TODO(#31): detect duplicate files
    let i = 0;
    while i < len {
        let file_name = *(file_names + i);
        let res = add_file(m, rel_path, file_name, false);
        if res.is_not_ok() {
            return FileAddResult { file_name: file_name, err_code: res };
        }
        i = i + 1;
    }

    return FileAddResult { file_name: null, err_code: err.CompileError.OK };
}

def add_file(m: *FileMap, rel_path: *path.Path, name: string, is_std_lib: bool): err.CompileError {
    let p = path.empty();
    let res = path.from_str(name, &p);
    if res.is_not_ok() {
        return res;
    }

    let abs_path = path.buf_from(path.empty());
    let ret_val = path.merge_abs_rel(rel_path, &p, &abs_path);
    if ret_val.is_not_ok() {
        return ret_val;
    }

    let sf: source.SourceFile = undefined;
    if (res = source.read(abs_path, &sf, is_std_lib)).is_not_ok() {
        path.free_pb(&abs_path);
        return res;
    }

    m.files.push(&sf as *void);
    if !is_std_lib {
        update_root(m, abs_path.inner);
    }

    return err.CompileError.OK;
}

def update_root(m: *FileMap, p: path.Path): void {
    if m.proj_root.inner.len == 0 {
        let p = path.parent(&p);
        m.proj_root = path.new_path_buf_l(p.len, p.inner);
        return;
    }

    let common = path.common_parent(m.proj_root.inner, p);
    path.free_pb(&m.proj_root);
    m.proj_root = common;
}
