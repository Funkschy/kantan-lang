import "ident";
import "tyid";
import "map";
import "vec";
import "std";
import "span";
import "ty";

type Field struct {
    ident: ident.Ident,
    ty: tyid.Type
}

def empty_field(): Field {
    return Field { ident: ident.empty(), ty: tyid.empty() };
}

def create_field(ident: ident.Ident, ty: tyid.Type): Field {
    return Field { ident: ident, ty: ty };
}

// TODO(#82): replace with vmap.Map
type Fields struct {
    field_map: map.Map, // from ident to index into fields
    fields: vec.Vec // actual fields
}

def free_fields(fs: *Fields): void {
    map.free_m(&fs.field_map);
    fs.fields.free();
}

def create_fields(fields: vec.Vec): Fields {
    let field_map = map.with_cap(fields.len);

    for let i: usize = 0; i < fields.len; i += 1 {
        let field = empty_field();
        fields.get(i, &field as *void);

        let s = tyid.to_string(&field.ty);
        delete s;

        let key = map.key_from_ident(&field.ident);
        // add one, to be able to tell null apart from 0
        let index = std.int_to_ptr(i) + 1;

        map.insert(&field_map, key, index);
    }

    return Fields { field_map: field_map, fields: fields };
}

def fields_get_field_at(fs: *Fields, i: u32, dest: *Field): bool {
    return fs.fields.get(i as usize, dest as *void);
}

def fields_to_string(fs: *Fields): string {
    let fields = (new '\0') as string;

    for let i: u32 = 0; i < fs.fields.len as u32; i += 1 {
        let f = empty_field();
        if !fields_get_field_at(fs, i, &f) {
            delete fields;
            return null;
        }
        let n = ident.to_string(&f.ident);
        let t = tyid.to_string(&f.ty);

        let extra_len: usize = 2; // ': '
        if i > 0 {
            extra_len = 4; // ': ..., '
        }

        let new_len = std.strlen(fields) + std.strlen(n) + std.strlen(t) + 1 + extra_len;
        let new_fields = std.malloc(new_len) as string;
        let old_fields = fields;
        fields = std.strcpy(new_fields, fields);
        delete old_fields;

        if extra_len > 2 {
            fields = std.strcat(fields, ", ");
        }

        fields = std.strcat(fields, n);
        fields = std.strcat(fields, ": ");
        fields = std.strcat(fields, t);
        delete n;
        delete t;

        i = i + 1;
    }

    return fields;
}

type StructDecl struct {
    name: ident.Ident,
    fields: Fields,
    struct_ty: *ty.Type
}

def create_struct(name: ident.Ident, fields: vec.Vec): StructDecl {
    let fields = create_fields(fields);
    return StructDecl { name: name, fields: fields, struct_ty: null };
}

def (s: *StructDecl) free() {
    free_fields(&s.fields);
}

def (s: *StructDecl) num_fields(): u32 {
    return s.fields.fields.len as u32;
}

def (s: *StructDecl) field_at(i: u32, dest: *Field): bool {
    return fields_get_field_at(&s.fields, i, dest);
}

type UnionDecl struct {
    name: ident.Ident,
    fields: Fields,
    union_ty: *ty.Type
}

def create_union(name: ident.Ident, fields: vec.Vec): UnionDecl {
    let fields = create_fields(fields);
    return UnionDecl { name: name, fields: fields, union_ty: null };
}

def (s: *UnionDecl) free() {
    free_fields(&s.fields);
}

def (s: *UnionDecl) num_fields(): u32 {
    return s.fields.fields.len as u32;
}

def (s: *UnionDecl) field_at(i: u32, dest: *Field): bool {
    return fields_get_field_at(&s.fields, i, dest);
}

type EnumDecl struct {
    name: ident.Ident,
    values: vec.Vec, // vec.Vec<ident.Ident>
    enum_ty: *ty.Type
}

def create_enum(name: ident.Ident, values: vec.Vec): EnumDecl {
    return EnumDecl { name: name, values: values, enum_ty: null };
}

def (e: *EnumDecl) free() {
    e.values.free();
}
