import "map";
import "vec";
import "ty";
import "ident";
import "span";

type Scope struct {
    bindings: map.Map // ident to *Type
}

def create(): Scope {
    return Scope { bindings: map.create() };
}

def free_s(s: *Scope): void {
    map.free_m(&s.bindings);
}

def bind_in(
    s: *Scope,
    span_interner: *span.SpanInterner,
    ident: *ident.Ident,
    value: *ty.Type
): bool {
    return map.insert(
        &s.bindings,
        map.key_from_ident(span_interner, ident),
        value as *void
    );
}

def get_in(s: *Scope, span_interner: *span.SpanInterner, ident: *ident.Ident): *ty.Type {
    return map.get(&s.bindings, map.key_from_ident(span_interner, ident)) as *ty.Type;
}

type ScopeStack struct {
    scopes: vec.Vec, // vec of Scopes
    span_interner: *span.SpanInterner // redundant, but leads to a nicer interface
}

def empty_stack(): ScopeStack {
    return ScopeStack { scopes: vec.create(0), span_interner: null };
}

def create_stack(span_interner: *span.SpanInterner): ScopeStack {
    return ScopeStack {
        scopes: vec.create(sizeof Scope),
        span_interner: span_interner
    };
}

def free_stack(s: *ScopeStack): void {
    let i = 0;
    while i < num_scopes(s) {
        free_s(scope_at(s, i));
        i = i + 1;
    }
    vec.free_v(&s.scopes);
}

def open_scope(s: *ScopeStack): void {
    let scope = create();
    vec.push(&s.scopes, &scope as *void);
}

def close_scope(s: *ScopeStack): void {
    free_s(top(s));
    s.scopes.len = s.scopes.len - 1;
}

def scope_at(s: *ScopeStack, i: i32): *Scope {
    return vec.get_ptr(&s.scopes, i) as *Scope;
}

def top(s: *ScopeStack): *Scope {
    return scope_at(s, s.scopes.len - 1);
}

def bind(s: *ScopeStack, ident: *ident.Ident, value: *ty.Type): bool {
    return bind_in(top(s), s.span_interner, ident, value);
}

def num_scopes(s: *ScopeStack): i32 {
    return s.scopes.len;
}

def lookup(s: *ScopeStack, ident: *ident.Ident): *ty.Type {
    let i = num_scopes(s) - 1;
    while i >= 0 {
        let scope = scope_at(s, i);
        let ty: *ty.Type = null;
        if (ty = get_in(scope, s.span_interner, ident)) != null {
            return ty;
        }
        i = i - 1;
    }

    return null;
}
