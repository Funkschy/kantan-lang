import "path";
import "file";
import "span";
import "std";

type LineSpan struct {
    start_number: i32,
    span: span.BigSpan
}

type SourceFile struct {
    file: file.File,
    code: string
}

def empty(): SourceFile {
    return SourceFile { file: file.empty(), code: null };
}

def free_sf(sf: *SourceFile): void {
    delete sf.code;
    file.free_f(&sf.file);
}

def file_name_dup(sf: *SourceFile): string {
    return file.name_dup(&sf.file);
}

def code(sf: *SourceFile): string {
    return sf.code;
}

def read(p: path.PathBuf, f: *SourceFile): i32 {
    let file = file.create(p);
    let s: string = null;
    let res = file.read_to_string(&file, &s);

    if res != 0 {
        return res;
    }

    *f = SourceFile { file: file, code: s };

    return 0;
}

def find_line(
    span: *span.BigSpan,
    si: *span.SpanInterner,
    file: *SourceFile,
    last_nl_pos: *i32
): LineSpan {
    let lines = 1;
    let last_nl = span.start;

    let ptr = file.code + span.start;
    while ptr != file.code {
        if *ptr == '\n' {
            lines = lines + 1;

            if last_nl == span.start {
                last_nl = ptr - file.code;
            }
        }
        ptr = ptr - 1;
    }

    // there was no new line => span is in first line of file
    if last_nl == span.start {
        last_nl = -1; // we add a 1 later, which is correct in every other case
    }

    if last_nl_pos != null {
        *last_nl_pos = last_nl;
    }

    // the \n at the end of the line with span in it
    let next_nl = std.strchr(file.code + span.start + span.len, '\n');
    let span = span.create(si, last_nl + 1, next_nl - file.code, span.ctx);
    return LineSpan { start_number: lines, span: span.get(si, span) };
}

