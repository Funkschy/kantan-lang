import "io";
import "std";
import "ident";
import "span";

let hash_num: usize = 65599;

type Map struct {
    len: usize,
    cap: usize,
    items: *Item
}

type Iter struct {
    pos: usize,
    map: *Map
}

def iter_next(iter: *Iter): *Item {
    while iter.pos < iter.map.cap {
        let item = iter.map.items + iter.pos;
        iter.pos = iter.pos + 1;
        if item.key.value != null {
            return item;
        }
    }
    return null;
}

def iter(map: *Map): Iter {
    return Iter{ pos: 0, map: map };
}

type Key struct {
    len: usize,
    value: string
}

def create_key(len: usize, value: string): Key {
    return Key { len: len, value: value };
}

def key_from_ident(i: *ident.Ident): Key {
    return create_key(ident.len(i), ident.start(i));
}

type Item struct {
    key: Key,
    value: *void
}

def create_item(key: Key, value: *void): Item {
    return Item { key: key, value: value };
}

def create(): Map {
    return Map { len: 0, cap: 0, items: null };
}

def with_cap(cap: usize): Map {
    if cap == 0 {
        return Map { len: 0, cap: 0, items: null };
    }

    cap = std.next_pow_of_2(cap as i64) as usize;

    let items = std.calloc(cap, sizeof Item) as *Item;
    return Map { len: 0, cap: cap, items: items };
}

def free_m(m: *Map) {
    if m.items == null {
        return;
    }

    delete m.items;
}

def key_eq(first: Key, second: Key): bool {
    if first.len != second.len {
        return false;
    }

    return std.strncmp(first.value, second.value, first.len) == 0;
}

def insert_all(map: *Map, other: *Map) {
    for let i: usize = 0; i < other.cap; i += 1 {
        let item = other.items + i;
        if item.key.value != null {
            insert(map, item.key, item.value);
        }
    }
}

def hash(key: string, len: usize): usize {
    let h: usize = 0;
    for let i: usize = 0; i < len; i += 1 {
        h = h * hash_num + (*(key + i) as usize);
    }
    return h;
}

def (m: *Map) get_map_index(key: string, len: usize): usize {
    let h = hash(key, len);
    return h & (m.cap - 1);
}

// inserts value into map at key
// returns the replaced value or null
def insert(map: *Map, key: Key, value: *void): *void {
    if map.items == null || load_factor(map) > 0.75 {
        resize(map);
    }

    let index = map.get_map_index(key.value, key.len);
    let item = map.items + index;

    // empty place
    if item.key.value == null {
        *item = create_item(key, value);
        map.len = map.len + 1;
        return null;
    }

    // overwrite
    if key_eq(item.key, key) {
        let old_val = item.value;
        item.value = value;
        return old_val;
    }

    let replaced: *void = null;
    // linear probing
    let n = map.cap + index;
    let mask = map.cap - 1;
    for let i = index + 1; i < n; i += 1 {
        item = map.items + (i & mask);

        if item.key.value == null || key_eq(item.key, key) {
            if item.key.value != null {
                replaced = item.value;
            }

            *item = create_item(key, value);
            map.len += 1;
            break;
        }
    }

    return replaced;
}

def load_factor(map: *Map): f32 {
    if map.cap == 0 {
        return 0.0;
    }

    return map.len as f32 / (map.cap as f32);
}

def resize(map: *Map) {
    let cap = map.cap * 2;
    if cap == 0 {
        cap = 4;
    }

    let new_map = with_cap(cap);
    insert_all(&new_map, map);
    free_m(map);
    *map = new_map;
}

def get(map: *Map, key: Key): *void {
    let item = get_item(map, key);
    if item == null {
        return null;
    }
    return item.value;
}

def get_item(map: *Map, key: Key): *Item {
    if map.items == null {
        return null;
    }

    let index = map.get_map_index(key.value, key.len);
    let item = map.items + index;

    if item.key.value != null && key_eq(item.key, key) {
        return item;
    }

    let n = map.cap + index;
    let mask = map.cap - 1;
    for let i = index + 1; i < n; i += 1 {
        item = map.items + (i & mask);
        if item.key.value != null && key_eq(item.key, key) {
            return item;
        }
    }

    return null;
}

def get_and_remove(map: *Map, key: Key): *void {
    let item = get_item(map, key);
    if item == null {
        return null;
    }

    let value = item.value;
    std.memset(item as *void, 0, sizeof Item);
    map.len = map.len - 1;
    return value;
}

def dump(map: *Map) {
    let iter = iter(map);
    let item = iter_next(&iter);
    while item != null {
        io.printf("%.*s: %p\n", item.key.len, item.key.value, item.value);
        item = iter_next(&iter);
    }
}
