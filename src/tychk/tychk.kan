import "../ty";
import "../str";
import "../ast";
import "../vec";
import "../mod";
import "../map";
import "../dbg";
import "../span";
import "../tyid";
import "../name";
import "../path";
import "../func";
import "../error";
import "../scope";
import "../ident";
import "../escape";
import "../config";
import "../record";
import "../ptrvec";
import "../symbol";
import "../modsort" as ms;

import "lookup";
import "waiting";

import "../std";
// TODO(#21): only for debug purposes
import "io";

extern def stmt2str(kind: i32): string;

type Result enum {
    OK, Error
}

def (r: Result) is_ok(): bool {
    return r == Result.OK;
}

def (r: Result) is_error(): bool {
    return r == Result.Error;
}

def (r: *Result) and_eq(other: Result) {
    if (*r).is_ok() && other.is_ok() {
        *r = Result.OK;
    } else {
        *r = Result.Error;
    }
}

let error_ty_name = "__error_ty__";

type PassMode enum {
    TypeDecl, FuncAndGlobalDecl, Real
}

type TypeError struct {
    text: string,
    span: span.Span
}

def err(tc: *TypeChecker, text: string, span: span.Span): TypeError {
    return TypeError { text: text, span: span };
}

def free_err(err: *TypeError) {
    delete err.text;
}

type Ctx struct {
    in_loops: i32,
    mod: *mod.Module,
    current_func: *ty.Func, // the function that is currently being resolved (or null)
    imports: map.Map, // <string, *mod.Module>
    values: scope.ScopeStack,
    types: scope.ScopeStack
}

def create_ctx(mod: *mod.Module, global_types: *scope.Scope, global_values: *scope.Scope): *Ctx {
    let values = scope.create_stack();
    scope.push_scope(&values, global_values);
    scope.push_scope(&values, ty.get_value_scope(mod.ty));

    let types = scope.create_stack();
    scope.push_scope(&types, global_types);
    scope.push_scope(&types, ty.get_type_scope(mod.ty));

    return new Ctx {
        in_loops: 0,
        mod: mod,
        current_func: null,
        imports: map.create(),
        values: values,
        types: types
    };
}

def free_ctx(ctx: *Ctx) {
    scope.free_stack(&ctx.types, 2);
    scope.free_stack(&ctx.values, 2);
    ctx.imports.free();
    delete ctx;
}

def get_mod_by_alias(ctx: *Ctx, alias_len: usize, alias: string): *mod.Module {
    return ctx.imports.get(map.create_key(alias_len, alias)) as *mod.Module;
}

type TypeChecker struct {
    pass: PassMode,
    config: *config.Config,
    mods: *mod.Map,
    sorted_mods: *u32,
    ctx: *Ctx,
    main_func: *ty.Type,
    types: ptrvec.Vec,
    global_types: scope.Scope,
    global_values: scope.Scope,
    errors: vec.Vec, // <TypeError>
    requests: vec.Vec, // Vec<waiting.RequestMap> indexed by mod idx
    contexts: ptrvec.Vec
}

def (tc: *TypeChecker) in_loop(): bool {
    return tc.ctx.in_loops > 0;
}

def (tc: *TypeChecker) enter_loop() {
    tc.ctx.in_loops += 1;
}

def (tc: *TypeChecker) exit_loop() {
    dbg.assert(tc.ctx.in_loops > 0, "leaving non-existing loop");
    tc.ctx.in_loops -= 1;
}

// Basically the stuff, that is not freed after the typechecker is done
type CheckResult struct {
    had_errors: bool,
    types: ptrvec.Vec,
    mods: *mod.Map,
    global_types: scope.Scope,
    main_func: *ty.Type
}

def empty_result(): CheckResult {
    return create_result(false, ptrvec.create(), null, scope.create(), null);
}

def create_result(
    had_errors: bool,
    types: ptrvec.Vec,
    mods: *mod.Map,
    global_types: scope.Scope,
    main_func: *ty.Type
): CheckResult {
    return CheckResult {
        had_errors: had_errors,
        types: types,
        mods: mods,
        global_types: global_types,
        main_func: main_func
    };
}

def free_result(r: *CheckResult) {
    for let i: usize = 0; i < r.types.len; i += 1 {
        ty.free_ty(r.types.get(i) as *ty.Type);
    }

    r.types.free();
    scope.free_s(&r.global_types);
}

def create_err_result(tc: *TypeChecker): CheckResult {
    return create_result(true, tc.types, tc.mods, tc.global_types, null);
}

def create_check_result(tc: *TypeChecker): CheckResult {
    return create_result(num_errs(tc) > 0, tc.types, tc.mods, tc.global_types, tc.main_func);
}

def create(mods: *mod.Map, config: *config.Config): TypeChecker {
    let num_mods = mod.num_mods(mods) as usize;

    let tc = TypeChecker {
        pass: PassMode.TypeDecl,
        config: config,
        mods: mods,
        sorted_mods: sorted_mods(mods),
        ctx: null,
        main_func: null,
        types: ptrvec.with_cap(256),
        global_types: scope.create(),
        global_values: scope.create(),
        errors: vec.create(sizeof TypeError),
        requests: vec.with_cap(sizeof waiting.RequestMap, num_mods),
        contexts: ptrvec.with_cap(num_mods)
    };
    tc.requests.init_zero();

    tc.global_types = create_global_types_scope(&tc);
    tc.global_values = create_global_values_scope(&tc, &tc.global_types);
    return tc;
}

def get_ctx(tc: *TypeChecker, idx: u32): *Ctx {
    return tc.contexts.unsafe_get(idx as usize) as *Ctx;
}

def check(tc: *TypeChecker): CheckResult {
    let error = false;

    // first init all modules, since the waiting system expects this
    let n = mod.num_mods(tc.mods);
    for let i: u32 = 0; i < n; i += 1 {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        error = error || init_mod(tc, m, idx);
    }

    // the decl only pass
    // TODO(#27): dont check stdlib if not needed
    for let i: u32 = 0; i < n; i += 1 {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        if check_mod(tc, m, idx, PassMode.TypeDecl).is_error() {
            error = true;
        }
    }

    if tc.errors.len > 0 {
        error = true;
    }

    // check for pending waitingrequests in all mods
    for let i: u32 = 0; i < n; i += 1 {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);
        tc.ctx = get_ctx(tc, idx);

        // resolve missing imports.
        // This needs to be done for unqualified imports for struct fields
        let num_imports = m.num_imports() as usize;
        for let j: usize = 0; j < num_imports; j += 1 {
            let imp = ast.as_import_stmt(m.import_at(j));
            if imp.is_qualified() || imp.mod_ty == null {
                continue;
            }

            let mod_ty = ty.as_mod(imp.mod_ty);

            let iter = mod_ty.types.iter();
            for let imported = iter.next(); imported.present(); imported = iter.next() {
                let imported_ty = imported.symbol.ty_or_null();
                bind_type_private(tc, &imported.name, imported_ty);

                if !(imported_ty.is_user_defined() || imported_ty.is_signature_pointer()) {
                    continue;
                }

                let original_name: ident.Ident = undefined;
                if imported_ty.is_signature_pointer() {
                    let sig = ty.as_signature(imported_ty.as_ptr().inner);
                    original_name = sig.name;
                } else {
                    let user_defined = imported_ty.get_user_defined();
                    original_name = user_defined.original_name;
                }

                // TODO: this feels like a dirty hack
                ty.tychk_untouch(imported_ty);
                waiting.update_all(
                    tc,
                    // use the current module as 'declared in' since the waiting types
                    // did not see any module prefix and therefore wait for a type in
                    // the same module
                    m,
                    imported_ty,
                    &original_name
                );
            }
        }

        let wrm = tc.get_waiting_map(m);
        let iter = wrm.request_map.iter();
        let next = iter.next();

        while next != null {
            let incomplete_ty = m.lookup_type(next.key.len, next.key.value).sym.ty;
            if incomplete_ty != null {
                dbg.assert(
                    ty.is_struct(incomplete_ty) || ty.is_union(incomplete_ty),
                    "incomplete_ty was neither struct nor union"
                );

                let s_ty = ty.as_struct(incomplete_ty);
                push_incomplete_ty_error(tc, &s_ty.super.original_name);
                error = true;
            } else {
                let idx = std.ptr_to_int(next.value) - 1;
                let pending = wrm.requests.get_ptr(idx) as *vec.Vec;
                dbg.assert(pending != null, "pending was null");

                for let j: usize = 0; j < pending.len; j += 1 {
                    let req = pending.get_ptr(j) as *waiting.Request;
                    push_not_defined_error(tc, &req.waiting_for, lookup.Kind.Types.to_string(), null);
                    error = true;
                }
            }

            next = iter.next();
        }
    }

    for let i: u32 = 0; i < n; i += 1 {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        if check_mod(tc, m, idx, PassMode.FuncAndGlobalDecl).is_error() {
            error = true;
        }
    }

    if tc.errors.len > 0 {
        error = true;
    }

    // don't execute real pass if there are already errors
    if error {
        return create_err_result(tc);
    }

    // the real pass
    for let i: u32 = 0; i < n; i += 1 {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        check_mod(tc, m, idx, PassMode.Real);
    }

    return create_check_result(tc);
}

def init_mod(tc: *TypeChecker, m: *mod.Module, idx: u32): bool {
    dbg.assert(m.ty == null, "mod type should be null");
    let p = mod.get_path(m);
    // io.printf("DBG: Initializing (%d) %.*s\n", idx, p.len, p.inner);

    let ty = ty.new_mod(m.name.ref());
    m.ty = ty;

    let ctx = create_ctx(m, &tc.global_types, &tc.global_values);
    tc.contexts.set(idx as usize, ctx as *void);
    tc.ctx = ctx;

    return false;
}

def check_mod(tc: *TypeChecker, m: *mod.Module, idx: u32, mode: PassMode): Result {
    dbg.assert(m.ty != null, "mod type should not be null");

    let ctx = get_ctx(tc, idx);
    dbg.assert(ctx != null, "ctx should not be null");

    tc.ctx = ctx;
    tc.pass = mode;

    let ret = Result.OK;

    for let i: usize = 0; i < mod.num_stmts(m); i += 1 {
        let stmt = mod.get_stmt_at(m, i);
        // templates are added to the end of the ast, so as soon as we see one, we can stop
        // typechecking
        if stmt.is_expanded_template {
            break;
        }

        let result = check_stmt(tc, stmt);

        if result != null {
            mod.set_stmt_at(m, i, result);
        } else {
            ret = Result.Error;
        }
    }

    return ret;
}

def (tc: *TypeChecker) get_waiting_map(mod: *mod.Module): *waiting.RequestMap {
    return tc.requests.get_ptr(mod.idx as usize) as *waiting.RequestMap;
}

def create_global_types_scope(tc: *TypeChecker): scope.Scope {
    // this is included in every module, so the visibility does not matter anyway
    let public = symbol.Visibility.Public;
    let ptr_width = tc.config.target.ptr_width_bytes;

    // TODO(#32): this should probably be defined in something like a builtin.kan
    let global = scope.create();
    let i8_ty = push_tmp_ty(tc, ty.new_integer(1, true, false));
    global.bind(2, "i8", i8_ty, public);
    global.bind(3, "i16", push_tmp_ty(tc, ty.new_integer(2, true, false)), public);
    global.bind(3, "i32", push_tmp_ty(tc, ty.new_integer(4, true, false)), public);
    global.bind(3, "i64", push_tmp_ty(tc, ty.new_integer(8, true, false)), public);
    global.bind(5, "isize", push_tmp_ty(tc, ty.new_integer(ptr_width, true, true)), public);

    global.bind(2, "u8", push_tmp_ty(tc, ty.new_integer(1, false, false)), public);
    global.bind(3, "u16", push_tmp_ty(tc, ty.new_integer(2, false, false)), public);
    global.bind(3, "u32", push_tmp_ty(tc, ty.new_integer(4, false, false)), public);
    global.bind(3, "u64", push_tmp_ty(tc, ty.new_integer(8, false, false)), public);
    global.bind(5, "usize", push_tmp_ty(tc, ty.new_integer(ptr_width, false, true)), public);

    global.bind(3, "f32", push_tmp_ty(tc, ty.new_f32()), public);
    global.bind(3, "f64", push_tmp_ty(tc, ty.new_f64()), public);

    global.bind(6, "string", push_tmp_ty(tc, ty.new_ptr(ptr_width, i8_ty)), public);

    global.bind(4, "void", push_tmp_ty(tc, ty.new_void()), public);
    global.bind(std.strlen(error_ty_name), error_ty_name, push_tmp_ty(tc, ty.new_error()), public);

    let bool_ty = push_tmp_ty(tc, ty.new_bool());
    global.bind(4, "bool", bool_ty, public);

    return global;
}

def create_global_values_scope(tc: *TypeChecker, global_types: *scope.Scope): scope.Scope {
    let global = scope.create();
    let bool_ty = global_types.get(4, "bool").sym.ty;
    global.bind(4, "true", bool_ty, symbol.Visibility.Public);
    global.bind(5, "false", bool_ty, symbol.Visibility.Public);

    return global;
}

def get_global_type(tc: *TypeChecker, len: usize, name: string): *ty.Type {
    // the return value of this is never checked, but since it isn't user supplied, it should
    // be correct anyway
    return tc.global_types.get(len, name).sym.ty;
}

def num_errs(tc: *TypeChecker): usize {
    return tc.errors.len;
}

def push_err(tc: *TypeChecker, error: TypeError) {
    tc.errors.push(&error as *void);
}

def push_mk_err(tc: *TypeChecker, text: string, span: span.Span) {
    let error = err(tc, text, span);
    tc.errors.push(&error as *void);
}

def get_err(tc: *TypeChecker, i: usize): *TypeError {
    return tc.errors.get_ptr(i) as *TypeError;
}

def add_import_alias(tc: *TypeChecker, ident: *ident.Ident, mod: *mod.Module) {
    tc.ctx.imports.insert(map.key_from_ident(ident), mod as *void);
}

// sorts the mods after the number of imports inside
def sorted_mods(mods: *mod.Map): *u32 {
    let num_mods = mod.num_mods(mods);
    let import_nums = std.malloc(num_mods as usize * sizeof u32) as *u32;

    for let i: u32 = 0; i < num_mods; i += 1 {
        let m = mod.get_mod(mods, i);
        *(import_nums + i) = m.num_imports();
    }

    let sorted_mods = ms.sort(import_nums, num_mods);
    delete import_nums;

    return sorted_mods;
}

def (tc: *TypeChecker) create_ptr_ty(inner: *ty.Type): *ty.Type {
    let ptr_width = tc.config.target.ptr_width_bytes;
    return push_tmp_ty(tc, ty.new_ptr(ptr_width, inner));
}

def (tc: *TypeChecker) create_array_ty(len: i64, inner: *ty.Type): *ty.Type {
    return push_tmp_ty(tc, ty.new_array(len, inner));
}

def (tc: *TypeChecker) create_slice_ty(inner: *ty.Type): *ty.Type {
    let ptr_width = tc.config.target.ptr_width_bytes;
    return push_tmp_ty(tc, ty.new_slice(ptr_width, inner));
}

def check_func_tyid(tc: *TypeChecker, signature: *ty.Type, id: *tyid.Type, out: **ty.Type): Result {
    let data = lookup.resolve_tyid(tc, id);
    if data.error || !data.found_type {
        return Result.Error;
    }

    *out = data.ty;
    return Result.OK;
}

def fill_func_def(tc: *TypeChecker, f_decl: *func.FuncDef, signature: *ty.Type): Result {
    // only needed for type params, but not harmful otherwise
    open_scope(tc);
    defer close_scope(tc);

    let f_ty: *ty.Func = null;
    if signature.is_template() {
        let template = signature.as_template();
        f_ty = ty.as_func(template.inner);

        for let i: usize = 0; i < template.type_params.len; i += 1 {
            let param = template.type_param_at(i);
            bind_type_public(tc, &param.as_template_param().name, param);
        }
    } else {
        f_ty = ty.as_func(signature);
    }

    let result = Result.OK;
    let ret_ty: *ty.Type = null;

    // no return type == implicit void
    if f_decl.ret_ty.is_empty() {
        ret_ty = get_global_type(tc, 4, "void");
    } else {
        result.and_eq(check_func_tyid(tc, signature, &f_decl.ret_ty, &ret_ty));
    }

    let receiver_ty: *ty.Type = null;
    if f_decl.is_method() {
        f_ty.is_method = true;
        result.and_eq(check_func_tyid(tc, signature, &f_decl.receiver.ty, &receiver_ty));

        if result.is_ok() {
            // You can only declare methods on user defined types (not on stuff like i32, f32 ...)
            if !receiver_ty.is_user_defined() {
                let span = f_decl.receiver.ty.span();
                push_primitive_receiver_type_error(tc, receiver_ty, span);
                result = Result.Error;
            } else if ty.bind_method(receiver_ty, f_decl.name, signature) {
                push_duplicate_def_error(tc, &f_decl.name);
            }
        }
    }

    let num_params = f_decl.num_params();
    let params = vec.with_cap(sizeof ty.Param, num_params as usize);

    for let i: u32 = 0; i < num_params; i += 1 {
        let p = f_decl.get_param_ptr(i);

        // TODO(#37): handle varargs
        if func.is_varargs_param(p) {
            f_ty.is_varargs = true;
            continue;
        }

        let data = lookup.resolve_tyid(tc, &p.ty);
        if data.error || !data.found_type {
            result = Result.Error;
            continue;
        }

        let is_aggregate_type = ty.is_struct(data.ty) || ty.is_union(data.ty);
        if is_aggregate_type && f_ty.is_extern && !p.ty.is_ptr() {
            // TODO(#121): implement proper argument/return type coercion
            // Trying to pass an aggregate type to an extern function
            let s = "Kantan currently does not implement the C abi, so you cannot pass a struct to a c function";
            push_internal_error(tc, p.ty.span(), s);
            result = Result.Error;
        }

        if !ty.is_sized(data.ty) {
            push_unsized_param_error(tc, data.ty, p.ty.span());
            result = Result.Error;
        }

        let f_param = ty.create_param(p.name, data.ty);
        params.push(&f_param as *void);
    }

    if result.is_ok() {
        f_ty.params = params;
        f_ty.ret = ret_ty;
        f_ty.receiver = ty.Param { name: f_decl.receiver.name, ty: receiver_ty };
    } else {
        params.free();
        return Result.Error;
    }

    return Result.OK;
}

def push_tmp_ty(tc: *TypeChecker, ty: *ty.Type): *ty.Type {
    tc.types.push_ptr(ty as *void);
    return ty;
}

def open_scope(tc: *TypeChecker) {
    scope.open_scope(&tc.ctx.types);
    scope.open_scope(&tc.ctx.values);
}

def close_scope(tc: *TypeChecker) {
    scope.close_scope(&tc.ctx.types);
    scope.close_scope(&tc.ctx.values);
}

def bind_type_public(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_public(&tc.ctx.types, ident, ty);
}

def bind_type_private(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_private(&tc.ctx.types, ident, ty);
}

def bind_value_public(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_public(&tc.ctx.values, ident, ty);
}

def bind_value_private(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_private(&tc.ctx.values, ident, ty);
}

type FieldState enum { None, Error, Waiting }

def (tc: *TypeChecker) check_field(
    t: *ty.Type,
    field_name: ident.Ident,
    field_tyid: *tyid.Type,
    offset: i32
): FieldState {
    let data = lookup.resolve_tyid(tc, field_tyid);

    if data.error {
        // push fake field here, so that the offset is not out of bounds
        tc.push_field_into_ty(t, field_name, null);
        return FieldState.Error;
    }

    // pointers are ok, because their size is known
    let is_ptr = field_tyid.is_ptr();
    if !data.found_type {
        waiting.wait_for_field(tc, data.module, field_name, field_tyid, offset, t);
        if !is_ptr {
            return FieldState.Waiting;
        }

        return FieldState.None;
    }

    let field_ty = data.ty;
    let is_user_defined = field_ty.is_user_defined();
    if ty.is_initialized(field_ty) {
        defer tc.push_field_into_ty(t, field_name, field_ty);

        if !ty.is_sized(field_ty) {
            push_unsized_field_error(tc, field_ty, field_tyid.span());
            return FieldState.Error;
        }

        return FieldState.None;
    } else if is_user_defined {
        // a user defined type that has not been initialized
        waiting.wait_for_field(tc, data.module, field_name, field_tyid, offset, t);
        if !is_ptr {
            return FieldState.Waiting;
        }
    } else {
        // struct types should be the only uninitialized
        push_internal_error(tc, field_name.span, "reached unreachable code");
        return FieldState.Error;
    }
}

// TODO(#122): remove this, when we have either function pointers or generics
def (tc: *TypeChecker) push_field_into_ty(
    structured_type: *ty.Type,
    field_name: ident.Ident,
    field_ty: *ty.Type
) {
    if ty.is_struct(structured_type) {
        if ty.push_field(ty.as_struct(structured_type), field_name, field_ty) {
            push_duplicate_def_error(tc, &field_name);
        }
    } else if ty.is_union(structured_type) {
        if ty.as_union(structured_type).push_field(field_name, field_ty) {
            push_duplicate_def_error(tc, &field_name);
        }
    }
}

def fill_struct_fields(tc: *TypeChecker, s_decl: *record.StructDecl, t: *ty.Type) {
    let s_ty = ty.as_struct(t);

    // let s = ident.to_string(&s_decl.name);
    // io.printf("----\nDBG: resolving %s\n", s);
    // delete s;

    let error = false;
    let is_waiting = false;

    let nf = s_decl.num_fields();
    s_ty.fields = vec.with_cap(sizeof ty.StructField, nf as usize);
    for let i: u32 = 0; i < nf; i += 1 {
        let f = record.empty_field();
        if !s_decl.field_at(i, &f) {
            push_internal_error(tc, s_decl.name.span, "could not get field");
            return;
        }

        let field_name = f.ident;
        let field_tyid = &f.ty;

        let state = tc.check_field(t, field_name, field_tyid, i as i32);
        error |= state == FieldState.Error;
        is_waiting |= state == FieldState.Waiting;
    }

    if !error && !is_waiting {
        ty.fill_width_align(t);
        waiting.update_all(tc, tc.ctx.mod, t, &s_ty.super.original_name);
    }
}

def fill_union_fields(tc: *TypeChecker, s_decl: *record.UnionDecl, t: *ty.Type) {
    let u_ty = ty.as_union(t);

    let error = false;
    let is_waiting = false;

    let nf = s_decl.num_fields();
    u_ty.fields = vec.with_cap(sizeof ty.UnionField, nf as usize);
    for let i: u32 = 0; i < nf; i += 1 {
        let f = record.empty_field();
        if !s_decl.field_at(i, &f) {
            push_internal_error(tc, s_decl.name.span, "could not get field");
            return;
        }

        let field_name = f.ident;
        let field_tyid = &f.ty;

        let state = tc.check_field(t, field_name, field_tyid, i as i32);
        error |= state == FieldState.Error;
        is_waiting |= state == FieldState.Waiting;
    }

    if !error && !is_waiting {
        ty.fill_width_align(t);
        waiting.update_all(tc, tc.ctx.mod, t, &u_ty.super.original_name);
    }
}

def get_import_alias(tc: *TypeChecker, imp: *ast.ImportStmt): ident.Ident {
    if ast.import_has_alias(imp) {
        return imp.alias;
    }

    let p = path.empty();
    let import_ident = imp.mod;

    // if the imported path starts with ':' we use the projects base path as our absolute path
    // instead of the current module
    // so we have to remove it here or otherwise the alias would include ':'
    if import_ident.index_of(':') == 0 {
        import_ident = import_ident.drop(1);
    }

    if path.from_str_len(import_ident.start(), import_ident.len(), &p).is_not_ok() {
        return ident.empty();
    }

    let lsp = path.last_separator_ptr(&p);
    if lsp == null {
        // there is no separator
        return import_ident;
    }
    lsp = lsp + 1; // skip the actual separator

    let offset = lsp - p.inner;
    let start = import_ident.start() + offset;
    let end = start + p.len - offset;

    let new_span = span.create(start, end);
    return ident.from_span(new_span);
}

def check_import(
    tc: *TypeChecker,
    i_s: *ast.ImportStmt,
    out_alias: *ident.Ident,
    out_ty: **ty.Type
): bool {
    let error: string = null;
    let imported_mod = mod.try_get_mod_from_import(
        tc.mods,
        tc.ctx.mod,
        i_s,
        &error
    );

    // no such module
    if imported_mod == null {
        // TODO(#45): for some reason this error is sometimes duplicated
        //  to recreate, just import a non existing file
        push_mk_err(tc, error, i_s.mod.span);
        return false;
    }

    let mod_ty = imported_mod.ty;
    dbg.assert(mod_ty != null, "mod_ty should not be null");
    *out_ty = mod_ty;

    if i_s.is_qualified() {
        let alias = get_import_alias(tc, i_s);
        if ident.start(&alias) == null {
            push_internal_error(tc, i_s.mod.span, "import alias was empty");
            return false;
        }

        add_import_alias(tc, &alias, imported_mod);
        *out_alias = alias;
    }

    return true;
}

def check_struct_decl(tc: *TypeChecker, sd: *record.StructDecl): *ty.Type {
    let ty = declare_struct(tc, sd);
    if ty == null {
        return null;
    }

    fill_struct_fields(tc, sd, ty);
    return ty;
}

// TODO(#103): remove duplicated code
def declare_struct(tc: *TypeChecker, sd: *record.StructDecl): *ty.Type {
    let prev = lookup.type_name(tc, &sd.name);
    if prev.present() {
        push_duplicate_def_error(tc, &sd.name);
        return null;
    }

    let definition = ty.new_type(ty.Kind.Struct, null);
    push_tmp_ty(tc, definition);

    let owned_name = mangle_type_name(tc, &sd.name);
    ty.init_struct(definition, sd.name, owned_name, tc.ctx.mod);
    return definition;
}

def check_union_decl(tc: *TypeChecker, sd: *record.UnionDecl): *ty.Type {
    let ty = declare_union(tc, sd);
    if ty == null {
        return null;
    }

    fill_union_fields(tc, sd, ty);
    return ty;
}

def declare_union(tc: *TypeChecker, sd: *record.UnionDecl): *ty.Type {
    let prev = lookup.type_name(tc, &sd.name);
    if prev.present() {
        push_duplicate_def_error(tc, &sd.name);
        return null;
    }

    let definition = ty.new_type(ty.Kind.Union, null);
    push_tmp_ty(tc, definition);

    let owned_name = mangle_type_name(tc, &sd.name);
    ty.init_union(definition, sd.name, owned_name, tc.ctx.mod);
    return definition;
}

// This is just temporary until compile time code execution is working, so it's not part of std.kan
extern def strtol(start: string, end: *string, base: i32): i64;

def check_enum_decl(tc: *TypeChecker, decl_stmt: *ast.EnumDeclStmt): *ty.Type {
    let ed = &decl_stmt.decl;
    let decl = declare_enum(tc, ed);
    if decl == null {
        return null;
    }

    let e_ty = ty.as_enum(decl);
    let start_value = 0;

    if decl_stmt.start_value != null {
        let init = check_expr(tc, decl_stmt.start_value);
        if init == null {
            return null;
        }

        // TODO(#123): allow enums of i64, i16...
        // currently only i32, no other integer types
        if !(init.ty.is_integer() && init.ty.width == 4) {
            push_invalid_enum_start_value_error(tc, e_ty, init);
            return null;
        }

        if !ast.is_int_expr(decl_stmt.start_value) {
            push_internal_error(
                tc,
                decl_stmt.start_value.span,
                "The compiler cannot handle arbitrary enum start value expressions yet"
            );
        }

        let value_span = decl_stmt.start_value.span;
        let literal_len = span.len(value_span);
        let value_end = value_span.end;
        // this does no error checks, since the lexer/parser should ensure the correctness.
        start_value = strtol(value_span.start, &value_end, 10) as i32;
    }

    for let i: usize = 0; i < ed.values.len; i += 1 {
        let name: ident.Ident = undefined;
        ed.values.get(i, &name as *void);
        if ty.push_enum_value(decl, name, start_value + i as i32) {
            push_duplicate_enum_value_error(tc, e_ty, &name);
            return null;
        }
    }

    waiting.update_all(tc, tc.ctx.mod, decl, &e_ty.super.original_name);
    return decl;
}

def declare_enum(tc: *TypeChecker, ed: *record.EnumDecl): *ty.Type {
    // since enum names are values and types at the same time, we have to check for name
    // collisions with values and types aswell
    let prev = lookup.type_name(tc, &ed.name);
    if !prev.present() {
        prev = lookup.value_name(tc, &ed.name);
    }
    if prev.present() {
        push_duplicate_def_error(tc, &ed.name);
        return null;
    }

    let definition = ty.new_type(ty.Kind.Enum, null);
    push_tmp_ty(tc, definition);

    let owned_name = mangle_type_name(tc, &ed.name);
    // currently, all enums are just i32 values
    let base_type = get_global_type(tc, 3, "i32");
    ty.init_enum(definition, ed.name, owned_name, tc.ctx.mod, base_type);
    return definition;
}

// runs in PassMode.TypeDecl
def declare_func(tc: *TypeChecker, function: *ast.Stmt): *ty.Type {
    let fd = &ast.as_func_decl_stmt(function).decl;

    if !fd.is_method() && lookup.value_name(tc, &fd.name).present() {
        push_duplicate_def_error(tc, &fd.name);
        return null;
    }

    let signature = ty.new_type(ty.Kind.Signature, null);
    push_tmp_ty(tc, signature);

    let mangled_name = mangle_func_name(tc, fd);
    ty.init_signature(signature, fd.name, mangled_name, tc.ctx.mod, fd.is_extern());

    let is_main = fd.is_main();
    if is_main {
        if tc.main_func != null {
            // TODO(#94): custom error for duplicated main function
            //  with reference to original
            push_duplicate_def_error(tc, &fd.name);
            return null;
        }

        tc.main_func = signature;
        let sig = ty.as_signature(signature);

        // "demangle" main name
        name.free_owned(&sig.mangled_name);
        sig.mangled_name = name.make_copied(4, "main");
    }

    if fd.num_type_params() > 0 {
        if is_main {
            // TODO: add proper error
            push_internal_error(tc, fd.name.span, "main function may not be generic");
            return null;
        }

        signature = push_tmp_ty(tc, ty.new_template(signature, function, &fd.type_params));
    }

    return signature;
}

// runs in PassMode.FuncAndGlobalDecl
def check_func_decl(tc: *TypeChecker, fd: *func.FuncDef): *ty.Type {
    let signature = fd.signature;
    if signature == null {
        return null;
    }

    if fill_func_def(tc, fd, signature).is_error() {
        return null;
    }

    return signature;
}

def check_func_body(tc: *TypeChecker, f_s: *ast.FuncDeclStmt): *ast.BlockStmt {
    let f_name = &f_s.decl.name;
    let f_ty = f_s.decl.signature;

    if f_ty == null {
        push_not_defined_error(tc, f_name, lookup.Kind.Values.to_string(), null);
        return null;
    }

    if !ty.is_func(f_ty) {
        push_internal_error(tc, f_name.span, "type is not a function");
        return null;
    }

    let f_ty = ty.as_func(f_ty);
    if !ty.func_is_initalized(f_ty) {
        // in this case, an error will be pushed later
        return null;
    }

    let last_func = tc.ctx.current_func;
    tc.ctx.current_func = f_ty;
    open_scope(tc);
    defer close_scope(tc);

    if f_ty.is_method {
        bind_value_public(tc, &f_ty.receiver.name, f_ty.receiver.ty);
    }

    // bind params
    for let i: u32 = 0; i < f_ty.num_params(); i += 1 {
        let p = f_ty.param_at(i);
        bind_value_public(tc, &p.name, p.ty);
    }

    if f_s.block == null {
        push_internal_error(tc, f_s.decl.name.span, "func body is null");
        tc.ctx.current_func = last_func;
        return null;
    }

    // check function body
    let body = check_stmt(tc, f_s.block as *ast.Stmt);
    if body == null {
        return null;
    }
    f_s.block = body as *ast.BlockStmt;

    if !ty.is_void(f_ty.ret) {
        if tc.check_for_return_stmt(f_s.block) == Result.Error {
            push_missing_return_error(tc, f_s.decl.name.span);
            tc.ctx.current_func = last_func;
            return null;
        }
    }

    tc.ctx.current_func = last_func;

    return f_s.block;
}

// Checks if the last stmt of a block is guaranteed to have a return statement
// Pseudo code:
// - last stmt is return -> ok
// - last stmt is if
//     - if has unconditional else
//         - if contains return && else contains return -> ok
//         - branches contains more ifs -> goto begin
//         - error
//     - error
// - error
def (tc: *TypeChecker) check_for_return_stmt(block: *ast.BlockStmt): Result {
    if block.stmts.len == 0 {
        return Result.Error;
    }

    let last_stmt = ast.stmt_at(block, block.stmts.len - 1);
    if ast.is_return_stmt(last_stmt) {
        return Result.OK;
    } else if ast.is_if_stmt(last_stmt) {
        let if_stmt = ast.as_if_stmt(last_stmt);
        let else_stmt = if_stmt.else_stmt;
        let run = true;
        while run && else_stmt != null {
            if ast.is_if_stmt(else_stmt) {
                // if else (...) {...}
                else_stmt = ast.as_if_stmt(else_stmt).else_stmt;
            } else {
                // else {...}
                run = false;
            }
        }

        // no unconditional else statement
        if else_stmt == null {
            return Result.Error;
        }
        let else_stmt = ast.as_block_stmt(else_stmt);

        let if_has_return = tc.check_for_return_stmt(if_stmt.block);
        let else_has_return = tc.check_for_return_stmt(else_stmt);

        if if_has_return.is_ok()  && else_has_return.is_ok() {
            let span = span.create(block.s.span.end, block.s.span.end);

            // just add a null value here. This is unreachable, but we currently don't have a
            // statement for that
            let value = ast.new_null_expr(span);
            value.ty = tc.ctx.current_func.ret;

            block.push(ast.new_return_stmt(span, value));
            return Result.OK;
        }
    }

    return Result.Error;
}

def check_decl_stmt(tc: *TypeChecker, s: *ast.Stmt): *ast.Stmt {
    // STMT_STRUCT_DECL
    if ast.is_struct_decl_stmt(s) {
        let sd = &ast.as_struct_decl_stmt(s).decl;

        let ty = check_struct_decl(tc, sd);
        if ty == null {
            return null;
        }

        bind_type_public(tc, &sd.name, ty);
        sd.struct_ty = ty;

        return s;
    }

    // STMT_ENUM_DECL
    if ast.is_enum_decl_stmt(s) {
        let decl_stmt = ast.as_enum_decl_stmt(s);
        let ed = &decl_stmt.decl;

        let ty = check_enum_decl(tc, decl_stmt);
        if ty == null {
            return null;
        }

        // the name of an enum can refer to both, the Enum scope (value) or the enum Type
        bind_type_public(tc, &ed.name, ty);
        bind_value_public(tc, &ed.name, ty);
        ed.enum_ty = ty;

        return s;
    }

    // STMT_UNION_DECL
    if ast.is_union_decl_stmt(s) {
        let sd = &ast.as_union_decl_stmt(s).decl;

        let ty = check_union_decl(tc, sd);
        if ty == null {
            return null;
        }

        bind_type_public(tc, &sd.name, ty);
        sd.union_ty = ty;

        return s;
    }

    if ast.is_func_decl_stmt(s) {
        let f_s = ast.as_func_decl_stmt(s);

        let signature = declare_func(tc, s);
        if signature == null {
            return null;
        }

        let fd = &f_s.decl;
        fd.signature = signature;
        if fd.is_procedure() || fd.is_extern() {
            bind_value_public(tc, &fd.name, fd.signature);
        } else if fd.is_delegate() {
            let func_ptr_ty = tc.create_ptr_ty(fd.signature);
            bind_type_public(tc, &fd.name, func_ptr_ty);
            waiting.update_all(tc, tc.ctx.mod, func_ptr_ty, &fd.name);
        }
    }

    return s;
}

// returns the statement which should replace the old one
// if a new statement is created, this function will free the old one
def check_stmt(tc: *TypeChecker, s: *ast.Stmt): *ast.Stmt {
    // STMT_IMPORT
    if ast.is_import_stmt(s) {
        let i_s = ast.as_import_stmt(s);

        if i_s.mod_ty == null {
            let alias: ident.Ident = ident.empty();

            if !check_import(tc, i_s, &alias, &i_s.mod_ty) {
                return null;
            }

            if i_s.is_qualified() {
                // since types and/or values could be imported, imports live in both namespaces
                bind_type_private(tc, &alias, i_s.mod_ty);
                bind_value_private(tc, &alias, i_s.mod_ty);
            }
        }

        if tc.pass == PassMode.Real && !i_s.is_qualified() {
            // non qualified import
            let mod_ty = ty.as_mod(i_s.mod_ty);

            let iter = mod_ty.types.iter();
            for let imported = iter.next(); imported.present(); imported = iter.next() {
                bind_type_private(tc, &imported.name, imported.symbol.ty_or_null());
            }

            let iter = mod_ty.values.iter();
            for let imported = iter.next(); imported.present(); imported = iter.next() {
                bind_value_private(tc, &imported.name, imported.symbol.ty_or_null());
            }
        }

        return s;
    }

    if tc.pass == PassMode.TypeDecl {
        return check_decl_stmt(tc, s);
    }

    // STMT_FUNC_DECL
    if ast.is_func_decl_stmt(s) {
        let f_s = ast.as_func_decl_stmt(s);
        let fd = &f_s.decl;

        if tc.pass == PassMode.FuncAndGlobalDecl {
            let checked_ty = check_func_decl(tc, fd);
            if checked_ty == null {
                return null;
            }

            return s;
        }

        if fd.is_method() {
            // at this point, all the types inside the function signature have to be resolved,
            // so it is safe to access the receiver type
            let receiver_ty = ty.as_func(fd.signature).receiver.ty;
            if receiver_ty == null {
                return null;
            }

            if receiver_ty.get_user_defined().declared_in != tc.ctx.mod {
                push_receiver_different_module_error(tc, fd.receiver.ty.span());
                return null;
            }
        }

        // templated functions are only checked when they are invoked
        if fd.signature.is_template() {
            return s;
        }

        // only resolve the block in the actual pass
        if fd.is_procedure() || fd.is_method() {
            let block = check_func_body(tc, f_s);
            if block == null {
                return null;
            }

            f_s.block = block;
        }

        return s;
    }

    // STMT_LET
    if ast.is_let_stmt(s) {
        let l_s = ast.as_let_stmt(s);
        let value: *ast.Expr = null;

        // this is only executed for global let statements, since we don't check
        // the function bodies in the decl only_pass
        if tc.pass == PassMode.FuncAndGlobalDecl {
            // placeholder to bind the name
            let temp_ty = get_global_type(tc, std.strlen(error_ty_name), error_ty_name);
            // we need to bind the name here, so we can give an error, when someone
            // tries to write a function with the same name
            bind_value_private(tc, &l_s.ident, temp_ty);
            return s;
        }

        let expected_ty: *ty.Type = null;
        if ast.has_type_decl(l_s) {
            let lookup_data = lookup.resolve_tyid(tc, &l_s.ty);
            if !lookup_data.found_type {
                return null;
            }
            expected_ty = lookup_data.ty;

            value = check_expr_expect(tc, l_s.value, expected_ty, null);
        } else {
            value = check_expr(tc, l_s.value);
        }

        // TODO(#104): do we need these 2 bind_value calls? shouldn't the value already be Result.Error?

        if value == null {
            // bind the error type here, to get rid of follow up errors
            let temp_ty = get_global_type(tc, std.strlen(error_ty_name), error_ty_name);
            bind_value_private(tc, &l_s.ident, temp_ty);
            return null;
        }

        if expected_ty != null && !ty.equals(value.ty, expected_ty) {
            push_wrong_let_type_error(tc, expected_ty, value.ty, value.span);
            // bind the error type here, to get rid of follow up errors
            let temp_ty = get_global_type(tc, std.strlen(error_ty_name), error_ty_name);
            bind_value_private(tc, &l_s.ident, temp_ty);
            return null;
        }

        if !ty.is_sized(value.ty) || (value.ty.is_array() && !value.can_init_array()) {
            let temp_ty = get_global_type(tc, std.strlen(error_ty_name), error_ty_name);
            bind_value_private(tc, &l_s.ident, temp_ty);
            push_type_not_assignable_error(tc, value);
            return null;
        }

        // TODO(#71): if a let stmt is in global scope, it should only allow compile time
        //  expressions as initialization

        let bind_f = &bind_value_public;

        let is_global = scope.num_scopes(&tc.ctx.values) < 3;
        if is_global {
            // we currently have strong constraints for global vars
            // this will change when compile time code evaluation is introduced
            if !value.is_const_evaluatable() {
                push_non_const_expr_error(tc, value.span);
                return null;
            }

            bind_f = &bind_value_private;
        }

        l_s.value = value;
        bind_f(tc, &l_s.ident, l_s.value.ty);
        return s;
    }

    // the statements below this should only be resolved in the real pass
    if tc.pass != PassMode.Real {
        return s;
    }

    // STMT_BLOCK
    if ast.is_block_stmt(s) {
        let b_s = ast.as_block_stmt(s);

        let error = false;
        open_scope(tc);

        for let i: usize = 0; i < b_s.stmts.len; i += 1 {
            let stmt = ast.stmt_at(b_s, i);

            let checked = check_stmt(tc, stmt);
            if checked == null {
                error = true;
            } else {
                ast.set_stmt_at(b_s, i, checked);
            }
        }

        close_scope(tc);

        if error {
            return null;
        }

        return s;
    }

    // STMT_EXPR
    if ast.is_expr_stmt(s) {
        let e_s = ast.as_expr_stmt(s);
        let expr = check_expr(tc, e_s.expr);

        if expr == null {
            return null;
        }

        if !ty.is_sized(expr.ty) && !ast.is_call_expr(expr) {
            push_invalid_expr_error(tc, expr);
            return null;
        }

        e_s.expr = expr;
        return s;
    }

    // STMT_DELETE
    if ast.is_delete_stmt(s) {
        let d_s = ast.as_delete_stmt(s);
        let expr = check_expr(tc, d_s.expr);

        if expr == null {
            return null;
        }

        if !expr.ty.is_ptr() {
            push_delete_non_ptr_error(tc, expr);
            return null;
        }

        d_s.expr = expr;
        return s;
    }

    // STMT_IF
    if ast.is_if_stmt(s) {
        let i_s = ast.as_if_stmt(s);
        let condition = check_expr(tc, i_s.condition);

        if condition == null {
            return null;
        }

        let bool_ty = get_global_type(tc, 4, "bool");
        if !ty.equals(bool_ty, condition.ty) {
            push_invalid_condition_error(tc, condition);
            return null;
        }
        i_s.condition = condition;

        let block = check_stmt(tc, i_s.block as *ast.Stmt);
        if block == null {
            return null;
        }
        i_s.block = block as *ast.BlockStmt;

        if (i_s.else_stmt != null) {
            let else_stmt = check_stmt(tc, i_s.else_stmt);
            if else_stmt == null {
                return null;
            }
            i_s.else_stmt = else_stmt;
        }

        return s;
    }

    // STMT_WHILE
    if ast.is_while_stmt(s) {
        let w_s = ast.as_while_stmt(s);
        let condition = check_expr(tc, w_s.condition);

        if condition == null {
            return null;
        }

        let bool_ty = get_global_type(tc, 4, "bool");
        if !ty.equals(bool_ty, condition.ty) {
            push_invalid_condition_error(tc, condition);
            return null;
        }
        w_s.condition = condition;

        tc.enter_loop();

        let block = check_stmt(tc, w_s.block as *ast.Stmt);
        if block == null {
            return null;
        }
        w_s.block = block as *ast.BlockStmt;

        tc.exit_loop();

        return s;
    }

    // STMT_FOR
    if ast.is_for_stmt(s) {
        let f_s = ast.as_for_stmt(s);

        open_scope(tc);
        defer close_scope(tc);

        let init: *ast.Stmt = null;
        if f_s.initializer != null {
            init = check_stmt(tc, f_s.initializer);
            if init == null {
                return null;
            }
        }

        let condition = check_expr(tc, f_s.condition);
        if condition == null {
            return null;
        }

        let bool_ty = get_global_type(tc, 4, "bool");
        if !ty.equals(bool_ty, condition.ty) {
            push_invalid_condition_error(tc, condition);
            return null;
        }

        let increment: *ast.Stmt = null;
        if f_s.increment != null {
            increment = check_stmt(tc, f_s.increment);
            if increment == null {
                return null;
            }
        }

        tc.enter_loop();

        let block = check_stmt(tc, f_s.block as *ast.Stmt) as *ast.BlockStmt;
        if block == null {
            return null;
        }

        // set the inner statements to null, so we don't get duplicated frees
        f_s.initializer = null;
        f_s.condition = null;
        f_s.increment = null;
        f_s.block = null;

        tc.exit_loop();

        // transform for statement into while stmt
        // this for loop compiles to...
        // for let i = 0; i < 3; i = i + 1 {
        //     ...
        // }
        //
        // ...this block
        // {
        //     let i = 0;
        //     while i < 3 {
        //         {
        //             ...
        //         }
        //         END_BLOCK: {
        //             i = i + 1;
        //         }
        //     }
        // }

        let w_s = ast.new_while_stmt(s.span, condition, block);

        if increment != null {
            let inc_block = ast.new_block_stmt(increment.span, ptrvec.with_cap(1));
            let inc_block = inc_block as *ast.BlockStmt;

            ast.push_stmt(inc_block, increment);
            ast.as_while_stmt(w_s).end_block = inc_block;
        }

        let statements = ptrvec.with_cap(2);
        if init != null {
            statements.push_ptr(init as *void);
        }
        statements.push_ptr(w_s as *void);

        let original_span = s.span;
        ast.stmt_free(s);

        return ast.new_block_stmt(original_span, statements);
    }

    // STMT_RETURN
    if ast.is_return_stmt(s) {
        let r_s = ast.as_return_stmt(s);
        if r_s.expr == null {
            if !ty.is_void(tc.ctx.current_func.ret) {
                let void_ty = get_global_type(tc, 4, "void");
                push_wrong_return_type_error(tc, s.span, void_ty);
                return null;
            }

            return s;
        } else if ty.is_void(tc.ctx.current_func.ret) {
            push_return_in_void_func_error(tc, r_s.expr.span);
            return null;
        }

        let expr = check_expr_expect(tc, r_s.expr, tc.ctx.current_func.ret, null);
        if expr == null {
            return null;
        }

        if !ty.equals(tc.ctx.current_func.ret, expr.ty) {
            push_wrong_return_type_error(tc, expr.span, expr.ty);
            return null;
        }

        r_s.expr = expr;
        return s;
    }

    // STMT_CONTINUE
    if ast.is_continue_stmt(s) {
        if !tc.in_loop() {
            push_outside_loop_error(tc, s.span, "continue");
            return null;
        }

        return s;
    }

    // STMT_BREAK
    if ast.is_break_stmt(s) {
        if !tc.in_loop() {
            push_outside_loop_error(tc, s.span, "break");
            return null;
        }

        return s;
    }

    // STMT_DEFER
    if ast.is_defer_stmt(s) {
        let defer_stmt = ast.as_defer_stmt(s);
        let checked = check_stmt(tc, defer_stmt.stmt);

        defer_stmt.stmt = checked;
        return s;
    }

    return null;
}

def check_expr(tc: *TypeChecker, e: *ast.Expr): *ast.Expr {
    return check_expr_expect(tc, e, null, null);
}

// if data == null, lookup.Kind.Values is assumed
def check_expr_expect(
    tc: *TypeChecker,
    e: *ast.Expr,
    expected: *ty.Type,
    data: *lookup.Data
): *ast.Expr {
    // EXPR_INT || EXPR_CHAR
    if ast.is_int_expr(e) || ast.is_char_expr(e) {
        // TODO(#124): check size of literal to determine correct integer width
        if expected != null && expected.is_integer() {
            e.ty = expected;
            return e;
        }

        if ast.is_char_expr(e) {
            e.ty = get_global_type(tc, 2, "i8");
            return e;
        }

        e.ty = get_global_type(tc, 3, "i32");
        return e;
    }

    // EXPR_FLOAT
    if ast.is_float_expr(e) {
        if expected != null && ty.is_f64(expected) {
            e.ty = get_global_type(tc, 3, "f64");
            return e;
        }

        e.ty = get_global_type(tc, 3, "f32");
        return e;
    }

    // EXPR_STRING
    if ast.is_string_expr(e) {
        if expected != null && expected.is_array() && expected.as_array().inner.is_char() {
            let s_e = ast.as_string_expr(e);
            let escaped = escape.string_literal(e.span.start, e.span.end);

            let char_ty = get_global_type(tc, 2, "i8");
            let total_len = escaped.len as i64 + 1;
            let arr_ty = tc.create_array_ty(total_len, char_ty);

            if expected.as_array().len < 0 {
                // array was declared with '_' as len
                expected.as_array().len = total_len;
                expected.set_sized(true);
            }

            if total_len != expected.as_array().len {
                push_bin_invalid_types_error(tc, expected, arr_ty, e.span);
                name.free_owned(&escaped);
                return null;
            }

            defer ast.expr_free(e);
            let e = ast.new_array_string_expr(e.span, escaped);
            e.ty = arr_ty;
            return e;
        }

        e.ty = get_global_type(tc, 6, "string");
        return e;
    }

    // EXPR_NULL
    if ast.is_null_expr(e) {
        if expected != null && expected.is_ptr() {
            e.ty = expected;
            return e;
        }
        push_could_not_infer_error(tc, e.span);
        return null;
    }

    // EXPR_UNDEFINED
    if ast.is_undefined_expr(e) {
        // undefined can take any value, as long as we know the type
        if expected != null {
            e.ty = expected;
            return e;
        }
        push_could_not_infer_error(tc, e.span);
        return null;
    }

    // EXPR_IDENT
    if ast.is_ident_expr(e) {
        let ident = &ast.as_ident_expr(e).ident;
        e.ty = data.lookup_ident(tc, ident).ty_or_null();

        if e.ty == null {
            push_not_defined_error(tc, ident, data.to_string(), null);
            return null;
        }

        if ty.is_error(e.ty) {
            // when a binding definition fails, we just bind a special error
            // type to the name and return null here without pushing an actual error.
            // This will prevent 'follow up' errors
            return null;
        }

        return e;
    }

    // EXPR_ACCESS
    if ast.is_access_expr(e) {
        let a_e = ast.as_access_expr(e);

        let left = check_expr_expect(tc, a_e.left, expected, data);
        if left == null {
            return null;
        }

        a_e.left = left;
        let left_ty = a_e.left.ty;

        // TODO(#86): add a special message for pointers to pointers
        //  "Type 'pointer' cannot be accessed with '.' operator" does not
        //  make sense, when the actual pointer to a struct can be accessed with '.'

        if !data.is_type_accessible(left_ty) {
            // TODO(#52): the span here is the span of the entire left access, which
            //  is probably not what we want...
            push_not_accessible_with_error(tc, a_e.left, ".");
            return null;
        }

        let name = &a_e.right.ident;
        let right = data.lookup_ident_in(left_ty, name);
        if !right.present() {
            push_not_defined_error(tc, &a_e.right.ident, data.to_string(), right.scope);
            return null;
        }

        if right.is_private() {
            push_access_private_symbol_error(tc, &a_e.right.ident, right.scope);
            return null;
        }

        a_e.right.e.ty = right.ty_or_null();
        e.ty = a_e.right.e.ty;
        return e;
    }

    // EXPR_INDEX
    if ast.is_index_expr(e) {
        let idx_e = ast.as_index_expr(e);

        let left = check_expr_expect(tc, idx_e.left, expected, data);
        if left == null {
            return null;
        }

        idx_e.left = left;
        let left_ty = idx_e.left.ty;

        if !left_ty.is_indexable() {
            push_not_accessible_with_error(tc, idx_e.left, "index");
            return null;
        }

        let right = check_expr(tc, idx_e.right);
        if right == null {
            return null;
        }

        if !right.ty.is_integer() {
            push_wrong_index_type_error(tc, left_ty, right.ty, e.span);
            return null;
        }

        idx_e.right = right;
        e.ty = left_ty.inner_type();

        return e;
    }

    // EXPR_BINARY
    if ast.is_binary_expr(e) {
        let b_e = ast.as_binary_expr(e);
        let left: *ast.Expr = null;
        let right: *ast.Expr = null;

        if ast.is_null_expr(b_e.left) {
            right = check_expr_expect(tc, b_e.right, expected, data);
            if right != null {
                left = check_expr_expect(tc, b_e.left, right.ty, data);
            }
        } else {
            left = check_expr_expect(tc, b_e.left, expected, data);
            if left != null {
                right = check_expr_expect(tc, b_e.right, left.ty, data);
            }
        }

        if left == null || right == null {
            return null;
        }

        let ty = check_binary_expr(
            tc, b_e.kind, b_e.op_span, left.ty, right.ty, e.span
        );

        if ty == null {
            return null;
        }

        b_e.left = left;
        b_e.right = right;
        e.ty = ty;
        return e;
    }

    // EXPR_ASSIGN
    if ast.is_assign_expr(e) {
        let a_e = ast.as_assign_expr(e);
        let left = check_expr(tc, a_e.left);

        if left == null {
            return null;
        }

        if !ast.is_assignable(left) {
            push_expr_not_assignable_error(tc, left);
            return null;
        }

        if !left.ty.is_assignable() {
            push_type_not_assignable_error(tc, left);
            return null;
        }

        let right = check_expr_expect(tc, a_e.right, left.ty, data);
        if right == null {
            return null;
        }

        if a_e.assign_type != ast.AssignType.Normal {
            // TODO(#125): remove this, when casting between enums and their base type is implemented
            let kind = *(&a_e.assign_type as *ast.BinaryKind);

            let new_rhs = ast.new_binary_expr(
                right.span, kind, a_e.assign_span, left, right
            );
            ast.as_binary_expr(new_rhs).free_left = false;

            right = check_expr_expect(tc, new_rhs, left.ty, data);
            if right == null {
                ast.expr_free(new_rhs);
                a_e.right = null;
                return null;
            }
        }

        if !ty.equals(left.ty, right.ty) {
            push_bin_invalid_types_error(tc, left.ty, right.ty, e.span);
            return null;
        }

        if !right.ty.is_assignable() {
            push_type_not_assignable_error(tc, right);
            return null;
        }

        a_e.left = left;
        a_e.right = right;
        e.ty = right.ty;
        return e;
    }

    // EXPR_UNARY
    if ast.is_unary_expr(e) {
        let u_e = ast.as_unary_expr(e);

        let lookup_data = data.copy();
        lookup_data.kind = lookup.Kind.Both; // needed for method pointers

        let expr = check_expr_expect(tc, u_e.right, expected, &lookup_data);
        if expr == null {
            return null;
        }

        let result_ty = check_unary_expr(tc, u_e.kind, expr, e.span, &lookup_data);
        if result_ty == null {
            return null;
        }

        u_e.right = expr;
        e.ty = result_ty;
        return e;
    }

    // EXPR_NEW
    if ast.is_new_expr(e) {
        let n_e = ast.as_new_expr(e);
        if expected != null && expected.is_ptr() {
            let p = expected.as_ptr();
            expected = p.inner;
        }

        let inner = check_expr_expect(tc, n_e.expr, expected, data);

        if inner == null {
            return null;
        }

        let ptr = tc.create_ptr_ty(inner.ty);
        n_e.expr = inner;
        e.ty = ptr;
        return e;
    }

    // EXPR_SIZEOF
    if ast.is_sizeof_expr(e) {
        let s_e = ast.as_sizeof_expr(e);

        let lookup_data = lookup.resolve_tyid(tc, &s_e.ty);
        if !lookup_data.found_type {
            return null;
        }
        let actual_ty = lookup_data.ty;

        if !ty.is_sized(actual_ty) {
            push_unsized_sizeof_error(tc, actual_ty, e.span);
            return null;
        }

        s_e.actual_ty = actual_ty;
        e.ty = get_global_type(tc, 5, "usize");
        return e;
    }

    // EXPR_AS
    if ast.is_as_expr(e) {
        let a_e = ast.as_as_expr(e);

        let lookup_data = lookup.resolve_tyid(tc, &a_e.ty);
        if !lookup_data.found_type {
            return null;
        }
        let dest_ty = lookup_data.ty;

        let expr = check_expr_expect(tc, a_e.expr, dest_ty, data);
        if expr == null {
            return null;
        }

        if !ty.can_be_casted(expr.ty, dest_ty) {
            push_invalid_cast_error(tc, expr.ty, dest_ty, e.span);
            return null;
        }

        a_e.expr = expr;
        e.ty = dest_ty;
        return e;
    }

    // EXPR_CALL
    if ast.is_call_expr(e) {
        let c_e = ast.as_call_expr(e);

        let callee = check_expr(tc, c_e.callee);
        if callee == null {
            return null;
        }

        let f_ty = callee.ty;
        if !ty.is_callable(f_ty) {
            push_not_callable_error(tc, e.span, f_ty);
            return null;
        }

        let is_template_invocation = f_ty.is_template();
        let func = ty.callable_as_func(f_ty);

        if func.is_method {
            dbg.assert(ast.is_access_expr(callee), "method callee wasn't an access expr");
            let access = ast.as_access_expr(callee);
            let recv_expr = access.left; // receiver should be lhs of the callee access

            let checked_recv = check_expr_expect(tc, recv_expr, func.receiver.ty, data);
            if checked_recv == null {
                return null;
            }

            let expected = func.receiver.ty;

            // a receiver cannot be a pointer to a pointer, so this check is sufficient
            if expected.is_ptr() && !checked_recv.ty.is_ptr() {
                // we allow auto upgrading a non pointer to a simple pointer, nothing else
                expected = expected.as_ptr().inner;
            }

            if !ty.equals(expected, checked_recv.ty) {
                push_wrong_arg_type_error(
                    tc, func.receiver.ty, checked_recv.ty, recv_expr.span
                );
                return null;
            }
        }

        let expected_num_args = func.num_params();
        let actual_num_args = c_e.args.count();
        if expected_num_args != actual_num_args {
            if actual_num_args < expected_num_args {
                push_wrong_num_args_error(tc, expected_num_args, actual_num_args, callee.span);
                return null;
            }

            if actual_num_args > expected_num_args && !func.is_varargs {
                push_wrong_num_args_error(tc, expected_num_args, actual_num_args, callee.span);
                return null;
            }
        }

        let mono_map = ty.empty_monomorphization_map();
        defer mono_map.free();
        if is_template_invocation {
            mono_map = f_ty.as_template().monomorphization_map();
        }

        for let i: u32 = 0; i < actual_num_args; i += 1 {
            let arg = ast.get_arg_at(&c_e.args, i);

            if func.is_varargs {
                let checked_arg = check_expr(tc, arg);
                if checked_arg == null {
                    return null;
                }
                ast.set_arg_at(&c_e.args, i, checked_arg);
                continue;
            }

            let param = func.param_at(i);
            let checked_arg: *ast.Expr = null;

            if is_template_invocation && param.ty.contains_template_param() {
                // if this is a template argument, we don't assume any type
                checked_arg = check_expr(tc, arg);
                if checked_arg == null {
                    return null;
                }

                if !mono_map.bind(param.ty, checked_arg.ty) {
                    push_internal_error(tc, checked_arg.span, "cannot bind template arg kekw");
                    return null;
                }

            } else {
                checked_arg = check_expr_expect(tc, arg, param.ty, null);
                if checked_arg == null {
                    return null;
                }

                if !ty.equals(param.ty, checked_arg.ty) {
                    push_wrong_arg_type_error(
                        tc, param.ty, checked_arg.ty, checked_arg.span
                    );
                    return null;
                }
            }

            ast.set_arg_at(&c_e.args, i, checked_arg);
        }

        // FIXME: how should this work for function pointers?
        if is_template_invocation {
            let signature = mono_map.get_previously_resolved_signature();

            if signature == null {
                open_scope(tc);
                defer close_scope(tc);

                let func_decl_stmt = mono_map.cloned_stmt();

                let f_s = ast.as_func_decl_stmt(func_decl_stmt);
                let fd = &f_s.decl;

                // bind the concrete types for this template
                let iter = mono_map.iter();
                for let item = iter.next(); item != null; item = iter.next() {
                    let name = item.key.as_ident();
                    let bound_type = item.value as *ty.Type;
                    bind_type_public(tc, &name, bound_type);
                }

                // since this clears the mono_map, it has to happen after we bind the template types
                signature = mono_map.into_cloned_signature();
                // add cloned function into the ast
                mod.push_stmt(ty.as_signature(signature).declared_in, func_decl_stmt);

                fd.signature = signature;
                fill_func_def(tc, fd, signature);

                if fd.is_procedure() || fd.is_method() {
                    let block = check_func_body(tc, f_s);
                    if block == null {
                        return null;
                    }

                    f_s.block = block;
                }
            }

            // TODO: generate actual code
            callee.ty = signature;
            func = ty.callable_as_func(signature);
        }

        c_e.callee = callee;
        e.ty = func.ret;
        return e;
    }

    // EXPR_INIT
    if ast.is_init_expr(e) {
        let i_e = ast.as_init_expr(e);
        let data = lookup.create_data(lookup.Kind.Types, null);
        let left = check_expr_expect(tc, i_e.identifier, expected, &data);
        if left == null {
            return null;
        }

        if !(ty.is_struct(left.ty) || ty.is_union(left.ty)) {
            push_init_invalid_type_error(tc, left.ty, e.span);
            return null;
        }

        if ty.is_union(left.ty) {
            let union_ty = ty.as_union(left.ty);
            let inits = &i_e.inits;

            if inits.count() != 1 {
                push_union_init_multiple_error(tc, e.span);
                return null;
            }

            let init = inits.get_ptr(0);
            let field_ty = union_ty.field_with_name(init.ident);
            if field_ty == null {
                push_not_defined_error(tc, &init.ident, "field", &union_ty.super.scope);
                return null;
            }

            let checked_init_expr = check_expr_expect(tc, init.expr, field_ty, null);
            if checked_init_expr == null {
                return null;
            }
            init.expr = checked_init_expr;

            if !ty.equals(field_ty, init.expr.ty) {
                push_union_init_invalid_error(tc, init, union_ty);
            }

            i_e.identifier = left;
            e.ty = left.ty;
            return e;
        }

        // TODO(#76): check names of fields and reorder if necessary

        let struct_ty = ty.as_struct(left.ty);
        let inits = &i_e.inits;

        let expected_num_args = struct_ty.num_fields();
        let actual_num_args = inits.count();
        if expected_num_args != actual_num_args {
            push_wrong_num_args_error(tc, expected_num_args, actual_num_args, e.span);
            return null;
        }

        for let i: u32 = 0; i < expected_num_args; i += 1 {
            let param = struct_ty.field_at(i);
            let arg = ast.init_at(inits, i);

            if !param.name.equals(arg.ident) {
                push_wrong_field_error(tc, param.name, arg.ident);
                return null;
            }

            let checked_arg = check_expr_expect(tc, arg.expr, param.ty, null);
            if checked_arg == null {
                return null;
            }

            if !ty.equals(param.ty, checked_arg.ty) {
                push_wrong_arg_type_error(tc, param.ty, checked_arg.ty, checked_arg.span);
                return null;
            }

            ast.set_init_expr_at(inits, i, checked_arg);
        }

        // TODO(#54): those names are really confusing
        i_e.identifier = left;
        e.ty = left.ty;
        return e;
    }

    return null;
}

def check_binary_expr(
    tc: *TypeChecker,
    kind: ast.BinaryKind,
    op_span: span.Span,
    first: *ty.Type,
    second: *ty.Type,
    span: span.Span
): *ty.Type {
    if first == null || second == null {
        push_internal_error(tc, span, "types were null");
        return null;
    }

    if ty.equals(first, second) {
        if kind == ast.BinaryKind.Eq || kind == ast.BinaryKind.NE
            || kind == ast.BinaryKind.ST || kind == ast.BinaryKind.SE
            || kind == ast.BinaryKind.GT || kind == ast.BinaryKind.GE
        {
            if ty.is_bool(first) {
                return first;
            }

            if ty.is_comparable(first) {
                return get_global_type(tc, 4, "bool");
            }

            push_bin_invalid_types_error(tc, first, second, op_span);
            return null;
        }

        if kind == ast.BinaryKind.LogOr || kind == ast.BinaryKind.LogAnd {
            if ty.is_bool(first) {
                return first;
            }

            push_bin_invalid_types_error(tc, first, second, op_span);
            return null;
        }

        if kind.is_bit_op() {
            if first.is_integer() || ty.is_bool(first) {
                return first;
            }

            push_bin_invalid_types_error(tc, first, second, op_span);
            return null;
        }

        // TODO(#58): should we allow float comparisons with '=='?
        //  0.1 == 0.2 == 0.3 is false after all
        //  should we just expose a compare function in the stdlib?

        if first.is_num() {
            // everything except || and && is fine
            return first;
        }

        if first.is_ptr() {
            // pointer subtraction is the only allowed operation
            if kind == ast.BinaryKind.Sub {
                return get_global_type(tc, 5, "isize");
            }

            let text = error.err2str(error.CompileError.BinPtrInvalid);
            push_mk_err(tc, text, op_span);
            return null;
        }

        push_bin_invalid_types_error(tc, first, second, op_span);
        return null;
    }

    if kind == ast.BinaryKind.Add {
        // both ptr + int and int + ptr are ok
        if first.is_ptr() && second.is_integer() {
            return first;
        }

        if second.is_ptr() && first.is_integer() {
            return second;
        }
    } else if kind == ast.BinaryKind.Sub {
        // only ptr - int is allowed, not the other way
        if first.is_ptr() && second.is_integer() {
            return first;
        }
    }

    push_bin_invalid_types_error(tc, first, second, op_span);
    return null;
}

def check_unary_expr(
    tc: *TypeChecker,
    kind: ast.UnaryKind,
    expr: *ast.Expr,
    span: span.Span,
    lookup_data: *lookup.Data
): *ty.Type {
    if expr.ty == null {
        push_internal_error(tc, span, "Unary expr type was null");
        return null;
    }

    if kind == ast.UnaryKind.Ref {
        if !ast.is_ident_expr(expr) && !ast.is_access_expr(expr) && !ast.is_index_expr(expr)
           || ast.is_access_expr(expr) && ty.is_enum(ast.as_access_expr(expr).left.ty) {
                let text = error.err2str(error.CompileError.UnaryRefRValue);
                push_mk_err(tc, text, span);
                return null;
        }

        let is_method_ptr = ty.is_func(expr.ty) && ty.as_func(expr.ty).is_method;
        if is_method_ptr && lookup_data.was_type_decl() {
            let new_func_type = ty.as_func(expr.ty).as_normal_function();
            push_tmp_ty(tc, new_func_type);
            return tc.create_ptr_ty(new_func_type);
        }

        if is_method_ptr {
            push_method_ptr_from_instance_error(tc, ty.as_func(expr.ty).receiver.ty, span);
            return null;
        }

        if lookup_data.was_type_decl() {
            push_cannot_take_address_of_error(tc, span);
            return null;
        }

        return tc.create_ptr_ty(expr.ty);
    }

    if lookup_data.was_type_decl() {
        push_illegal_unary_expr_error(tc, span);
        return null;
    }

    if kind == ast.UnaryKind.Deref {
        if !expr.ty.is_ptr() {
            let s_ty = tc.ty_to_string(expr.ty);
            defer s_ty.free();
            let text = error.err2str(error.CompileError.UnaryDerefNonPtr, s_ty.cstring());
            push_mk_err(tc, text, span);
            return null;
        }

        let e_ty: *ty.Type = null;
        let p_ty = expr.ty.as_ptr();
        e_ty = p_ty.inner;

        if !ty.is_sized(e_ty) {
            push_deref_unsized_error(tc, e_ty, span);
            return null;
        }

        return e_ty;
    }

    // TODO(#55): rewrite with function pointers
    if kind == ast.UnaryKind.NegBool {
        if !ty.is_bool(expr.ty) {
            let s_ty = ty.to_static_string(expr.ty);
            let text = error.err2str(error.CompileError.UnaryOpNotDefined, "!", s_ty);
            push_mk_err(tc, text, span);
            return null;
        }

        return expr.ty;
    }

    if kind == ast.UnaryKind.NegNum {
        if !expr.ty.is_num() {
            let s_ty = ty.to_static_string(expr.ty);
            let text = error.err2str(error.CompileError.UnaryOpNotDefined, "-", s_ty);
            push_mk_err(tc, text, span);
            return null;
        }

        return expr.ty;
    }

    if kind == ast.UnaryKind.BitNot {
        if !expr.ty.is_num() {
            let s_ty = ty.to_static_string(expr.ty);
            let text = error.err2str(error.CompileError.UnaryOpNotDefined, "~", s_ty);
            push_mk_err(tc, text, span);
            return null;
        }

        return expr.ty;
    }

    return null;
}

def mangle_func_name(tc: *TypeChecker, fd: *func.FuncDef): name.Owned {
    dbg.assert(fd != null, "funcdef was null");

    if fd.is_extern() || fd.is_exported() {
        // the names must be owned, so just copy data here
        // there aren't many extern functions anyway
        let len = ident.len(&fd.name);
        return name.make_copied(len, ident.start(&fd.name));
    }

    if fd.is_method() {
        let recv_ty_name = fd.receiver.ty.to_string();
        defer recv_ty_name.free();

        let len: usize = 0;
        let with_receiver = std.l_format_str(
            &len,
            "%.*s.%.*s",
            recv_ty_name.len(), recv_ty_name.cstring(),
            ident.len(&fd.name), ident.start(&fd.name)
        );

        let mangled = name.s_mangle(tc.mods.proj_root, len, with_receiver, tc.ctx.mod);
        delete with_receiver;
        return mangled;
    }

    return name.mangle_ident(tc.mods.proj_root, &fd.name, tc.ctx.mod);
}

def mangle_type_name(tc: *TypeChecker, i: *ident.Ident): name.Owned {
    dbg.assert(i != null, "ident was null");
    return name.mangle_ident(tc.mods.proj_root, i, tc.ctx.mod);
}

def free_tc(tc: *TypeChecker) {
    delete tc.sorted_mods;

    for let i: usize = 0; i < tc.errors.len; i += 1 {
        free_err(get_err(tc, i));
    }
    tc.errors.free();

    for let i: usize = 0; i < tc.requests.len; i += 1 {
        (tc.requests.get_ptr(i) as *waiting.RequestMap).free();
    }
    tc.requests.free();

    for let i: usize = 0; i < tc.contexts.len; i += 1 {
        free_ctx(get_ctx(tc, i as u32));
    }
    tc.contexts.free();

    scope.free_s(&tc.global_values);
}

def (tc: *TypeChecker) ty_to_string(t: *ty.Type): str.String {
    return ty.to_string_mangled(t, !t.is_declared_in(tc.ctx.mod));
}

def push_internal_error(tc: *TypeChecker, span: span.Span, text: string) {
    let text = error.err2str(error.CompileError.Internal, text);
    push_mk_err(tc, text, span);
}

def push_ident_error(tc: *TypeChecker, code: error.CompileError, i: *ident.Ident) {
    let len = ident.len(i);
    let text = error.err2str(code, len, ident.start(i));

    push_mk_err(tc, text, i.span);
}

def push_incomplete_ty_error(tc: *TypeChecker, name: *ident.Ident) {
    push_ident_error(tc, error.CompileError.IncompleteType, name);
}

def push_duplicate_def_error(tc: *TypeChecker, name: *ident.Ident) {
    push_ident_error(tc, error.CompileError.DuplicateDefintion, name);
}

def push_access_private_symbol_error(tc: *TypeChecker, name: *ident.Ident, from: *scope.Scope) {
    let scope_name = from.name();
    let text = error.err2str(
        error.CompileError.AccessingPrivateSymbol,
        name.len(), name.start(),
        scope_name.len, scope_name.data
    );

    push_mk_err(tc, text, name.span);
}

def push_not_defined_error(tc: *TypeChecker, name: *ident.Ident, kind_s: string, from: *scope.Scope) {
    let len = ident.len(name);
    let scope_name = from.name();
    let text = error.err2str(
        error.CompileError.NotDefined,
        kind_s,
        len, ident.start(name),
        scope_name.len, scope_name.data
    );

    push_mk_err(tc, text, name.span);
}

def push_not_accessible_with_error(tc: *TypeChecker, e: *ast.Expr, op: string) {
    let ty_s = tc.ty_to_string(e.ty);
    defer ty_s.free();
    let error = error.err2str(error.CompileError.NotAccessibleWithOp, ty_s.cstring(), op);

    push_mk_err(tc, error, e.span);
}

def push_not_callable_error(tc: *TypeChecker, span: span.Span, actual_ty: *ty.Type) {
    let ty_s = tc.ty_to_string(actual_ty);
    defer ty_s.free();
    let text = error.err2str(error.CompileError.CallingNonFunction, ty_s.cstring());
    push_mk_err(tc, text, span);
}

def push_wrong_num_args_error(tc: *TypeChecker, expected: u32, actual: u32, span: span.Span) {
    let text = error.err2str(error.CompileError.WrongNumberOfArgs, expected, actual);
    push_mk_err(tc, text, span);
}

def push_invalid_expr_error(tc: *TypeChecker, e: *ast.Expr) {
    let text = error.err2str(error.CompileError.InvalidExpression);
    push_mk_err(tc, text, e.span);
}

def push_receiver_different_module_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.ReceiverFromOtherMod);
    push_mk_err(tc, text, span);
}

def push_cannot_take_address_of_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.CannotTakeAddrOf);
    push_mk_err(tc, text, span);
}

def push_illegal_unary_expr_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.IllegalExprForUnary);
    push_mk_err(tc, text, span);
}

def push_array_invalid_len_expr_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.ArrayInvalidLen);
    push_mk_err(tc, text, span);
}

def push_duplicate_enum_value_error(tc: *TypeChecker, e: *ty.Enum, value_name: *ident.Ident) {
    let len = ident.len(value_name);
    let text = error.err2str(
        error.CompileError.DuplicateEnumValue,
        len, ident.start(value_name),
        e.super.mangled_name.len, e.super.mangled_name.data
    );
    push_mk_err(tc, text, value_name.span);
}

def push_invalid_enum_start_value_error(tc: *TypeChecker, e: *ty.Enum, start_value: *ast.Expr) {
    let s_start_ty = tc.ty_to_string(start_value.ty);
    defer s_start_ty.free();

    let text = error.err2str(
        error.CompileError.InvalidEnumStartValue,
        s_start_ty.cstring(),
        e.super.mangled_name.len, e.super.mangled_name.data
    );

    push_mk_err(tc, text, start_value.span);
}

def push_bin_invalid_types_error(
    tc: *TypeChecker,
    first: *ty.Type,
    second: *ty.Type,
    span: span.Span
) {
    let s_first = tc.ty_to_string(first);
    defer s_first.free();

    let s_second = tc.ty_to_string(second);
    defer s_second.free();

    let text = error.err2str(
        error.CompileError.BinInvalidTypes,
        s_first.cstring(),
        s_second.cstring()
    );
    push_mk_err(tc, text, span);
}

def push_wrong_index_type_error(
    tc: *TypeChecker,
    array_type: *ty.Type,
    index_type: *ty.Type,
    span: span.Span
) {
    push_wrong_type_error(tc, error.CompileError.WrongIndexType, array_type, index_type, span);
}


def push_wrong_arg_type_error(
    tc: *TypeChecker,
    expected: *ty.Type,
    actual: *ty.Type,
    span: span.Span
) {
    push_wrong_type_error(tc, error.CompileError.WrongArgType, expected, actual, span);
}

def push_wrong_let_type_error(
    tc: *TypeChecker,
    expected: *ty.Type,
    actual: *ty.Type,
    span: span.Span
) {
    push_wrong_type_error(tc, error.CompileError.LetDifferentTypes, expected, actual, span);
}

def push_wrong_type_error(
    tc: *TypeChecker,
    err_kind: error.CompileError,
    expected: *ty.Type,
    actual: *ty.Type,
    span: span.Span
) {
    let expected_ty_s = tc.ty_to_string(expected);
    defer expected_ty_s.free();

    let actual_ty_s = tc.ty_to_string(actual);
    defer actual_ty_s.free();

    let text = error.err2str(err_kind, expected_ty_s.cstring(), actual_ty_s.cstring());
    push_mk_err(tc, text, span);
}


def push_wrong_return_type_error(tc: *TypeChecker, span: span.Span, actual: *ty.Type) {
    let ret_ty_s = tc.ty_to_string(tc.ctx.current_func.ret);
    defer ret_ty_s.free();
    let ty_s = tc.ty_to_string(actual);
    defer ty_s.free();

    let text = error.err2str(
        error.CompileError.WrongReturnType,
        ret_ty_s.cstring(),
        ty_s.cstring()
    );
    push_mk_err(tc, text, span);
}

def push_missing_return_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.MissingReturn);
    push_mk_err(tc, text, span);
}

def push_return_in_void_func_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.ReturnWithValueInVoid);
    push_mk_err(tc, text, span);
}

def push_union_init_multiple_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.UnionInitInvalidCount);
    push_mk_err(tc, text, span);
}

def push_init_invalid_type_error(tc: *TypeChecker, actual_ty: *ty.Type, span: span.Span) {
    let ty_s = tc.ty_to_string(actual_ty);
    defer ty_s.free();
    let text = error.err2str(error.CompileError.InitInvalidType, ty_s.cstring());
    push_mk_err(tc, text, span);
}

def push_union_init_invalid_error(tc: *TypeChecker, init: *ast.Init, union_ty: *ty.Union) {
    let actual_ty_s = tc.ty_to_string(init.expr.ty);
    defer actual_ty_s.free();

    let expected_ty_s = tc.ty_to_string(union_ty.field_with_name(init.ident));
    defer expected_ty_s.free();

    let text = error.err2str(
        error.CompileError.UnionInitInvalid,
        init.ident.len(), init.ident.start(),
        union_ty.super.original_name.len(), union_ty.super.original_name.start(),
        expected_ty_s.cstring(), actual_ty_s.cstring()
    );
    push_mk_err(tc, text, init.expr.span);
}

def push_could_not_infer_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.CouldNotInferType);
    push_mk_err(tc, text, span);
}

def push_non_const_expr_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.NonConstExpressionInConstContext);
    push_mk_err(tc, text, span);
}

def push_outside_loop_error(tc: *TypeChecker, span: span.Span, keyword: string) {
    let text = error.err2str(error.CompileError.BreakOrContinueOutsideLoop, keyword);
    push_mk_err(tc, text, span);
}

def push_wrong_field_error(tc: *TypeChecker, expected: ident.Ident, actual: ident.Ident) {
    let text = error.err2str(
        error.CompileError.WrongStructField,
        expected.len(), expected.start(),
        actual.len(), actual.start()
    );
    push_mk_err(tc, text, actual.span);
}

def push_invalid_cast_error(
    tc: *TypeChecker,
    src: *ty.Type,
    dest: *ty.Type,
    span: span.Span
) {
    let src_ty_s = tc.ty_to_string(src);
    defer src_ty_s.free();

    let dest_ty_s = tc.ty_to_string(dest);
    defer dest_ty_s.free();

    let text = error.err2str(
        error.CompileError.InvalidCast,
        src_ty_s.cstring(),
        dest_ty_s.cstring()
    );
    push_mk_err(tc, text, span);
}

def push_simple_error(tc: *TypeChecker, kind: error.CompileError, t: *ty.Type, s: span.Span) {
    let ty_s = tc.ty_to_string(t);
    defer ty_s.free();

    let text = error.err2str(kind, ty_s.cstring());
    push_mk_err(tc, text, s);
}

def push_expr_type_error(tc: *TypeChecker, kind: error.CompileError, e: *ast.Expr) {
    push_simple_error(tc, kind, e.ty, e.span);
}

def push_unsized_field_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.UnsizedStructField, t, s);
}

def push_unsized_param_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.UnsizedParameter, t, s);
}

def push_unsized_sizeof_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.UnsizedSizeof, t, s);
}

def push_deref_unsized_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.DerefOfUnsizedType, t, s);
}

def push_primitive_receiver_type_error(tc: *TypeChecker, recv: *ty.Type, span: span.Span) {
    push_simple_error(tc, error.CompileError.PrimitiveReceiverType, recv, span);
}

def push_method_ptr_from_instance_error(tc: *TypeChecker, instanceof: *ty.Type, span: span.Span) {
    // TODO(#126): implement proper hint system
    // TODO(#127): use import alias for mangling
    push_simple_error(tc, error.CompileError.MethodPtrFromInstance, instanceof, span);
}

def push_invalid_condition_error(tc: *TypeChecker, e: *ast.Expr) {
    push_expr_type_error(tc, error.CompileError.InvalidTypeInCondition, e);
}

def push_type_not_assignable_error(tc: *TypeChecker, e: *ast.Expr) {
    push_expr_type_error(tc, error.CompileError.TypeNotAssignable, e);
}

def push_expr_not_assignable_error(tc: *TypeChecker, e: *ast.Expr) {
    push_expr_type_error(tc, error.CompileError.ExprNotAssignable, e);
}

def push_delete_non_ptr_error(tc: *TypeChecker, e: *ast.Expr) {
    let ty_s = tc.ty_to_string(e.ty);
    defer ty_s.free();

    let text = error.err2str(error.CompileError.DeleteNonPtr, ty_s.cstring());
    push_mk_err(tc, text, e.span);
}
