import "std";

// TODO: remove these, when we finally have an isize/usize type
extern def strlen(s: string): usize;
extern def memcpy(dest: *void, src: *void, n: usize);
extern def strndup(s: string, n: usize): string;
extern def malloc(size: usize): *void;

type String struct {
    // don't access directly
    len_: usize,
    cap_: usize,
    data_: string
}

def create(): String {
    return from_l("", 0);
}

def from(s: string): String {
    return from_l(s, strlen(s));
}

def from_l(s: string, len: usize): String {
    let max_storage = (sizeof *void as usize) * 3 - 2;

    let str: String = undefined;

    // on x64, we have 24 bytes - len (1 byte) - null terminator
    if len <= max_storage {
        // least significant len bit == 0 => optimized string
        str.len_ = len << 1;

        memcpy((&str as *void) + 1, s as *void, len);
        *(&str as *i8 + 1 + len) = '\0';
    } else {
        str.cap_ = len;
        // least significant len bit == 1 => heap allocated string
        str.len_ = (len << 1) | 1;
        str.data_ = strndup(s, len);
    }

    return str;
}

def (s: *String) len(): usize {
    if s.is_optimized() {
        return *(&s.len_ as *i8) >> 1 as usize;
    }

    return s.len_ >> 1;
}

def (s: *String) cstring(): string {
    if s.is_optimized() {
        return (s as *i8) + 1;
    }
    return s.data_;
}

def (s: *String) push(other: View) {
    let len = s.len();
    let new_len = len + other.len;

    if s.is_optimized() {
        let max_storage = (sizeof *void as usize) * 3 - 2;

        if  new_len <= max_storage {
            *(&s.len_ as *i8) = (new_len << 1) as i8;
            memcpy((s as *void + 1) + len, other.data as *void, other.len);
            *(s as *i8 + 1 + new_len) = '\0';
        } else {
            let cap = std.next_pow_of_2(new_len as i64 + 1) as usize;
            let data = malloc(cap);

            memcpy(data, s as *void + 1, len);
            memcpy(data + len, other.data as *void, other.len);

            s.data_ = data as string;
            *(s.data_ + new_len) = '\0';

            s.len_ = (new_len << 1) | 1;
            s.cap_ = cap;
        }

        return;
    }

    if new_len < s.cap_ {
        memcpy(s.data_ as *void + len, other.data as *void, other.len);
        *(s.data_ + new_len) = '\0';
        s.len_ = (new_len << 1) | 1;
        return;
    }

    let cap = std.next_pow_of_2(new_len as i64 + 1) as usize;
    let data = malloc(cap);

    memcpy(data, s.data_ as *void, len);
    memcpy(data + len, other.data as *void, other.len);

    delete s.data_;
    s.data_ = data as string;
    *(s.data_ + new_len) = '\0';

    s.len_ = (new_len << 1) | 1;
    s.cap_ = cap;
}

def (s: *String) is_optimized(): bool {
    return s.len_ & 1 == 0;
}

def (s: *String) view(): View {
    return view(s.len(), s.cstring());
}

def (s: *String) free() {
    if s.is_optimized() {
        return;
    }
    delete s.data_;
}

type View struct {
    len: usize,
    data: string
}

def view(len: usize, s: string): View {
    return View {
        len: len, data: s
    };
}
