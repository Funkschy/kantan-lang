import "dbg";
import "std";
import "name";
import "path";
import "llvm-bindings" as llvm;

type Arch enum {
    X86_64
}

type Vendor enum {
    Unknown, Apple
}

type Sys enum {
    Linux, Darwin, Win32
}

type Abi enum {
    Empty, Gnu, Msvc
}

def arch_to_name(a: Arch): name.Ref {
    if a == Arch.X86_64 {
        return name.make_ref(6, "x86_64");
    }
    return name.make_ref(0, null);
}

def arch_register(a: Arch): void {
    if a == Arch.X86_64 {
        llvm.initialize_x86_target_info();
        llvm.initialize_x86_target();
        llvm.initialize_x86_target_mc();
        llvm.initialize_x86_asm_printer();
        return;
    }

    dbg.assert_fmt(0 == 1, "unknown target architecture: %d", a);
}

def vendor_to_name(v: Vendor): name.Ref {
    if v == Vendor.Unknown {
        return name.make_ref(7, "unknown");
    }
    if v == Vendor.Apple {
        return name.make_ref(5, "apple");
    }
    return name.make_ref(0, null);
}

def sys_to_name(s: Sys): name.Ref {
    if s == Sys.Linux {
        return name.make_ref(5, "linux");
    }
    if s == Sys.Darwin {
        return name.make_ref(6, "darwin");
    }
    if s == Sys.Win32 {
        return name.make_ref(5, "win32");
    }
    return name.make_ref(0, null);
}

def abi_to_name(a: Abi): name.Ref {
    if a == Abi.Gnu {
        return name.make_ref(3, "gnu");
    }
    if a == Abi.Msvc {
        return name.make_ref(4, "msvc");
    }
    return name.make_ref(0, null);
}

type Target struct {
    is_error: bool,
    arch: Arch,
    vendor: Vendor,
    sys: Sys,
    abi: Abi,
    lltarget: *llvm.Target,
    triple_or_error: string // llvm message
}

def create_and_register_target(a: Arch, v: Vendor, sys: Sys, abi: Abi): Target {
    let target = Target {
        is_error: false,
        arch: a,
        vendor: v,
        sys: sys,
        abi: abi,
        lltarget: null,
        triple_or_error: null
    };

    arch_register(a);

    let arch = arch_to_name(a);
    let vendor = vendor_to_name(v);
    let sys = sys_to_name(sys);
    let abi = abi_to_name(abi);

    let triple = "";
    // abi can be empty (for example on darwin)
    if abi.data != null {
        triple = std.format_str(
            "%.*s-%.*s-%.*s-%.*s",
            arch.len, arch.data,
            vendor.len, vendor.data,
            sys.len, sys.data,
            abi.len, abi.data
        );
    } else {
        triple = std.format_str(
            "%.*s-%.*s-%.*s",
            arch.len, arch.data,
            vendor.len, vendor.data,
            sys.len, sys.data
        );
    }

    let lltarget: *llvm.Target = null;
    let error: string = null;
    if llvm.get_target_from_triple(triple, &lltarget, &error) {
        delete triple;
        target.is_error = true;
        target.triple_or_error = error;
        return target;
    }

    target.lltarget = lltarget;
    target.triple_or_error = triple;
    return target;
}

def free_target(t: *Target): void {
    if t.is_error {
        llvm.dispose_message(t.triple_or_error);
    } else {
        delete t.triple_or_error;
    }
}

type TargetMachine struct {
    lltm: *llvm.TargetMachine
}

def create_target_machine(target: *Target): TargetMachine {
    dbg.assert(!target.is_error, "passed error target to create_target_machine");

    let default_code_opt_level = 2;
    // we currently want our code to be psysition independent, so that we can
    // link it easily
    let reloc_mode_pic = 2;
    let code_model_default = 0;

    let tm = llvm.create_target_machine(
        target.lltarget,
        target.triple_or_error,
        "generic", // cpu type
        "", // features
        default_code_opt_level,
        reloc_mode_pic,
        code_model_default
    );

    dbg.assert(tm != null, "could not create TargetMachine");

    return TargetMachine {
        lltm: tm
    };
}

def free_target_machine(tm: *TargetMachine): void {
    llvm.dispose_target_machine(tm.lltm);
}

// returns null or an error message
def emit_to_file(
    tm: *TargetMachine,
    mod: *llvm.Module,
    out: path.Path,
    asm: bool
): string {
    let gen_type = 1; // object file
    if asm {
        gen_type = 0; // assembly file
    }

    let file = std.strndup(out.inner, out.len);
    let err: string = null;
    if llvm.target_machine_emit_to_file(tm.lltm, mod, file, gen_type, &err) {
        delete file;
        return err;
    }

    delete file;
    return null;
}
