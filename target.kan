#include "std.h"

import "dbg";
import "std";
import "name";
import "path";
import "llvmc";

#define ARCH_X86_64 1

def arch_x86_64(): Arch {
    return Arch { value: ARCH_X86_64 };
}

#define VENDOR_UNKNOWN 1

def vendor_unknown(): Vendor {
    return Vendor { value: VENDOR_UNKNOWN };
}

#define OS_LINUX 1

def os_linux(): OS {
    return OS { value: OS_LINUX };
}

#define ENV_GNU 1

def env_gnu(): Env {
    return Env { value: ENV_GNU };
}

type Arch struct {
    value: i32
}

def arch_to_name(a: Arch): name.Ref {
    if a.value == ARCH_X86_64 {
        return name.make_ref(6, "x86_64");
    }
    return name.make_ref(0, null);
}

def arch_register(a: Arch): void {
    if a.value == ARCH_X86_64 {
        llvmc.initialize_x86_target_info();
        llvmc.initialize_x86_target();
        llvmc.initialize_x86_target_mc();
        llvmc.initialize_x86_asm_printer();
        return;
    }

    dbg.assert_fmt(0 == 1, "unknown target architecture: %d", a.value);
}

type Vendor struct {
    value: i32
}

def vendor_to_name(a: Vendor): name.Ref {
    if a.value == VENDOR_UNKNOWN {
        return name.make_ref(7, "unknown");
    }
    return name.make_ref(0, null);
}

type OS struct {
    value: i32
}

def os_to_name(a: OS): name.Ref {
    if a.value == OS_LINUX {
        return name.make_ref(5, "linux");
    }
    return name.make_ref(0, null);
}

type Env struct {
    value: i32
}

def env_to_name(a: Env): name.Ref {
    if a.value == ENV_GNU {
        return name.make_ref(3, "gnu");
    }
    return name.make_ref(0, null);
}

type Target struct {
    is_error: bool,
    lltarget: *llvmc.Target,
    triple_or_error: string // llvm message
}

def create_and_register_target(a: Arch, v: Vendor, os: OS, env: Env): Target {
    arch_register(a);

    let arch = arch_to_name(a);
    let vendor = vendor_to_name(v);
    let os = os_to_name(os);
    let env = env_to_name(env);

    let triple = std.format_str(
        "%.*s-%.*s-%.*s-%.*s",
        arch.len, arch.data,
        vendor.len, vendor.data,
        os.len, os.data,
        env.len, env.data
    );

    let target: *llvmc.Target = null;
    let error: string = null;
    if llvmc.get_target_from_triple(triple, &target, &error) {
        delete triple;
        return Target { is_error: true, lltarget: null, triple_or_error: error };
    }

    return Target {
        is_error: false,
        lltarget: target,
        triple_or_error: triple
    };
}

def free_target(t: *Target): void {
    if t.is_error {
        llvmc.dispose_message(t.triple_or_error);
    } else {
        delete t.triple_or_error;
    }
}

type TargetMachine struct {
    lltm: *llvmc.TargetMachine
}

def create_target_machine(target: *Target): TargetMachine {
    dbg.assert(!target.is_error, "passed error target to create_target_machine");

    let default_code_opt_level = 2;
    // we currently want our code to be position independent, so that we can
    // link it easily
    let reloc_mode_pic = 2;
    let code_model_default = 0;

    let tm = llvmc.create_target_machine(
        target.lltarget,
        target.triple_or_error,
        "generic", // cpu type
        "", // features
        default_code_opt_level,
        reloc_mode_pic,
        code_model_default
    );

    dbg.assert(tm != null, "could not create TargetMachine");

    return TargetMachine {
        lltm: tm
    };
}

def free_target_machine(tm: *TargetMachine): void {
    llvmc.dispose_target_machine(tm.lltm);
}

// returns null or an error message
def emit_to_file(
    tm: *TargetMachine,
    mod: *llvmc.Module,
    out: path.Path,
    asm: bool
): string {
    let gen_type = 1; // object file
    if asm {
        gen_type = 0; // assembly file
    }

    let file = std.strndup(out.inner, out.len);
    let err: string = null;
    if llvmc.target_machine_emit_to_file(tm.lltm, mod, file, gen_type, &err) {
        delete file;
        return err;
    }

    delete file;
    return null;
}
