import "dbg";
import "std";
import "name";
import "path";
import "llvm";

#define ARCH_X86_64 1

def arch_x86_64(): Arch {
    return Arch { value: ARCH_X86_64 };
}

#define VENDOR_UNKNOWN 1
#define VENDOR_APPLE   2

def vendor_unknown(): Vendor {
    return Vendor { value: VENDOR_UNKNOWN };
}

def vendor_apple(): Vendor {
    return Vendor { value: VENDOR_APPLE };
}

#define SYS_LINUX  1
#define SYS_DARWIN 2

def sys_linux(): Sys {
    return Sys { value: SYS_LINUX };
}

def sys_darwin(): Sys {
    return Sys { value: SYS_DARWIN };
}

#define ABI_EMPTY 1
#define ABI_GNU   2

def abi_empty(): Abi {
    return Abi { value: ABI_EMPTY };
}

def abi_gnu(): Abi {
    return Abi { value: ABI_GNU };
}

type Arch struct {
    value: i32
}

def arch_to_name(a: Arch): name.Ref {
    if a.value == ARCH_X86_64 {
        return name.make_ref(6, "x86_64");
    }
    return name.make_ref(0, null);
}

def arch_register(a: Arch): void {
    if a.value == ARCH_X86_64 {
        llvm.initialize_x86_target_info();
        llvm.initialize_x86_target();
        llvm.initialize_x86_target_mc();
        llvm.initialize_x86_asm_printer();
        return;
    }

    dbg.assert_fmt(0 == 1, "unknown target architecture: %d", a.value);
}

type Vendor struct {
    value: i32
}

def vendor_to_name(v: Vendor): name.Ref {
    if v.value == VENDOR_UNKNOWN {
        return name.make_ref(7, "unknown");
    }
    if v.value == VENDOR_APPLE {
        return name.make_ref(5, "apple");
    }
    return name.make_ref(0, null);
}

type Sys struct {
    value: i32
}

def sys_to_name(s: Sys): name.Ref {
    if s.value == SYS_LINUX {
        return name.make_ref(5, "linux");
    }
    if s.value == SYS_DARWIN {
        return name.make_ref(6, "darwin");
    }
    return name.make_ref(0, null);
}

type Abi struct {
    value: i32
}

def abi_to_name(a: Abi): name.Ref {
    if a.value == ABI_GNU {
        return name.make_ref(3, "gnu");
    }
    return name.make_ref(0, null);
}

type Target struct {
    is_error: bool,
    lltarget: *llvm.Target,
    triple_or_error: string // llvm message
}

def create_and_register_target(a: Arch, v: Vendor, sys: Sys, abi: Abi): Target {
    arch_register(a);

    let arch = arch_to_name(a);
    let vendor = vendor_to_name(v);
    let sys = sys_to_name(sys);
    let abi = abi_to_name(abi);

    let triple = "";
    // abi can be empty (for example on darwin)
    if abi.data != null {
        triple = std.format_str(
            "%.*s-%.*s-%.*s-%.*s",
            arch.len, arch.data,
            vendor.len, vendor.data,
            sys.len, sys.data,
            abi.len, abi.data
        );
    } else {
        triple = std.format_str(
            "%.*s-%.*s-%.*s",
            arch.len, arch.data,
            vendor.len, vendor.data,
            sys.len, sys.data
        );
    }

    let target: *llvm.Target = null;
    let error: string = null;
    if llvm.get_target_from_triple(triple, &target, &error) {
        delete triple;
        return Target { is_error: true, lltarget: null, triple_or_error: error };
    }

    return Target {
        is_error: false,
        lltarget: target,
        triple_or_error: triple
    };
}

def free_target(t: *Target): void {
    if t.is_error {
        llvm.dispose_message(t.triple_or_error);
    } else {
        delete t.triple_or_error;
    }
}

type TargetMachine struct {
    lltm: *llvm.TargetMachine
}

def create_target_machine(target: *Target): TargetMachine {
    dbg.assert(!target.is_error, "passed error target to create_target_machine");

    let default_code_opt_level = 2;
    // we currently want our code to be psysition independent, so that we can
    // link it easily
    let reloc_mode_pic = 2;
    let code_model_default = 0;

    let tm = llvm.create_target_machine(
        target.lltarget,
        target.triple_or_error,
        "generic", // cpu type
        "", // features
        default_code_opt_level,
        reloc_mode_pic,
        code_model_default
    );

    dbg.assert(tm != null, "could not create TargetMachine");

    return TargetMachine {
        lltm: tm
    };
}

def free_target_machine(tm: *TargetMachine): void {
    llvm.dispose_target_machine(tm.lltm);
}

// returns null or an error message
def emit_to_file(
    tm: *TargetMachine,
    mod: *llvm.Module,
    out: path.Path,
    asm: bool
): string {
    let gen_type = 1; // object file
    if asm {
        gen_type = 0; // assembly file
    }

    let file = std.strndup(out.inner, out.len);
    let err: string = null;
    if llvm.target_machine_emit_to_file(tm.lltm, mod, file, gen_type, &err) {
        delete file;
        return err;
    }

    delete file;
    return null;
}
