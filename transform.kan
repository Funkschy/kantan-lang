#include "std.h"

#define USE_LLVM 1

import "io";
import "std";
import "mod";
import "mir";
import "vec";
import "mirc";
import "path";
import "llvm";
import "target";
import "ptrvec";
import "codegen";

def compile_all(data: mirc.CompilationData, types: ptrvec.Vec): void {
    let n = mod.num_mods(data.mods);

#if USE_LLVM
    let arch = target.arch_x86_64();
    let vendor = target.vendor_unknown();
    let os = target.os_linux();
    let env = target.env_gnu();

    let t = target.create_and_register_target(arch, vendor, os, env);
    if t.is_error {
        io.printf("%s\n", t.triple_or_error);
        return;
    }

    let tm = target.create_target_machine(&t);
    // llvm doesn't handle multithreading very gracefully (we basically
    // need to have everything in one context, but contexts aren't thread safe)
    // But we want to create a single final module, so that we can do lto,
    // therefore, we simply export each modules bitcode into a buffer and then
    // parse those buffers into a single module at the end
    // (see https://lists.llvm.org/pipermail/llvm-dev/2015-June/086296.html)
    let bc_buffers = ptrvec.with_cap(n);
#endif

    // TODO(#64): the mir compilation can be done in parallel
    let i = 0;
    while i < n {
        let m = mod.get_mod(data.mods, i);

        let mir_compiler = mirc.create_mirc(m, &data);
        let mir_mod = mirc.compile(&mir_compiler);

        io.printf("--- mir %s ---\n", mir_mod.actual.name.data);
        mir.dump_module(&mir_mod);
        io.printf("\n");

#if USE_LLVM
        let llvm_context = codegen.compile_mir_mod(&mir_mod);

        io.printf("--- llvm ---\n");
        llvm.dump_module(llvm_context.llmod);
        io.printf("\n");

        llvm.verify_module(llvm_context.llmod, 0, null);
        optimize_single(llvm_context.llmod);

        let buf = llvm.write_bitcode_to_memory_buffer(llvm_context.llmod);
        if buf == null {
            io.printf("Could not write bitcode to buffer");
        }
        ptrvec.set(&bc_buffers, i, buf as *void);

        llvm.dispose_module(llvm_context.llmod);
        llvm.context_dispose(llvm_context.ctx);
#endif

        mirc.free_compiler(&mir_compiler);
        mir.free_mod(&mir_mod);

        i = i + 1;
    }

#if USE_LLVM
    // the context for the final module
    let base_ctx = llvm.context_create();
    let base_mod = llvm.module_create_with_name_in_context("base", base_ctx);

    let i = 0;
    while i < n {
        let buf = ptrvec.get(&bc_buffers, i) as *llvm.MemoryBuffer;

        let mod: *llvm.Module = null;
        if llvm.parse_bitcode_in_context2(base_ctx, buf, &mod) {
            io.printf("Could not parse module\n");
            std.abort();
        }

        llvm.link_modules2(base_mod, mod);

        llvm.dispose_memory_buffer(buf);
        i = i + 1;
    }

    io.printf("--- final ---\n");
    llvm.dump_module(base_mod);

    let out = path.create("out.o", 5);
    let error = target.emit_to_file(&tm, base_mod, out, false);
    if error != null {
        io.printf("%s\n", error);
        llvm.dispose_message(error);
    }

    llvm.dispose_module(base_mod);
    llvm.context_dispose(base_ctx);

    ptrvec.free_v(&bc_buffers);
    target.free_target_machine(&tm);
    target.free_target(&t);
#endif
}

def optimize_single(module: *llvm.Module): void {
    let opt_level_none = 0;
    let opt_level_less = 1;
    let opt_level_default = 2;
    let opt_level_aggressive = 1;

    let opt_level = opt_level_none;

    if opt_level == opt_level_none {
        return;
    }

    // Per clang and rustc, we want to use both kinds.
    let mpm = llvm.create_pass_manager();
    let fpm = llvm.create_function_pass_manager_for_module(module);

    let pm_builder = llvm.pass_manager_builder_create();
    llvm.pass_manager_builder_set_opt_level(pm_builder, opt_level);

    llvm.pass_manager_builder_populate_module_pass_manager(pm_builder, mpm);
    llvm.pass_manager_builder_populate_function_pass_manager(pm_builder, fpm);
    llvm.pass_manager_builder_dispose(pm_builder);

    llvm.initialize_function_pass_manager(fpm);
    llvm.add_promote_memory_to_register_pass(fpm);
    llvm.add_dead_store_elimination_pass(fpm);

    // Iterate over functions, running the FPM over each
    let func = llvm.get_first_function(module);
    while func != null {
        llvm.run_function_pass_manager(fpm, func);
        func = llvm.get_next_function(func);
    }
    llvm.finalize_function_pass_manager(fpm);

    // Run the MPM over the module
    llvm.run_pass_manager(mpm, module);

    // Clean up managers
    llvm.dispose_pass_manager(fpm);
    llvm.dispose_pass_manager(mpm);
}
