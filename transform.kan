#define USE_LLVM 1
#define LLVM_DUMP 0
#define MIR_DUMP 0
#define ENABLE_THREADS 0

import "io";
import "ty";
import "dbg";
import "opt";
import "std";
import "mod";
import "mir";
import "vec";
import "map";
import "mirc";
import "path";
import "llvm";
import "target";
import "ptrvec";
import "codegen";

extern def link_obj_file(obj_name: string, exe_name: string): i32;

// TODO: the unlink function only exists on posix systems, not windows
extern def unlink(filename: string): i32;

// Data which is shared between all Compiler instances
// readonly, since it will be used across threads
type CompilationData struct {
    mods: *mod.Map,
    main_func: *ty.Type,
    proj_root: path.Path,
    global_types: map.Map, // map.Map<ident.Ident, *ty.Type>
    config: *opt.Config,
    std_dir: string
}

def map_data(data: *CompilationData): mirc.CompilationData {
    return mirc.CompilationData {
        mods: data.mods,
        proj_root: data.proj_root,
        global_types: data.global_types,
        char_lits: mirc.CharacterLiterals {
            backslash: std.int_to_char(92),
            new_line: std.int_to_char(10),
            zero: std.int_to_char(0),
            carriage_return: std.int_to_char(13),
            tab: std.int_to_char(9),
            double_quote: std.int_to_char(34),
            single_quote: std.int_to_char(39)
        }
    };
}

def compile_all(comp_data: CompilationData, types: ptrvec.Vec): void {
#if ENABLE_THREADS
    io.printf("Compiling in parallel\n");
    compile_all_parallel(&comp_data, types);
#else
    io.printf("Compiling sequentially\n");
    compile_all_sequential(&comp_data, types);
#endif
}

def compile_all_parallel(comp_data: *CompilationData, types: ptrvec.Vec) {
    dbg.not_implemented();
    // llvm doesn't handle multithreading very gracefully (we basically
    // need to have everything in one context, but contexts aren't thread safe)
    // But we want to create a single final module, so that we can do lto,
    // therefore, we simply export each modules bitcode into a buffer and then
    // parse those buffers into a single module at the end
    // (see https://lists.llvm.org/pipermail/llvm-dev/2015-June/086296.html)
    //
    // implement something like this:
    //
    // let bc_buffers = ptrvec.with_cap(n);
    // llvm.verify_module(llvm_context.llmod, 0, null);
    // optimize_single(llvm_context.llmod, comp_data.config.opt_level);

    // let buf = llvm.write_bitcode_to_memory_buffer(llvm_context.llmod);
    // if buf == null {
    //     io.printf("Could not write bitcode to buffer");
    // }
    // ptrvec.set(&bc_buffers, i, buf as *void);

    // llvm.dispose_module(llvm_context.llmod);
    // llvm.context_dispose(llvm_context.ctx);

    // let buf = ptrvec.get(&bc_buffers, i) as *llvm.MemoryBuffer;

    // let mod: *llvm.Module = null;
    // if llvm.parse_bitcode_in_context2(base_ctx, buf, &mod) {
    //     io.printf("Could not parse module\n");
    //     std.abort();
    // }

    // llvm.link_modules2(base_mod, mod);

    // llvm.dispose_memory_buffer(buf);
}

def compile_all_sequential(comp_data: *CompilationData, types: ptrvec.Vec) {
    let data = map_data(comp_data);
    let n = mod.num_mods(data.mods);
    dbg.assert(n > 0, "no modules to compile");

    let main_mod: *mod.Module = null;
    if comp_data.main_func != null {
        main_mod = ty.as_func(comp_data.main_func).declared_in;
    } else {
        main_mod = mod.get_mod(comp_data.mods, 0);
    }

#if USE_LLVM
    let arch = target.arch_x86_64();
    let vendor = target.vendor_unknown();
    let sys = target.sys_linux();
    let abi = target.abi_gnu();

    let t = target.create_and_register_target(arch, vendor, sys, abi);
    if t.is_error {
        io.printf("%s\n", t.triple_or_error);
        return;
    }

    let tm = target.create_target_machine(&t);
    // the single context used for all modules
    let base_ctx = llvm.context_create();
    let base_mod = llvm.module_create_with_name_in_context(main_mod.name.data, base_ctx);

    let mod_path = mod.get_path(main_mod);
    let dir = path.parent(&mod_path);
    let file = path.create(mod_path.inner + dir.len, mod_path.len - dir.len);
    llvm.set_source_file_name(base_mod, file.inner, file.len);

    let options = codegen.CompilationOptions {
        global_ctx: base_ctx,
        std_dir: comp_data.std_dir,
        target: t,
        debug_info: comp_data.config.debug_info
    };
#endif

    let i = 0;
    while i < n {
        let m = mod.get_mod(data.mods, i);

        let mir_compiler = mirc.create_mirc(m, &data);
        let mir_mod = mirc.compile(&mir_compiler);

#if MIR_DUMP
        io.printf("--- mir %s ---\n", mir_mod.actual.name.data);
        mir.dump_module(&mir_mod);
        io.printf("\n");
#endif

#if USE_LLVM
        let llvm_context = codegen.compile_mir_mod(&mir_mod, &options);
        llvm.verify_module(llvm_context.llmod, 0, null);
        optimize_single(llvm_context.llmod, comp_data.config.opt_level);

        llvm.link_modules2(base_mod, llvm_context.llmod);
#endif

        mirc.free_compiler(&mir_compiler);
        mir.free_mod(&mir_mod);

        i = i + 1;
    }

#if LLVM_DUMP
    io.printf("--- final ---\n");
    llvm.dump_module(base_mod);
    llvm.verify_module(base_mod, 0, null);
#endif

#if USE_LLVM
    emit_to_file(comp_data, base_mod, tm);

    llvm.dispose_module(base_mod);
    llvm.context_dispose(base_ctx);

    target.free_target_machine(&tm);
    target.free_target(&t);
#endif
}

def emit_to_file(comp_data: *CompilationData, base_mod: *llvm.Module, tm: target.TargetMachine) {
    let out_name = "out.o";
    let out_len = 5;
    let gen_asm = false;
    let gen_obj = false;

    if comp_data.config.output_filename != null {
        let len = std.strlen(comp_data.config.output_filename);
        if len >= 3 {
            gen_asm = std.strcmp(comp_data.config.output_filename + (len - 2), ".s") == 0;
            gen_obj = std.strcmp(comp_data.config.output_filename + (len - 2), ".o") == 0;
        }

        if gen_asm || gen_obj {
            out_name = comp_data.config.output_filename;
            out_len = len;
        }
    }

    let out = path.create(out_name, out_len);
    let error = target.emit_to_file(&tm, base_mod, out, gen_asm);
    if error != null {
        io.printf("%s\n", error);
        llvm.dispose_message(error);
        return;
    }

    if !(gen_asm || gen_obj) {
        let exe_name = comp_data.config.output_filename;
        if exe_name == null {
            exe_name = "a.out";
        }

        link_obj_file(out_name, exe_name);
        // use unlink instead of remove, to not accidentally delete some directory
        unlink(out_name);
    }
}

def optimize_single(module: *llvm.Module, opt_level: i32): void {
    // replace this with an enum
    let opt_level_none = 0;
    let opt_level_less = 1;
    let opt_level_default = 2;
    let opt_level_aggressive = 3;

    if opt_level == opt_level_none {
        return;
    }

    // Per clang and rustc, we want to use both kinds.
    let mpm = llvm.create_pass_manager();
    let fpm = llvm.create_function_pass_manager_for_module(module);

    let pm_builder = llvm.pass_manager_builder_create();
    llvm.pass_manager_builder_set_opt_level(pm_builder, opt_level);

    llvm.pass_manager_builder_populate_module_pass_manager(pm_builder, mpm);
    llvm.pass_manager_builder_populate_function_pass_manager(pm_builder, fpm);
    llvm.pass_manager_builder_dispose(pm_builder);

    llvm.initialize_function_pass_manager(fpm);
    llvm.add_promote_memory_to_register_pass(fpm);
    llvm.add_dead_store_elimination_pass(fpm);

    // Iterate over functions, running the FPM over each
    let func = llvm.get_first_function(module);
    while func != null {
        llvm.run_function_pass_manager(fpm, func);
        func = llvm.get_next_function(func);
    }
    llvm.finalize_function_pass_manager(fpm);

    // Run the MPM over the module
    llvm.run_pass_manager(mpm, module);

    // Clean up managers
    llvm.dispose_pass_manager(fpm);
    llvm.dispose_pass_manager(mpm);
}
