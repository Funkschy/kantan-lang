#include "std.h"

#define USE_LLVM 1
#define LLVM_DUMP 0
#define MIR_DUMP 0

import "io";
import "std";
import "mod";
import "mir";
import "vec";
import "map";
import "mirc";
import "path";
import "llvmc";
import "target";
import "ptrvec";
import "codegen";

// Data which is shared between all Compiler instances
// readonly, since it will be used across threads
type CompilationData struct {
    mods: *mod.Map,
    proj_root: path.Path,
    global_types: map.Map // map.Map<ident.Ident, *ty.Type>
}

def map_data(data: *CompilationData): mirc.CompilationData {
    return mirc.CompilationData {
        mods: data.mods,
        proj_root: data.proj_root,
        global_types: data.global_types,
        char_lits: mirc.CharacterLiterals {
            backslash: std.int_to_char(92),
            new_line: std.int_to_char(10),
            zero: std.int_to_char(0),
            carriage_return: std.int_to_char(13),
            tab: std.int_to_char(9),
            double_quote: std.int_to_char(34),
            single_quote: std.int_to_char(39)
        }
    };
}

def compile_all(comp_data: CompilationData, types: ptrvec.Vec): void {
    let data = map_data(&comp_data);
    let n = mod.num_mods(data.mods);

#if USE_LLVM
    let arch = target.arch_x86_64();
    let vendor = target.vendor_unknown();
    let os = target.os_linux();
    let env = target.env_gnu();

    let t = target.create_and_register_target(arch, vendor, os, env);
    if t.is_error {
        io.printf("%s\n", t.triple_or_error);
        return;
    }

    let tm = target.create_target_machine(&t);
    // llvm doesn't handle multithreading very gracefully (we basically
    // need to have everything in one context, but contexts aren't thread safe)
    // But we want to create a single final module, so that we can do lto,
    // therefore, we simply export each modules bitcode into a buffer and then
    // parse those buffers into a single module at the end
    // (see https://lists.llvmc.org/pipermail/llvm-dev/2015-June/086296.html)
    let bc_buffers = ptrvec.with_cap(n);
#endif

    // TODO(#64): the mir compilation can be done in parallel
    let i = 0;
    while i < n {
        let m = mod.get_mod(data.mods, i);

        let mir_compiler = mirc.create_mirc(m, &data);
        let mir_mod = mirc.compile(&mir_compiler);

#if MIR_DUMP
        io.printf("--- mir %s ---\n", mir_mod.actual.name.data);
        mir.dump_module(&mir_mod);
        io.printf("\n");
#endif

#if USE_LLVM
        let llvm_context = codegen.compile_mir_mod(&mir_mod);
#if LLVM_DUMP
        io.printf("--- llvm ---\n");
        llvmc.dump_module(llvm_context.llmod);
        io.printf("\n");
#endif
        llvmc.verify_module(llvm_context.llmod, 0, null);
        optimize_single(llvm_context.llmod);

        let buf = llvmc.write_bitcode_to_memory_buffer(llvm_context.llmod);
        if buf == null {
            io.printf("Could not write bitcode to buffer");
        }
        ptrvec.set(&bc_buffers, i, buf as *void);

        llvmc.dispose_module(llvm_context.llmod);
        llvmc.context_dispose(llvm_context.ctx);
#endif

        mirc.free_compiler(&mir_compiler);
        mir.free_mod(&mir_mod);

        i = i + 1;
    }

#if USE_LLVM
    // the context for the final module
    let base_ctx = llvmc.context_create();
    let base_mod = llvmc.module_create_with_name_in_context("base", base_ctx);

    let i = 0;
    while i < n {
        let buf = ptrvec.get(&bc_buffers, i) as *llvmc.MemoryBuffer;

        let mod: *llvmc.Module = null;
        if llvmc.parse_bitcode_in_context2(base_ctx, buf, &mod) {
            io.printf("Could not parse module\n");
            std.abort();
        }

        llvmc.link_modules2(base_mod, mod);

        llvmc.dispose_memory_buffer(buf);
        i = i + 1;
    }

#if LLVM_DUMP
    io.printf("--- final ---\n");
    llvmc.dump_module(base_mod);
#endif

    let out = path.create("out.o", 5);
    let error = target.emit_to_file(&tm, base_mod, out, false);
    if error != null {
        io.printf("%s\n", error);
        llvmc.dispose_message(error);
    }

    llvmc.dispose_module(base_mod);
    llvmc.context_dispose(base_ctx);

    ptrvec.free_v(&bc_buffers);
    target.free_target_machine(&tm);
    target.free_target(&t);
#endif
}

def optimize_single(module: *llvmc.Module): void {
    let opt_level_none = 0;
    let opt_level_less = 1;
    let opt_level_default = 2;
    let opt_level_aggressive = 1;

    let opt_level = opt_level_none;

    if opt_level == opt_level_none {
        return;
    }

    // Per clang and rustc, we want to use both kinds.
    let mpm = llvmc.create_pass_manager();
    let fpm = llvmc.create_function_pass_manager_for_module(module);

    let pm_builder = llvmc.pass_manager_builder_create();
    llvmc.pass_manager_builder_set_opt_level(pm_builder, opt_level);

    llvmc.pass_manager_builder_populate_module_pass_manager(pm_builder, mpm);
    llvmc.pass_manager_builder_populate_function_pass_manager(pm_builder, fpm);
    llvmc.pass_manager_builder_dispose(pm_builder);

    llvmc.initialize_function_pass_manager(fpm);
    llvmc.add_promote_memory_to_register_pass(fpm);
    llvmc.add_dead_store_elimination_pass(fpm);

    // Iterate over functions, running the FPM over each
    let func = llvmc.get_first_function(module);
    while func != null {
        llvmc.run_function_pass_manager(fpm, func);
        func = llvmc.get_next_function(func);
    }
    llvmc.finalize_function_pass_manager(fpm);

    // Run the MPM over the module
    llvmc.run_pass_manager(mpm, module);

    // Clean up managers
    llvmc.dispose_pass_manager(fpm);
    llvmc.dispose_pass_manager(mpm);
}
