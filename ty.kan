#include "std.h"

import "ptrvec";
import "vec";
import "std";
import "ident";

// TODO: this should be imported, but can't because of circular dependencies
// for some reason, this works anyway
// import "mod";

#define WIDTH_UNKNOWN -1

#define TY_UNKNOWN  0
#define TY_I32      1
#define TY_STRING   2
#define TY_FUNC     3
#define TY_MOD      4
#define TY_STRUCT   5

#define FLAG_SCOPED 1

extern def flag_set(flags: *i32, flag: i32): void;
extern def flag_get(flags: *i32, flag: i32): bool;

/////////// i32 type ///////////

type I32 struct {
    t: Type
}

def new_i32(): *Type {
    let t = (new I32 {
        t: create_type(TY_I32)
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_i32(t: *Type): bool {
    return t.kind == TY_I32;
}

def as_i32(t: *Type): *I32 {
    return t as *I32;
}

/////////// string type ///////////

type String struct {
    t: Type
}

def new_string(): *Type {
    let t = (new String {
        t: create_type(TY_STRING)
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_string(t: *Type): bool {
    return t.kind == TY_STRING;
}

def as_string(t: *Type): *String {
    return t as *String;
}

/////////// func type ///////////

type StructField struct {
    name: ident.Ident,
    ty: *Type
}

type Struct struct {
    t: Type,
    name: ident.Ident,
    fields: vec.Vec // <StructField>
}

def new_struct(name: ident.Ident, fields: vec.Vec): *Type {
    let t = (new Struct {
        t: create_type(TY_STRUCT),
        name: name,
        fields: fields
    }) as *Type;

    flag_set(&t.flags, FLAG_SCOPED);
    fill_width_align(t);

    return t;
}

def is_struct(t: *Type): bool {
    return t.kind == TY_STRUCT;
}

def as_struct(t: *Type): *Struct {
    return t as *Struct;
}

def field_at(t: *Struct, i: i32): *StructField {
    return vec.get_ptr(&t.fields, i) as *StructField;
}

/////////// func type ///////////

type Func struct {
    t: Type,
    ret: *Type,
    params: TypeList,
    name: ident.Ident
}

def new_func(ret: *Type, params: ptrvec.Vec, name: ident.Ident): *Type {
    let params = create_type_list(params);
    let t = (new Func {
        t: create_type(TY_FUNC),
        ret: ret,
        params: params,
        name: name
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_func(t: *Type): bool {
    return t.kind == TY_FUNC;
}

def as_func(t: *Type): *Func {
    return t as *Func;
}

/////////// mod type ///////////

type Mod struct {
    t: Type,
    mod: *mod.Module
}

def new_mod(mod: *mod.Module): *Type {
    let t = (new Mod {
        t: create_type(TY_MOD),
        mod: mod
    }) as *Type;

    flag_set(&t.flags, FLAG_SCOPED);

    return t;
}

def is_mod(t: *Type): bool {
    return t.kind == TY_MOD;
}

def as_mod(t: *Type): *Mod {
    return t as *Mod;
}

/////////// base type ///////////

type Type struct {
    kind: i32,
    width: i32, // width in bytes
    align: i32,
    flags: i32
}

def create_type(kind: i32): Type {
    return Type {
        kind: kind,
        width: 0,
        align: 0,
        flags: 0
    };
}

def is_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return flag_get(&t.flags, FLAG_SCOPED);
}

type TypeList struct {
    types: ptrvec.Vec
}

def empty_type_list(): TypeList {
    return TypeList { types: ptrvec.create() };
}

def create_type_list(types: ptrvec.Vec): TypeList {
    return TypeList { types: types };
}

def type_at(tl: *TypeList, i: i32): *Type {
    return ptrvec.get(&tl.types, i) as *Type;
}

def type_list_free(tl: *TypeList): void {
    let i = 0;
    while i < tl.types.len {
        type_free(type_at(tl, i));
        i = i + 1;
    }
    ptrvec.free_v(&tl.types);
}

def type_free(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        type_free(f_ty.ret);
        type_list_free(&f_ty.params);
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        let i = 0;
        while i < s_ty.fields.len {
            let f = field_at(s_ty, i);
            if f != null {
                type_free(f.ty);
            }
            i = i + 1;
        }
    }

    delete t;
}

/////////// align utils ///////////
// TODO: should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;

    if is_i32(t) {
        width = 4;
    } if is_string(t) {
        width = 8;
    } else if is_struct(t) {
        let s_ty = as_struct(t);
        let max_width = width;

        let i = 0;
        while i < s_ty.fields.len {
            let f = field_at(s_ty, i);
            if f != null {
                let w = f.ty.width;
                if w > max_width {
                    max_width = w;
                }
            }
            i = i + 1;
        }

        width = max_width;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;
        return true;
    }

    return false;
}

def to_string(t: *Type, span_interner: *span.SpanInterner): string {
    if t == null {
        return null;
    }

    if is_i32(t) {
        return std.strdup("i32");
    }

    if is_string(t) {
        return std.strdup("string");
    }

    if is_func(t) {
        // TODO: resolve cyclic dependencies
        let name = "name";
        let s = std.format_str("def %s(...): ...", name);
        return s;
    }

    if is_mod(t) {
        // TODO: use mod name
        return std.strdup("mod");
    }

    return null;
}

def clone(t: *Type): *Type {
    if t == null {
        return null;
    }

    let nt = std.malloc(sizeof Type);
    std.memcpy(nt, t as *void, sizeof Type);
    return nt as *Type;
}
