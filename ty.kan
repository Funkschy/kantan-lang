#include "std.h"

import "ptrvec";
import "ast";

#define WIDTH_UNKNOWN -1

#define TY_UNKNOWN 0
#define TY_I32 1
#define TY_FUNC 2

/////////// i32 type ///////////

def is_i32(t: *Type): bool {
    return t.kind == TY_I32;
}

def make_i32(t: *Type): void {
    t.kind = TY_I32;
    fill_width_align(t);
}

/////////// func type ///////////

type Func struct {
    ret: *Type,
    params: TypeList,
    name: *ast.IdentExpr
}

def make_func(t: *Type, func: *Func): void {
    t.kind = TY_FUNC;
    t.extra = func as *void;
    fill_width_align(t);
}

def new_func(ret: *Type, params: ptrvec.Vec, name: *ast.IdentExpr): *Func {
    let params = create_type_list(params);
    return new Func {
        ret: ret,
        params: params,
        name: name
    };
}

def is_func(t: *Type): bool {
    return t.kind == TY_FUNC;
}

/////////// base type ///////////

type Type struct {
    kind: i32,
    width: i32, // width in bytes
    align: i32,
    extra: *void
}

def new_type(): *Type {
    return new Type {
        kind: TY_UNKNOWN,
        width: 0,
        align: 0,
        extra: null
    };
}

type TypeList struct {
    types: ptrvec.Vec
}

def empty_type_list(): TypeList {
    return TypeList { types: ptrvec.create() };
}

def create_type_list(types: ptrvec.Vec): TypeList {
    return TypeList { types: types };
}

def type_at(tl: *TypeList, i: i32): *Type {
    return ptrvec.get(&tl.types, i) as *Type;
}

def type_list_free(tl: *TypeList): void {
    let i = 0;
    while i < tl.types.len {
        type_free(type_at(tl, i));
        i = i + 1;
    }
    ptrvec.free_v(&tl.types);
}

def type_free(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = t.extra as *Func;
        type_free(f_ty.ret);
        type_list_free(&f_ty.params);
        delete t.extra;
    }

    delete t;
}

/////////// align utils ///////////
// TODO: should be in separate file, but can't because of circular imports

def width_was_calculated(t: *ty.Type): bool {
    return t.align > 0;
}

// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *ty.Type): bool {
    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;

    if t.kind == TY_I32 {
        width = 4;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;
        return true;
    }

    return false;
}
