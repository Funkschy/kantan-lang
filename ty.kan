#include "std.h"
#include "ty_types.h"

import "ptrvec";
import "vec";
import "std";
import "ident";
import "span";
import "scope";

// TODO: this should be imported, but can't because of circular dependencies
// for some reason, this works anyway
// import "mod";

#define WIDTH_UNKNOWN -1

#define FLAG_SCOPED  1
#define FLAG_UNSIZED 2
// TODO: rename this, placeholder is currently used as a check for initalization
#define FLAG_PLACEHOLDER 4

/////////// i32 type ///////////

type I32 struct {
    t: Type
}

def new_i32(): *Type {
    let t = (new I32 {
        t: create_type(TY_I32)
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_i32(t: *Type): bool {
    return t.kind == TY_I32;
}

def as_i32(t: *Type): *I32 {
    return t as *I32;
}

/////////// pointer type ///////////

type Ptr struct {
    t: Type,
    count: i32,
    inner: *ty.Type
}

def new_ptr(count: i32, inner: *ty.Type): *Type {
    let t = (new Ptr {
        t: create_type(TY_PTR),
        count: count,
        inner: inner
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_ptr(t: *Type): bool {
    return t.kind == TY_PTR;
}

def as_ptr(t: *Type): *Ptr {
    return t as *Ptr;
}

/////////// string type ///////////

type String struct {
    t: Type
}

def new_string(): *Type {
    let t = (new String {
        t: create_type(TY_STRING)
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_string(t: *Type): bool {
    return t.kind == TY_STRING;
}

def as_string(t: *Type): *String {
    return t as *String;
}

/////////// struct type ///////////

type StructField struct {
    name: ident.Ident,
    ty: *Type
}

type Struct struct {
    t: Type,
    name: ident.Ident,
    fields: vec.Vec // <StructField>
}

def new_struct(name: ident.Ident, fields: vec.Vec): *Type {
    let t = (new Struct {
        t: create_type(TY_STRUCT),
        name: name,
        fields: fields
    }) as *Type;

    std.flag_set(&t.flags, FLAG_SCOPED);
    fill_width_align(t);

    return t;
}

// this function is used to initialize the placeholder structs of tychk
def init_struct(t: *Type, name: ident.Ident): void {
    let s = Struct {
        t: *t,
        name: name,
        fields: vec.create(sizeof StructField)
    };
    std.flag_set(&s.t.flags, FLAG_SCOPED);

    std.memcpy(t as *void, &s as *void, sizeof Struct);
}

def is_struct(t: *Type): bool {
    return t.kind == TY_STRUCT;
}

def as_struct(t: *Type): *Struct {
    return t as *Struct;
}

def push_field(t: *Struct, name: ident.Ident, ty: *Type): void {
    let field = StructField { name: name, ty: ty };
    vec.push(&t.fields, &field as *void);
}

def field_at(t: *Struct, i: i32): *StructField {
    return vec.get_ptr(&t.fields, i) as *StructField;
}

def num_fields(t: *Struct): i32 {
    return t.fields.len;
}

/////////// func type ///////////

type Func struct {
    t: Type,
    ret: *Type,
    params: TypeList,
    name: ident.Ident
}

def new_func(ret: *Type, params: TypeList, name: ident.Ident): *Type {
    let t = (new Func {
        t: create_type(TY_FUNC),
        ret: ret,
        params: params,
        name: name
    }) as *Type;

    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

// this function is used to initialize the placeholder functions of tychk
def init_func(t: *Type, name: ident.Ident): void {
    let f = Func {
        t: *t,
        ret: null,
        params: empty_type_list(),
        name: name,
    };
    std.flag_set(&t.flags, FLAG_UNSIZED);

    std.memcpy(t as *void, &f as *void, sizeof Func);
}

def is_func(t: *Type): bool {
    return t.kind == TY_FUNC;
}

def as_func(t: *Type): *Func {
    return t as *Func;
}

/////////// mod type ///////////

type Mod struct {
    t: Type,
    scope: scope.Scope
}

def new_mod(): *Type {
    let t = (new Mod {
        t: create_type(TY_MOD),
        scope: scope.create()
    }) as *Type;

    std.flag_set(&t.flags, FLAG_SCOPED);
    std.flag_set(&t.flags, FLAG_UNSIZED);

    return t;
}

def is_mod(t: *Type): bool {
    return t.kind == TY_MOD;
}

def as_mod(t: *Type): *Mod {
    return t as *Mod;
}

/////////// base type ///////////

type Type struct {
    kind: i32,
    width: i32, // width in bytes
    align: i32,
    flags: i32
}

def new_type(kind: i32, size: i32): *Type {
    let mem = std.calloc(size, 1);
    let ty = create_type(kind);

    std.memcpy(mem, &ty as *void, sizeof Type);
    return mem as *Type;
}

def is_placeholder(t: *Type): bool {
    return std.flag_get(&t.flags, FLAG_PLACEHOLDER);
}

def set_placeholder(t: *Type): void {
    std.flag_set(&t.flags, FLAG_PLACEHOLDER);
}

def unset_placeholder(t: *Type): void {
    std.flag_unset(&t.flags, FLAG_PLACEHOLDER);
}

def create_type(kind: i32): Type {
    return Type {
        kind: kind,
        width: WIDTH_UNKNOWN,
        align: 0,
        flags: 0
    };
}

// if the type is not unsized and the with is unknown it wasn't
// constructed correctly
def is_initialized(t: *Type): bool {
    return t.width != WIDTH_UNKNOWN || std.flag_get(&t.flags, FLAG_UNSIZED);
}

def is_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_SCOPED);
}

type TypeList struct {
    types: ptrvec.Vec
}

def empty_type_list(): TypeList {
    return TypeList { types: ptrvec.create() };
}

def create_type_list(types: ptrvec.Vec): TypeList {
    return TypeList { types: types };
}

def push_type(tl: *TypeList, ty: *Type): void {
    ptrvec.push_ptr(&tl.types, ty as *void);
}

def type_at(tl: *TypeList, i: i32): *Type {
    return ptrvec.get(&tl.types, i) as *Type;
}

def free_type_list(tl: *TypeList): void {
    ptrvec.free_v(&tl.types);
}

def type_free(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        // the inner types are garbage collected by tychk
        free_type_list(&f_ty.params);
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        // the inner types are garbage collected by tychk
        vec.free_v(&s_ty.fields);
    }

    if is_mod(t) {
        let m_ty = as_mod(t);
        scope.free_s(&m_ty.scope);
    }

    delete t;
}

// looks for an ident in types with FLAG_SCOPED
def get_scope(t: *Type): *scope.Scope {
    if is_mod(t) {
        return &as_mod(t).scope;
    }

    // FIXME
    // TODO: lookup in structs aswell

    return null;
}

/////////// align utils ///////////
// TODO: should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;
    let has_placeholders = false;

    if is_ptr(t){
        width = 8; // TODO: determine pointer width based on target
    } else if is_i32(t) {
        width = 4;
    } else if is_string(t) {
        width = 8; // TODO: determine pointer width based on target
    } else if is_struct(t) {
        let s_ty = as_struct(t);
        let max_align = align;
        let width_sum = 0;

        let i = 0;
        while i < s_ty.fields.len {
            let f = field_at(s_ty, i);
            let field_initialized = f != null;
            if field_initialized {
                field_initialized = f.ty != null;
            }

            if field_initialized {
                let is_placeholder = std.flag_get(&f.ty.flags, FLAG_PLACEHOLDER);

                if is_placeholder {
                    has_placeholders = true;
                } else {
                    let a = f.ty.align;
                    if a > max_align {
                        max_align = a;
                    }

                    let w = f.ty.width;
                    width_sum = width_sum + w;
                }
            } else {
                has_placeholders = true;
            }

            i = i + 1;
        }

        width = width_sum;
        align = max_align;
    }

    if has_placeholders {
        return false;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;
        return true;
    }

    return false;
}

def to_string(t: *Type, span_interner: *span.SpanInterner): string {
    if t == null {
        return null;
    }

    if is_i32(t) {
        return std.strdup("i32");
    }

    if is_string(t) {
        return std.strdup("string");
    }

    if is_func(t) {
        // TODO: resolve cyclic dependencies
        let name = "name";
        let s = std.format_str("def %s(...): ...", name);
        return s;
    }

    if is_mod(t) {
        return std.strdup("mod");
    }

    if is_struct(t) {
        return std.strdup("struct definition");
    }

    return null;
}

def clone(t: *Type): *Type {
    if t == null {
        return null;
    }

    let nt = std.malloc(sizeof Type);
    std.memcpy(nt, t as *void, sizeof Type);
    return nt as *Type;
}
