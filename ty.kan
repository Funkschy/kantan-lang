import "str";
import "dbg";
import "std";
import "mod";
import "vec";
import "vmap";
import "span";
import "name";
import "scope";
import "ident";
import "ptrvec";

extern def type2str(kind: Kind): string;

// the order is important, if it is changed, the order of strings in lib.h also has to change
type Kind enum {
    Error, Ptr, Bool, I32, F32, Char, Void, Func, Mod, Struct, Enum
}

// TODO(#15): this should be imported, but can't because of circular dependencies
//  for some reason, this works anyway
//  import "mod";

#define WIDTH_UNKNOWN -1

// These flags have to be powers of 2
#define FLAG_SCOPED        1
#define FLAG_UNSIZED       2
// this gets set, when tychk visits a type for the first time and gets unset
// when the type is fully resolved
#define FLAG_TYCHK_TOUCHED 4
// if this flag is set, this type refers to a declaration, not an actual instance
// this is used to check for things like 'bool == false' which would be legal otherwise
#define FLAG_TY_DECL       8

/////////// error type ///////////

def new_error(): *Type {
    let t = new_type(Kind.Error, null);
    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

def is_error(t: *Type): bool {
    return t.kind == Kind.Error;
}

/////////// void type ///////////

// TODO(#84): remove void type. Replace it with byte type and empty return types

def new_void(): *Type {
    let t = new_type(Kind.Void, null);
    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

def is_void(t: *Type): bool {
    return t.kind == Kind.Void;
}

/////////// i32 type ///////////

def new_i32(): *Type {
    let t = new_type(Kind.I32, null);
    fill_width_align(t);
    return t;
}

def is_i32(t: *Type): bool {
    return t.kind == Kind.I32;
}

/////////// f32 type ///////////

def new_f32(): *Type {
    let t = new_type(Kind.F32, null);
    fill_width_align(t);
    return t;
}

def is_f32(t: *Type): bool {
    return t.kind == Kind.F32;
}

/////////// char type ///////////

def new_char(): *Type {
    let t = new_type(Kind.Char, null);
    fill_width_align(t);
    return t;
}

def is_char(t: *Type): bool {
    return t.kind == Kind.Char;
}

/////////// bool type ///////////

def new_bool(): *Type {
    let t = new_type(Kind.Bool, null);
    fill_width_align(t);
    return t;
}

def is_bool(t: *Type): bool {
    return t.kind == Kind.Bool;
}

/////////// pointer type ///////////

// TODO(#22): remember to make the result of pointer subtraction dependent on the
//  pointers types
type Ptr struct {
    count: i32,
    inner: *Type
}

// TODO(#28): don't allow pointers to Mod or other non-runtime abstractions (e.g Types)
//  should we actually check this here, or just in the typechecker itself?
def new_ptr(count: i32, inner: *Type): *Type {
    if inner != null && is_ptr(inner) {
        count = count + as_ptr(inner).count;
        inner = as_ptr(inner).inner;
    }

    let ptr = new Ptr {
        count: count,
        inner: inner
    };

    let t = new_type(Kind.Ptr, ptr as *void);
    if inner != null && count < 2 {
        // only auto deref once
        t.flags = inner.flags;
    }

    // pointers always have a size
    std.flag_unset(&t.flags, FLAG_UNSIZED);
    // you cannot declare a pointer
    std.flag_unset(&t.flags, FLAG_TY_DECL);
    fill_width_align(t);
    return t;
}

def update_inner(ptr_ty: *Type, inner: *Type): void {
    let p = as_ptr(ptr_ty);

    if inner != null && is_ptr(inner) {
        inner = as_ptr(inner).inner;
        p.count = p.count + as_ptr(inner).count;
    }

    p.inner = inner;
    // only auto deref once
    if p.count < 2 {
        // use flags from inner type, except for unsized and decl
        ptr_ty.flags = inner.flags;
    }
    // pointers always have a size
    std.flag_unset(&ptr_ty.flags, FLAG_UNSIZED);
    // you cannot declare a pointer
    std.flag_unset(&ptr_ty.flags, FLAG_TY_DECL);
}

def is_ptr(t: *Type): bool {
    return t.kind == Kind.Ptr;
}

def as_ptr(t: *Type): *Ptr {
    return t.data as *Ptr;
}

def is_string(t: *Type): bool {
    return is_ptr(t) && as_ptr(t).count == 1 && is_char(as_ptr(t).inner);
}

/////////// struct type ///////////

type StructField struct {
    name: ident.Ident,
    ty: *Type,
    offset: i32 // gets set during fill_width_align
}

type Struct struct {
    name: ident.Ident,
    mangled_name: name.Owned,
    scope: scope.Scope,
    declared_in: *mod.Module,
    fields: vec.Vec // <StructField>
}

// this function is used to initialize placeholder structs of tychk
def init_struct(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module
): void {
    let s = new Struct {
        name: name,
        mangled_name: mangled_name,
        scope: scope.create(),
        declared_in: declared_in,
        fields: vec.create(sizeof StructField)
    };

    t.data = s as *void;
    t.width = WIDTH_UNKNOWN;
    std.flag_set(&t.flags, FLAG_SCOPED);
}

def is_struct(t: *Type): bool {
    return t.kind == Kind.Struct;
}

def is_struct_decl(t: *Type): bool {
    return is_struct(t) && is_decl(t);
}

def push_field(t: *Struct, name: ident.Ident, ty: *Type): void {
    let field = StructField { name: name, ty: ty, offset: 0 };
    vec.push(&t.fields, &field as *void);
    scope.bind_in(&t.scope, &name, ty);
}

def field_at(t: *Struct, i: i32): *StructField {
    return vec.get_ptr(&t.fields, i) as *StructField;
}

// get the index of the field with name 'name'
// returns -1 if the field does not exist
// if out_field_ty is not null, it is set to the type of the field
// TODO(#85): Struct should have a vmap for its fields
def field_idx(t: *Struct, name: ident.Ident, out_field_ty: **Type): i32 {
    let i = 0;
    while i < t.fields.len {
        let f = field_at(t, i);
        if ident.eq_value(&name, &f.name) {
            if out_field_ty != null {
                *out_field_ty = f.ty;
            }
            return i;
        }
        i = i + 1;
    }

    return -1;
}

def update_field_ty(t: *Struct, field: *StructField): void {
    scope.bind_in(&t.scope, &field.name, field.ty);
}

def num_fields(t: *Struct): i32 {
    return t.fields.len;
}

def as_struct(t: *Type): *Struct {
    return t.data as *Struct;
}

/////////// enum type ///////////

type EnumValue struct {
    name: ident.Ident,
    value: i32
}

type Enum struct {
    name: ident.Ident,
    mangled_name: name.Owned,
    scope: scope.Scope,
    declared_in: *mod.Module,
    base_ty: *Type, // currently only i32
    values: vmap.Map // vmap.Map<ident.Ident, EnumValue>
}

// this function is used to initialize placeholder enums of tychk
def init_enum(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module,
    base_ty: *Type
): void {
    dbg.assert(base_ty != null, "base_ty was null");

    let s = new Enum {
        name: name,
        mangled_name: mangled_name,
        scope: scope.create(),
        declared_in: declared_in,
        base_ty: base_ty,
        values: vmap.create(sizeof EnumValue)
    };

    t.data = s as *void;
    std.flag_set(&t.flags, FLAG_SCOPED);
    fill_width_align(t);
}

def is_enum(t: *Type): bool {
    return t.kind == Kind.Enum;
}

def is_enum_decl(t: *Type): bool {
    return is_enum(t) && is_decl(t);
}

def as_enum(t: *Type): *Enum {
    return t.data as *Enum;
}

def num_values(t: *Enum): i32 {
    return t.values.values.len;
}

// returns true, if the value was already in the enum
def push_value(t: *Type, name: ident.Ident, value: i32): bool {
    let e_ty = as_enum(t);
    let key = vmap.key_from_ident(&name);

    if vmap.get_ptr(&e_ty.values, key) != null {
        return true;
    }

    let value = EnumValue { name: name, value: value };
    vmap.insert(&e_ty.values, key, &value as *void);

    let field_type = instance_of(t);
    // all enum values have the enum itself as their type
    scope.bind_in(&e_ty.scope, &name, field_type);
    return false;
}

def value_at(t: *Enum, i: i32): *EnumValue {
    return vmap.get_ptr_idx(&t.values, i) as *EnumValue;
}

def value_by_name(t: *Enum, name: ident.Ident): *EnumValue {
    let key = vmap.key_from_ident(&name);
    return vmap.get_ptr(&t.values, key) as *EnumValue;
}

/////////// func type ///////////

type Param struct {
    name: ident.Ident,
    ty: *Type
}

def create_param(name: ident.Ident, ty: *Type): Param {
    return Param { name: name, ty: ty };
}

type Func struct {
    is_extern: bool,
    is_varargs: bool,
    declared_in: *mod.Module,
    ret: *Type,
    params: vec.Vec, // <Param>
    name: ident.Ident,
    mangled_name: name.Owned
}

// this function is used to initialize placeholder functions of tychk
def init_func(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module,
    is_extern: bool
): void {
    let f = new Func {
        is_extern: is_extern,
        // the way that tychk currently works, is that this is set lazily, while
        // checking the parameters types
        is_varargs: false,
        declared_in: declared_in,
        ret: null,
        params: vec.create(sizeof Param),
        name: name,
        mangled_name: mangled_name
    };
    std.flag_set(&t.flags, FLAG_UNSIZED);

    t.data = f as *void;
}

// TODO(#33): this is inefficient
//  do we actually need to iterate everything all the time? We don't want to
//  iterate over the params, which were already initialized last time
def func_is_initalized(t: *Func): bool {
    if t.ret == null {
        return false;
    }

    let i = 0;
    while i < t.params.len {
        let p = param_at(t, i);
        if p.ty == null {
            return false;
        }
        i = i + 1;
    }

    return true;
}

// returns: idx of param with name or -1
def find_param_idx(t: *Func, name: *ident.Ident): i32 {
    let i = 0;
    while i < t.params.len {
        let p = param_at(t, i);
        if ident.eq_value(&p.name, name) {
            return i;
        }
        i = i + 1;
    }
    return -1;
}

def param_at(t: *Func, i: i32): *Param {
    return vec.get_ptr(&t.params, i) as *Param;
}

def is_func(t: *Type): bool {
    return t.kind == Kind.Func;
}

def as_func(t: *Type): *Func {
    return t.data as *Func;
}

/////////// mod type ///////////

type Mod struct {
    scope: scope.Scope
}

def new_mod(): *Type {
    let m = new Mod {
        scope: scope.create()
    };

    let t = new_type(Kind.Mod, m as *void);

    std.flag_set(&t.flags, FLAG_SCOPED);
    std.flag_set(&t.flags, FLAG_UNSIZED);

    return t;
}

def is_mod(t: *Type): bool {
    return t.kind == Kind.Mod;
}

def as_mod(t: *Type): *Mod {
    return t.data as *Mod;
}

/////////// base type ///////////

type Type struct {
    kind: Kind,
    width: i32, // width in bytes
    align: i32,
    flags: i32,
    data: *void, // extra data, eg. 'Struct' or 'Func'
    cached_instance: *Type // only ever create one instance of a single type
}

def new_type(kind: Kind, data: *void): *Type {
    return new create_type(kind, data);
}

def was_touched_by_tychk(t: *Type): bool {
    return std.flag_get(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_touch(t: *Type): void {
    std.flag_set(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_untouch(t: *Type): void {
    std.flag_unset(&t.flags, FLAG_TYCHK_TOUCHED);
}

def create_type(kind: Kind, data: *void): Type {
    return Type {
        kind: kind,
        width: WIDTH_UNKNOWN,
        align: 0,
        flags: FLAG_TY_DECL, // types are declarations by default
        data: data,
        cached_instance: null
    };
}

def instance_of(base: *Type): *Type {
    if base.cached_instance != null {
        return base.cached_instance;
    }

    let inst = new *base;
    std.flag_unset(&inst.flags, FLAG_TY_DECL);
    base.cached_instance = inst;

    return inst;
}

def is_decl(t: *Type): bool {
    return std.flag_get(&t.flags, FLAG_TY_DECL);
}

def is_sized(t: *Type): bool {
    return !std.flag_get(&t.flags, FLAG_UNSIZED);
}

// if the type is not unsized and the with is unknown it wasn't
// constructed correctly
def is_initialized(t: *Type): bool {
    return t != null
        && ((t.width != WIDTH_UNKNOWN && t.align > 0) || std.flag_get(&t.flags, FLAG_UNSIZED));
}

def is_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_SCOPED);
}

def free_ty(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        name.free_owned(&f_ty.mangled_name);
        // the inner types are garbage collected by tychk
        vec.free_v(&f_ty.params);
        delete t.data;
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        name.free_owned(&s_ty.mangled_name);
        // the inner types are garbage collected by tychk
        vec.free_v(&s_ty.fields);
        scope.free_s(&s_ty.scope);
        delete t.data;
    }

    if is_enum(t) {
        let e_ty = as_enum(t);
        name.free_owned(&e_ty.mangled_name);
        vmap.free_m(&e_ty.values);
        scope.free_s(&e_ty.scope);
        delete t.data;
    }

    if is_mod(t) {
        let m_ty = as_mod(t);
        scope.free_s(&m_ty.scope);
        delete t.data;
    }

    if is_ptr(t) {
        delete t.data;
    }

    if t.cached_instance != null {
        delete t.cached_instance;
    }

    delete t;
}

// looks for an ident in types with FLAG_SCOPED
def get_scope(t: *Type): *scope.Scope {
    if is_mod(t) {
        return &as_mod(t).scope;
    }

    if is_struct(t) {
        return &as_struct(t).scope;
    }

    if is_enum(t) {
        return &as_enum(t).scope;
    }

    if is_ptr(t) {
        return get_scope(as_ptr(t).inner);
    }

    return null;
}

def is_num(t: *Type): bool {
    return is_i32(t) || is_f32(t);
}

def is_integer(t: *Type): bool {
    return is_i32(t);
}

def is_comparable(t: *Type): bool {
    return is_num(t)
        || is_ptr(t)
        || is_char(t)
        || is_enum(t);
}

/////////// align utils ///////////
// TODO(#36): should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the struct has uninitialized fields
def calc_struct_width_align(s_ty: *Struct, width: *i32, align: *i32): bool {
    let max_align = 1;
    let width_sum = 0;

    for let i = 0; i < s_ty.fields.len; i = i + 1 {
        let f = field_at(s_ty, i);
        if f == null || !is_initialized(f.ty) {
            return true;
        }

        if f.ty.align > max_align {
            max_align = f.ty.align;
        }

        // s: string,  width: 8, align: 8, offset: 0,  padding: 0    , width_sum: 8
        // c: char,    width: 1, align: 1, offset: 8,  padding: 0    , width_sum: 9
        // x: i32      width: 4, align: 4, offset: 12, padding: 4 - 1,

        let padding = 0;
        let rem = width_sum % f.ty.align;
        if width_sum > 0 && rem != 0 {
            padding = f.ty.align - rem;
        }

        f.offset = width_sum + padding;

        let real_width = f.ty.width + padding;
        width_sum = width_sum + real_width;
    }

    let rem = width_sum % max_align;
    if rem != 0 {
        width_sum = width_sum + (max_align - rem);
    }

    *width = width_sum;
    *align = max_align;

    return false;
}

// TODO(#38): implement either lookup table or full method dispatching for Type
// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if std.flag_get(&t.flags, FLAG_UNSIZED) {
        return false;
    }

    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;
    let has_unresolved_fields = false;

    if is_ptr(t) {
        width = 8; // TODO(#42): determine pointer width based on target
    } else if is_i32(t) {
        width = 4;
    } else if is_f32(t) {
        width = 4;
    } else if is_bool(t) {
        width = 1;
    } else if is_char(t) {
        width = 1;
    } else if is_struct(t) {
        let s_ty = as_struct(t);
        has_unresolved_fields = calc_struct_width_align(s_ty, &width, &align);
    } else if is_enum(t) {
        let e_ty = as_enum(t);
        fill_width_align(e_ty.base_ty);
        width = e_ty.base_ty.width;
        align = e_ty.base_ty.align;
    }

    if has_unresolved_fields {
        return false;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;

        if t.cached_instance != null {
            t.cached_instance.width = width;
            t.cached_instance.align = align;
        }

        return true;
    }

    return false;
}

// returns true if the string needs to be freed
def to_string(t: *Type, out: *string): bool {
    return to_string_mangled(t, true, out);
}

// returns true if the string needs to be freed
def to_string_mangled(t: *Type, use_mangled: bool, out: *string): bool {
    if t == null {
        *out = null;
        return false;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        let s_ret = ")";
        let free_ret = to_string(f_ty.ret, &s_ret);

        let buf = str.create_buf();
        for let i = 0; i < f_ty.params.len; i = i + 1 {
            if i > 0 {
                str.append(&buf, 2, ", ");
            }

            let p = param_at(f_ty, i);

            let p_ty_s = "";
            let free_p_ty_s = to_string_mangled(p.ty, use_mangled, &p_ty_s);
            let len = std.strlen(p_ty_s);

            str.append(&buf, len, p_ty_s);

            if free_p_ty_s {
                delete p_ty_s;
            }
        }

        let s = std.format_str("(%s) -> %s", buf.content, s_ret);
        if free_ret {
            delete s_ret;
        }

        str.free_buf(&buf);

        *out = s;
        return true;
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        if use_mangled {
            *out = s_ty.mangled_name.data;
            return false;
        }

        *out = ident.to_string(&s_ty.name);
        return true;
    }

    if is_enum(t) {
        let e_ty = as_enum(t);
        if use_mangled {
            *out = e_ty.mangled_name.data;
            return false;
        }

        *out = ident.to_string(&e_ty.name);
        return true;
    }

    if is_ptr(t) {
        let p_ty = as_ptr(t);
        let count = p_ty.count;

        let s_inner = "";
        let free_inner = false;

        if p_ty.inner != null && is_char(p_ty.inner) {
            count = count - 1;
            s_inner = "string";
        } else {
            free_inner = to_string_mangled(p_ty.inner, use_mangled, &s_inner);
        }

        let asterisks = std.malloc(count) as string;
        std.memset(asterisks as *void, std.char_to_int('*'), count);
        let s = std.format_str("%.*s%s", count, asterisks, s_inner);

        if free_inner {
            delete s_inner;
        }
        delete asterisks;

        *out = s;
        return true;
    }

    *out = to_static_string(t);
    return false;
}

def to_static_string(t: *Type): string {
    // since string is just an alias, this would normaly output 'pointer'
    if is_string(t) {
        return "string";
    }

    return type2str(t.kind);
}

def equals(first: *Type, second: *Type): bool {
    if first == null || second == null {
        return false;
    }

    if first.kind != second.kind {
        return false;
    }

    let first_ptr_count = 0;
    let second_ptr_count = 0;

    if is_ptr(first) {
        let p_ty = as_ptr(first);
        first_ptr_count = p_ty.count;
        first = p_ty.inner;
    }
    if is_ptr(second) {
        let p_ty = as_ptr(second);
        second_ptr_count = p_ty.count;
        second = p_ty.inner;
    }

    // only pointers and struct instances are created multiple times, everything
    // else should be unique in memory
    return first == second && first_ptr_count == second_ptr_count;
}
