import "str";
import "dbg";
import "std";
import "mod";
import "vec";
import "vmap";
import "span";
import "name";
import "scope";
import "ident";
import "ptrvec";

extern def type2str(kind: Kind): string;

// the order is important, if it is changed, the order of strings in lib.h also has to change
type Kind enum {
    Error, Ptr, Bool, I32, F32, I64, Char, Void, Func, Mod, Struct, Enum
}

// TODO(#15): this should be imported, but can't because of circular dependencies
//  for some reason, this works anyway
//  import "mod";

#define WIDTH_UNKNOWN -1

// These flags have to be powers of 2
#define FLAG_TYPE_SCOPED   1
#define FLAG_VALUE_SCOPED  2
#define FLAG_UNSIZED       4
// this gets set, when tychk visits a type for the first time and gets unset
// when the type is fully resolved
#define FLAG_TYCHK_TOUCHED 8

/////////// error type ///////////

def new_error(): *Type {
    let t = new_type(Kind.Error, null);
    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

def is_error(t: *Type): bool {
    return t.kind == Kind.Error;
}

/////////// void type ///////////

// TODO(#84): remove void type. Replace it with byte type and empty return types

def new_void(): *Type {
    let t = new_type(Kind.Void, null);
    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

def is_void(t: *Type): bool {
    return t.kind == Kind.Void;
}

/////////// i32 type ///////////

def new_i32(): *Type {
    let t = new_type(Kind.I32, null);
    fill_width_align(t);
    return t;
}

def is_i32(t: *Type): bool {
    return t.kind == Kind.I32;
}

/////////// i64 type ///////////

def new_i64(): *Type {
    let t = new_type(Kind.I64, null);
    fill_width_align(t);
    return t;
}

def is_i64(t: *Type): bool {
    return t.kind == Kind.I64;
}

/////////// f32 type ///////////

def new_f32(): *Type {
    let t = new_type(Kind.F32, null);
    fill_width_align(t);
    return t;
}

def is_f32(t: *Type): bool {
    return t.kind == Kind.F32;
}

/////////// char type ///////////

def new_char(): *Type {
    let t = new_type(Kind.Char, null);
    fill_width_align(t);
    return t;
}

def is_char(t: *Type): bool {
    return t.kind == Kind.Char;
}

/////////// bool type ///////////

def new_bool(): *Type {
    let t = new_type(Kind.Bool, null);
    fill_width_align(t);
    return t;
}

def is_bool(t: *Type): bool {
    return t.kind == Kind.Bool;
}

/////////// pointer type ///////////

// TODO(#22): remember to make the result of pointer subtraction dependent on the
//  pointers types
type Ptr struct {
    count: i32,
    inner: *Type
}

// TODO(#28): don't allow pointers to Mod or other non-runtime abstractions (e.g Types)
//  should we actually check this here, or just in the typechecker itself?
def new_ptr(count: i32, inner: *Type): *Type {
    if inner != null && is_ptr(inner) {
        count = count + as_ptr(inner).count;
        inner = as_ptr(inner).inner;
    }

    let ptr = new Ptr {
        count: count,
        inner: inner
    };

    let t = new_type(Kind.Ptr, ptr as *void);
    if inner != null && count < 2 {
        // only auto deref once
        t.flags = inner.flags;
    }

    // pointers always have a size
    std.flag_unset(&t.flags, FLAG_UNSIZED);
    fill_width_align(t);
    return t;
}

def update_inner(ptr_ty: *Type, inner: *Type): void {
    let p = as_ptr(ptr_ty);

    if inner != null && is_ptr(inner) {
        inner = as_ptr(inner).inner;
        p.count = p.count + as_ptr(inner).count;
    }

    p.inner = inner;
    // only auto deref once
    if p.count < 2 {
        // use flags from inner type, except for unsized and decl
        ptr_ty.flags = inner.flags;
    }
    // pointers always have a size
    std.flag_unset(&ptr_ty.flags, FLAG_UNSIZED);
}

def is_ptr(t: *Type): bool {
    return t.kind == Kind.Ptr;
}

def as_ptr(t: *Type): *Ptr {
    return t.data as *Ptr;
}

def is_string(t: *Type): bool {
    return is_ptr(t) && as_ptr(t).count == 1 && is_char(as_ptr(t).inner);
}

type UserDefinedType struct {
    original_name: ident.Ident,
    mangled_name: name.Owned,
    scope: scope.Scope,
    declared_in: *mod.Module
}

def is_user_defined(t: *Type): bool {
    return is_struct(t) || is_enum(t);
}

def get_user_defined(t: *Type): *UserDefinedType {
    return t.data as *UserDefinedType;
}

/////////// struct type ///////////

type StructField struct {
    name: ident.Ident,
    ty: *Type,
    offset: i32 // gets set during fill_width_align
}

type Struct struct {
    super: UserDefinedType,
    fields: vec.Vec // <StructField>
}

// this function is used to initialize placeholder structs of tychk
def init_struct(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module
): void {
    let s = new Struct {
        super: UserDefinedType {
            name: name,
            mangled_name: mangled_name,
            scope: scope.create(),
            declared_in: declared_in
        },
        fields: vec.create(sizeof StructField)
    };

    t.data = s as *void;
    t.width = WIDTH_UNKNOWN;
    std.flag_set(&t.flags, FLAG_VALUE_SCOPED);
}

def is_struct(t: *Type): bool {
    return t.kind == Kind.Struct;
}

def push_field(t: *Struct, name: ident.Ident, ty: *Type): void {
    let field = StructField { name: name, ty: ty, offset: 0 };
    vec.push(&t.fields, &field as *void);
    scope.bind_in(&t.super.scope, &name, ty);
}

def field_at(t: *Struct, i: i32): *StructField {
    return vec.get_ptr(&t.fields, i) as *StructField;
}

// get the index of the field with name 'name'
// returns -1 if the field does not exist
// if out_field_ty is not null, it is set to the type of the field
// TODO(#85): Struct should have a vmap for its fields
def field_idx(t: *Struct, name: ident.Ident, out_field_ty: **Type): i32 {
    let i = 0;
    while i < t.fields.len {
        let f = field_at(t, i);
        if ident.eq_value(&name, &f.name) {
            if out_field_ty != null {
                *out_field_ty = f.ty;
            }
            return i;
        }
        i = i + 1;
    }

    return -1;
}

def update_field_ty(t: *Struct, field: *StructField): void {
    scope.bind_in(&t.super.scope, &field.name, field.ty);
}

def num_fields(t: *Struct): i32 {
    return t.fields.len;
}

def as_struct(t: *Type): *Struct {
    return t.data as *Struct;
}

/////////// enum type ///////////

type EnumValue struct {
    name: ident.Ident,
    value: i32
}

type Enum struct {
    super: UserDefinedType,
    base_ty: *Type, // currently only i32
    values: vmap.Map // vmap.Map<ident.Ident, EnumValue>
}

// this function is used to initialize placeholder enums of tychk
def init_enum(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module,
    base_ty: *Type
): void {
    dbg.assert(base_ty != null, "base_ty was null");

    let s = new Enum {
        super: UserDefinedType {
            name: name,
            mangled_name: mangled_name,
            scope: scope.create(),
            declared_in: declared_in
        },
        base_ty: base_ty,
        values: vmap.create(sizeof EnumValue)
    };

    t.data = s as *void;
    std.flag_set(&t.flags, FLAG_VALUE_SCOPED);
    fill_width_align(t);
}

def is_enum(t: *Type): bool {
    return t.kind == Kind.Enum;
}

def as_enum(t: *Type): *Enum {
    return t.data as *Enum;
}

def num_values(t: *Enum): i32 {
    return t.values.values.len;
}

// returns true, if the value was already in the enum
def push_enum_value(t: *Type, name: ident.Ident, value: i32): bool {
    let e_ty = as_enum(t);
    let key = vmap.key_from_ident(&name);

    // TODO: instead of a fake "len" value, we should just have a len() compile time function
    if vmap.get_ptr(&e_ty.values, key) != null || ident.eq_lit(&name, "len") {
        return true;
    }

    let value = EnumValue { name: name, value: value };
    vmap.insert(&e_ty.values, key, &value as *void);

    let field_type = t;
    // all enum values have the enum itself as their type
    scope.bind_in(&e_ty.super.scope, &name, field_type);
    return false;
}

def value_at(t: *Enum, i: i32): *EnumValue {
    return vmap.get_ptr_idx(&t.values, i) as *EnumValue;
}

def enum_value_by_name(t: *Enum, name: ident.Ident): i32 {
    // since there is no Ident for "len", we just cheat a bit
    if ident.eq_lit(&name, "len") {
        return vmap.len(&t.values);
    }

    let key = vmap.key_from_ident(&name);
    return (vmap.get_ptr(&t.values, key) as *EnumValue).value;
}

/////////// func type ///////////

type Param struct {
    name: ident.Ident,
    ty: *Type
}

def create_param(name: ident.Ident, ty: *Type): Param {
    return Param { name: name, ty: ty };
}

type Func struct {
    is_extern: bool,
    is_varargs: bool,
    declared_in: *mod.Module,
    ret: *Type,
    params: vec.Vec, // <Param>
    name: ident.Ident,
    mangled_name: name.Owned
}

// this function is used to initialize placeholder functions of tychk
def init_func(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module,
    is_extern: bool
): void {
    let f = new Func {
        is_extern: is_extern,
        // the way that tychk currently works, is that this is set lazily, while
        // checking the parameters types
        is_varargs: false,
        declared_in: declared_in,
        ret: null,
        params: vec.create(sizeof Param),
        name: name,
        mangled_name: mangled_name
    };
    std.flag_set(&t.flags, FLAG_UNSIZED);

    t.data = f as *void;
}

// TODO(#33): this is inefficient
//  do we actually need to iterate everything all the time? We don't want to
//  iterate over the params, which were already initialized last time
def func_is_initalized(t: *Func): bool {
    if t.ret == null {
        return false;
    }

    let i = 0;
    while i < t.params.len {
        let p = param_at(t, i);
        if p.ty == null {
            return false;
        }
        i = i + 1;
    }

    return true;
}

// returns: idx of param with name or -1
def find_param_idx(t: *Func, name: *ident.Ident): i32 {
    let i = 0;
    while i < t.params.len {
        let p = param_at(t, i);
        if ident.eq_value(&p.name, name) {
            return i;
        }
        i = i + 1;
    }
    return -1;
}

def param_at(t: *Func, i: i32): *Param {
    return vec.get_ptr(&t.params, i) as *Param;
}

def is_func(t: *Type): bool {
    return t.kind == Kind.Func;
}

def as_func(t: *Type): *Func {
    return t.data as *Func;
}

def is_callable(t: *Type): bool {
    return is_func(t)
        || (is_ptr(t) && as_ptr(t).count == 1 && is_func(as_ptr(t).inner));
}

def callable_as_func(t: *Type): *Func {
    if is_func(t) {
        return as_func(t);
    }
    return as_func(as_ptr(t).inner);
}

/////////// mod type ///////////

type Mod struct {
    types: scope.Scope
    values: scope.Scope
}

def new_mod(): *Type {
    let m = new Mod {
        types: scope.create(),
        values: scope.create()
    };

    let t = new_type(Kind.Mod, m as *void);

    std.flag_set(&t.flags, FLAG_TYPE_SCOPED);
    std.flag_set(&t.flags, FLAG_VALUE_SCOPED);
    std.flag_set(&t.flags, FLAG_UNSIZED);

    return t;
}

def is_mod(t: *Type): bool {
    return t.kind == Kind.Mod;
}

def as_mod(t: *Type): *Mod {
    return t.data as *Mod;
}

/////////// base type ///////////

type Type struct {
    kind: Kind,
    width: i32, // width in bytes
    align: i32,
    flags: i32,
    data: *void // extra data, eg. 'Struct' or 'Func'
}

def new_type(kind: Kind, data: *void): *Type {
    return new create_type(kind, data);
}

def was_touched_by_tychk(t: *Type): bool {
    return std.flag_get(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_touch(t: *Type): void {
    std.flag_set(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_untouch(t: *Type): void {
    std.flag_unset(&t.flags, FLAG_TYCHK_TOUCHED);
}

def create_type(kind: Kind, data: *void): Type {
    return Type {
        kind: kind,
        width: WIDTH_UNKNOWN,
        align: 0,
        flags: 0,
        data: data
    };
}

def is_sized(t: *Type): bool {
    return !std.flag_get(&t.flags, FLAG_UNSIZED);
}

// if the type is not unsized and the with is unknown it wasn't
// constructed correctly
def is_initialized(t: *Type): bool {
    return t != null
        && ((t.width != WIDTH_UNKNOWN && t.align > 0) || std.flag_get(&t.flags, FLAG_UNSIZED));
}

def is_type_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_TYPE_SCOPED);
}

def is_value_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_VALUE_SCOPED);
}

def free_user_defined_type(user_defined: *UserDefinedType) {
    name.free_owned(&user_defined.mangled_name);
    scope.free_s(&user_defined.scope);
}

def free_ty(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        name.free_owned(&f_ty.mangled_name);
        // the inner types are garbage collected by tychk
        vec.free_v(&f_ty.params);
        delete t.data;
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        free_user_defined_type(&s_ty.super);
        // the inner types are garbage collected by tychk
        vec.free_v(&s_ty.fields);
        delete t.data;
    }

    if is_enum(t) {
        let e_ty = as_enum(t);
        free_user_defined_type(&e_ty.super);
        vmap.free_m(&e_ty.values);
        delete t.data;
    }

    if is_mod(t) {
        let m_ty = as_mod(t);
        scope.free_s(&m_ty.values);
        scope.free_s(&m_ty.types);
        delete t.data;
    }

    if is_ptr(t) {
        delete t.data;
    }

    delete t;
}

def lookup_value_in(t: *Type, name: *ident.Ident): *Type {
    if !is_value_scoped(t) {
        return null;
    }

    if is_enum(t) && ident.eq_lit(name, "len") {
        return as_enum(t).base_ty;
    }

    let value_scope = get_value_scope(t);
    dbg.assert(value_scope != null, "null value scope on value_scoped type");

    return scope.get_in(value_scope, name);
}

def lookup_type_in(t: *Type, name: *ident.Ident): *Type {
    if !is_type_scoped(t) {
        return null;
    }

    let type_scope = get_type_scope(t);
    dbg.assert(type_scope != null, "null type scope on type_scoped type");

    return scope.get_in(type_scope, name);
}

// looks for an ident in types with FLAG_VALUE_SCOPED
def get_value_scope(t: *Type): *scope.Scope {
    if is_user_defined(t) {
        return &get_user_defined(t).scope;
    }

    if is_mod(t) {
        return &as_mod(t).values;
    }

    if is_ptr(t) {
        return get_value_scope(as_ptr(t).inner);
    }

    return null;
}

def get_type_scope(t: *Type): *scope.Scope {
    if is_mod(t) {
        return &as_mod(t).types;
    }

    return null;
}

def is_num(t: *Type): bool {
    return is_integer(t) || is_f32(t);
}

def is_integer(t: *Type): bool {
    return is_i32(t) || is_i64(t);
}

def is_comparable(t: *Type): bool {
    return is_num(t)
        || is_ptr(t)
        || is_char(t)
        || is_enum(t);
}

def can_be_casted(from: *Type, into: *Type): bool {
    return (is_ptr(from) && is_ptr(into))
        || (is_num(from) && is_num(into));
}

/////////// align utils ///////////
// TODO(#36): should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the struct has uninitialized fields
def calc_struct_width_align(s_ty: *Struct, width: *i32, align: *i32): bool {
    let max_align = 1;
    let width_sum = 0;

    for let i = 0; i < s_ty.fields.len; i = i + 1 {
        let f = field_at(s_ty, i);
        if f == null || !is_initialized(f.ty) {
            return true;
        }

        if f.ty.align > max_align {
            max_align = f.ty.align;
        }

        // s: string,  width: 8, align: 8, offset: 0,  padding: 0    , width_sum: 8
        // c: char,    width: 1, align: 1, offset: 8,  padding: 0    , width_sum: 9
        // x: i32      width: 4, align: 4, offset: 12, padding: 4 - 1,

        let padding = 0;
        let rem = width_sum % f.ty.align;
        if width_sum > 0 && rem != 0 {
            padding = f.ty.align - rem;
        }

        f.offset = width_sum + padding;

        let real_width = f.ty.width + padding;
        width_sum = width_sum + real_width;
    }

    let rem = width_sum % max_align;
    if rem != 0 {
        width_sum = width_sum + (max_align - rem);
    }

    *width = width_sum;
    *align = max_align;

    return false;
}

// TODO(#38): implement either lookup table or full method dispatching for Type
// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if std.flag_get(&t.flags, FLAG_UNSIZED) {
        return false;
    }

    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;
    let has_unresolved_fields = false;

    if is_ptr(t) {
        width = 8; // TODO(#42): determine pointer width based on target
    } else if is_i32(t) {
        width = 4;
    } else if is_f32(t) {
        width = 4;
    } else if is_i64(t) {
        width = 8;
    } else if is_bool(t) {
        width = 1;
    } else if is_char(t) {
        width = 1;
    } else if is_struct(t) {
        let s_ty = as_struct(t);
        has_unresolved_fields = calc_struct_width_align(s_ty, &width, &align);
    } else if is_enum(t) {
        let e_ty = as_enum(t);
        fill_width_align(e_ty.base_ty);
        width = e_ty.base_ty.width;
        align = e_ty.base_ty.align;
    }

    if has_unresolved_fields {
        return false;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;

        return true;
    }

    return false;
}

// returns true if the string needs to be freed
def to_string(t: *Type, out: *string): bool {
    return to_string_mangled(t, true, out);
}

// returns true if the string needs to be freed
def to_string_mangled(t: *Type, use_mangled: bool, out: *string): bool {
    if t == null {
        *out = null;
        return false;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        let s_ret = ")";
        let free_ret = to_string(f_ty.ret, &s_ret);

        let buf = str.create_buf();
        for let i = 0; i < f_ty.params.len; i = i + 1 {
            if i > 0 {
                str.append(&buf, 2, ", ");
            }

            let p = param_at(f_ty, i);

            let p_ty_s = "";
            let free_p_ty_s = to_string_mangled(p.ty, use_mangled, &p_ty_s);
            let len = std.strlen(p_ty_s);

            str.append(&buf, len, p_ty_s);

            if free_p_ty_s {
                delete p_ty_s;
            }
        }

        let s = std.format_str("(%s) -> %s", buf.content, s_ret);
        if free_ret {
            delete s_ret;
        }

        str.free_buf(&buf);

        *out = s;
        return true;
    }

    if is_user_defined(t) {
        if use_mangled {
            *out = get_user_defined(t).mangled_name.data;
            return false;
        }

        *out = ident.to_string(&get_user_defined(t).original_name);
        return true;
    }

    if is_ptr(t) {
        let p_ty = as_ptr(t);
        let count = p_ty.count;

        let s_inner = "";
        let free_inner = false;

        if p_ty.inner != null && is_char(p_ty.inner) {
            count = count - 1;
            s_inner = "string";
        } else {
            free_inner = to_string_mangled(p_ty.inner, use_mangled, &s_inner);
        }

        let asterisks = std.malloc(count) as string;
        std.memset(asterisks as *void, std.char_to_int('*'), count);
        let s = std.format_str("%.*s%s", count, asterisks, s_inner);

        if free_inner {
            delete s_inner;
        }
        delete asterisks;

        *out = s;
        return true;
    }

    *out = to_static_string(t);
    return false;
}

def to_static_string(t: *Type): string {
    // since string is just an alias, this would normaly output 'pointer'
    if is_string(t) {
        return "string";
    }

    return type2str(t.kind);
}

def equals(first: *Type, second: *Type): bool {
    if first == second {
        return true;
    }

    if first == null || second == null {
        return false;
    }

    if first.kind != second.kind {
        return false;
    }

    if is_func(first) && is_func(second) {
        let first = as_func(first);
        let second = as_func(second);

        if !equals(first.ret, second.ret) {
            return false;
        }

        if first.params.len != second.params.len {
            return false;
        }

        for let i = 0; i < first.params.len; i = i + 1 {
            if !equals(param_at(first, i).ty, param_at(second, i).ty) {
                return false;
            }
        }

        return true;
    }

    let was_pointer = false;
    let first_ptr_count = 0;
    let second_ptr_count = 0;

    if is_ptr(first) {
        let p_ty = as_ptr(first);
        first_ptr_count = p_ty.count;
        first = p_ty.inner;
        was_pointer = true;
    }
    if is_ptr(second) {
        let p_ty = as_ptr(second);
        second_ptr_count = p_ty.count;
        second = p_ty.inner;
        was_pointer = true;
    }

    // either, at least one operand was a pointer, then we recursively call equals, or neither
    // types were pointers, then we just compare their memory addresses, which should be unique
    return ((!was_pointer && first == second) || (was_pointer && equals(first, second)))
        && first_ptr_count == second_ptr_count;
}
