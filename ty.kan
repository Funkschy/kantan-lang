#include "std.h"

import "ptrvec";
import "std";
import "ast";

#define WIDTH_UNKNOWN -1

#define TY_UNKNOWN 0
#define TY_I32 1
#define TY_FUNC 2

/////////// i32 type ///////////

type I32 struct {
    t: Type
}

def new_i32(): *Type {
    return (new I32 {
        t: create_type(TY_I32)
    }) as *Type;
}

def is_i32(t: *Type): bool {
    return t.kind == TY_I32;
}

def as_i32(t: *Type): *I32 {
    return t as *I32;
}

/////////// func type ///////////

type Func struct {
    t: Type,
    ret: *Type,
    params: TypeList,
    name: *ast.IdentExpr
}

def new_func(ret: *Type, params: ptrvec.Vec, name: *ast.IdentExpr): *Type {
    let params = create_type_list(params);
    return (new Func {
        t: create_type(TY_FUNC),
        ret: ret,
        params: params,
        name: name
    }) as *Type;
}

def is_func(t: *Type): bool {
    return t.kind == TY_FUNC;
}

def as_func(t: *Type): *Func {
    return t as *Func;
}

/////////// base type ///////////

type Type struct {
    kind: i32,
    width: i32, // width in bytes
    align: i32
}

def create_type(kind: i32): Type {
    let t = Type {
        kind: kind,
        width: 0,
        align: 0
    };

    fill_width_align(&t);
    return t;
}

type TypeList struct {
    types: ptrvec.Vec
}

def empty_type_list(): TypeList {
    return TypeList { types: ptrvec.create() };
}

def create_type_list(types: ptrvec.Vec): TypeList {
    return TypeList { types: types };
}

def type_at(tl: *TypeList, i: i32): *Type {
    return ptrvec.get(&tl.types, i) as *Type;
}

def type_list_free(tl: *TypeList): void {
    let i = 0;
    while i < tl.types.len {
        type_free(type_at(tl, i));
        i = i + 1;
    }
    ptrvec.free_v(&tl.types);
}

def type_free(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        type_free(f_ty.ret);
        type_list_free(&f_ty.params);
    }

    delete t;
}

/////////// align utils ///////////
// TODO: should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;

    if t.kind == TY_I32 {
        width = 4;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;
        return true;
    }

    return false;
}

def to_string(t: *Type, span_interner: *span.SpanInterner): string {
    if t == null {
        return null;
    }

    if is_i32(t) {
        return std.strdup("i32");
    }

    if is_func(t) {
        // TODO: resolve cyclic dependencies
        let name = "name";
        let s = std.format_str("def %s(...): ...", name);
        return s;
    }

    return null;
}

def clone(t: *Type): *Type {
    if t == null {
        return null;
    }

    let nt = std.malloc(sizeof Type);
    std.memcpy(nt, t as *void, sizeof Type);
    return nt as *Type;
}
