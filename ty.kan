import "str";
import "dbg";
import "std";
import "mod";
import "vec";
import "vmap";
import "span";
import "name";
import "scope";
import "ident";
import "symbol";
import "ptrvec";

extern def type2str(kind: Kind): string;

// the order is important, if it is changed, the order of strings in lib.h also has to change
type Kind enum {
    Error, Ptr, Bool, I8, I16, I32, I64, ISize, U8, U16, U32, U64, USize, F32, F64, Void, Func, Mod, Struct, Enum
}

#define WIDTH_UNKNOWN -1

// These flags have to be powers of 2
#define FLAG_TYPE_SCOPED   1
#define FLAG_VALUE_SCOPED  2
#define FLAG_UNSIZED       4
// this gets set, when tychk visits a type for the first time and gets unset
// when the type is fully resolved
#define FLAG_TYCHK_TOUCHED 8

/////////// error type ///////////

def new_error(): *Type {
    let t = new_type(Kind.Error, null);
    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

def is_error(t: *Type): bool {
    return t.kind == Kind.Error;
}

/////////// void type ///////////

// TODO(#84): remove void type. Replace it with byte type and empty return types

def new_void(): *Type {
    let t = new_type(Kind.Void, null);
    std.flag_set(&t.flags, FLAG_UNSIZED);
    return t;
}

def is_void(t: *Type): bool {
    return t.kind == Kind.Void;
}

/////////// i8 type ///////////

def new_i8(): *Type {
    let t = new_type(Kind.I8, null);
    t.width = (t.align = 1) as i64;
    return t;
}

def is_i8(t: *Type): bool {
    return t.kind == Kind.I8;
}

/////////// i16 type ///////////

def new_i16(): *Type {
    let t = new_type(Kind.I16, null);
    t.width = (t.align = 2) as i64;
    return t;
}

def is_i16(t: *Type): bool {
    return t.kind == Kind.I16;
}

/////////// i32 type ///////////

def new_i32(): *Type {
    let t = new_type(Kind.I32, null);
    t.width = (t.align = 4) as i64;
    return t;
}

def is_i32(t: *Type): bool {
    return t.kind == Kind.I32;
}

/////////// i64 type ///////////

def new_i64(): *Type {
    let t = new_type(Kind.I64, null);
    t.width = (t.align = 8) as i64;
    return t;
}

def is_i64(t: *Type): bool {
    return t.kind == Kind.I64;
}

/////////// isize type ///////////

def new_isize(width: usize): *Type {
    let t = new_type(Kind.ISize, null);
    t.align = width as i32;
    t.width = width as i64;
    return t;
}

def is_isize(t: *Type): bool {
    return t.kind == Kind.ISize;
}

/////////// u8 type ///////////

def new_u8(): *Type {
    let t = new_type(Kind.U8, null);
    t.width = (t.align = 1) as i64;
    return t;
}

def is_u8(t: *Type): bool {
    return t.kind == Kind.U8;
}

/////////// u16 type ///////////

def new_u16(): *Type {
    let t = new_type(Kind.U16, null);
    t.width = (t.align = 2) as i64;
    return t;
}

def is_u16(t: *Type): bool {
    return t.kind == Kind.U16;
}

/////////// u32 type ///////////

def new_u32(): *Type {
    let t = new_type(Kind.U32, null);
    t.width = (t.align = 4) as i64;
    return t;
}

def is_u32(t: *Type): bool {
    return t.kind == Kind.U32;
}

/////////// u64 type ///////////

def new_u64(): *Type {
    let t = new_type(Kind.U64, null);
    t.width = (t.align = 8) as i64;
    return t;
}

def is_u64(t: *Type): bool {
    return t.kind == Kind.U64;
}

/////////// usize type ///////////

def new_usize(width: usize): *Type {
    let t = new_type(Kind.USize, null);
    t.align = width as i32;
    t.width = width as i64;
    return t;
}

def is_usize(t: *Type): bool {
    return t.kind == Kind.USize;
}

/////////// f32 type ///////////

def new_f32(): *Type {
    let t = new_type(Kind.F32, null);
    t.width = (t.align = 4) as i64;
    return t;
}

def is_f32(t: *Type): bool {
    return t.kind == Kind.F32;
}

/////////// f64 type ///////////

def new_f64(): *Type {
    let t = new_type(Kind.F64, null);
    t.width = (t.align = 8) as i64;
    return t;
}

def is_f64(t: *Type): bool {
    return t.kind == Kind.F64;
}

/////////// bool type ///////////

def new_bool(): *Type {
    let t = new_type(Kind.Bool, null);
    t.width = (t.align = 1) as i64;
    return t;
}

def is_bool(t: *Type): bool {
    return t.kind == Kind.Bool;
}

/////////// pointer type ///////////

// TODO(#22): remember to make the result of pointer subtraction dependent on the
//  pointers types
type Ptr struct {
    count: u32,
    inner: *Type
}

// TODO(#28): don't allow pointers to Mod or other non-runtime abstractions (e.g Types)
//  should we actually check this here, or just in the typechecker itself?
def new_ptr(count: u32, inner: *Type): *Type {
    if inner != null && is_ptr(inner) {
        count = count + as_ptr(inner).count;
        inner = as_ptr(inner).inner;
    }

    let ptr = new Ptr {
        count: count,
        inner: inner
    };

    let t = new_type(Kind.Ptr, ptr as *void);
    if inner != null && count < 2 {
        // only auto deref once
        t.flags = inner.flags;
    }

    // pointers always have a size
    std.flag_unset(&t.flags, FLAG_UNSIZED);
    // TODO(#42): determine pointer width based on target
    t.width = (t.align = 8) as i64;
    return t;
}

def update_inner(ptr_ty: *Type, inner: *Type): void {
    let p = as_ptr(ptr_ty);

    if inner != null && is_ptr(inner) {
        inner = as_ptr(inner).inner;
        p.count = p.count + as_ptr(inner).count;
    }

    p.inner = inner;
    // only auto deref once
    if p.count < 2 {
        // use flags from inner type, except for unsized and decl
        ptr_ty.flags = inner.flags;
    }
    // pointers always have a size
    std.flag_unset(&ptr_ty.flags, FLAG_UNSIZED);
}

def is_ptr(t: *Type): bool {
    return t.kind == Kind.Ptr;
}

def as_ptr(t: *Type): *Ptr {
    return t.data as *Ptr;
}

def is_string(t: *Type): bool {
    return is_ptr(t) && as_ptr(t).count == 1 && is_i8(as_ptr(t).inner);
}

type UserDefinedType struct {
    original_name: ident.Ident,
    mangled_name: name.Owned,
    scope: scope.Scope,
    declared_in: *mod.Module
}

def bind_method(t: *Type, name: ident.Ident, method: *Type) {
    dbg.assert(is_user_defined(t), "Trying to bind method on non user defined type");
    dbg.assert(method != null, "Trying to bind null method");
    dbg.assert(is_func(method), "Trying to bind non func type as method");

    let value_scope = get_value_scope(t);
    value_scope.bind_public_ident(&name, method);
}

def is_user_defined(t: *Type): bool {
    if is_ptr(t) {
        let ptr = as_ptr(t);
        return ptr.count == 1 && is_user_defined(ptr.inner);
    }

    return is_struct(t) || is_enum(t);
}

def get_user_defined(t: *Type): *UserDefinedType {
    if is_ptr(t) {
        return get_user_defined(as_ptr(t).inner);
    }

    return t.data as *UserDefinedType;
}

/////////// struct type ///////////

type StructField struct {
    name: ident.Ident,
    ty: *Type,
    offset: u64 // gets set during fill_width_align
}

type Struct struct {
    super: UserDefinedType,
    fields: vec.Vec // <StructField>
}

// this function is used to initialize placeholder structs of tychk
def init_struct(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module
): void {
    let s = new Struct {
        super: UserDefinedType {
            name: name,
            mangled_name: mangled_name,
            scope: scope.with_name(name.ref()),
            declared_in: declared_in
        },
        fields: vec.create(sizeof StructField)
    };

    t.data = s as *void;
    t.width = WIDTH_UNKNOWN;
    std.flag_set(&t.flags, FLAG_VALUE_SCOPED);
}

def is_struct(t: *Type): bool {
    return t.kind == Kind.Struct;
}

def push_field(t: *Struct, name: ident.Ident, ty: *Type): void {
    let field = StructField { name: name, ty: ty, offset: 0 };
    t.fields.push(&field as *void);
    t.super.scope.bind_public_ident(&name, ty);
}

// get the index of the field with name 'name'
// returns -1 if the field does not exist
// if out_field_ty is not null, it is set to the type of the field
// TODO(#85): Struct should have a vmap for its fields
def field_idx(t: *Struct, name: ident.Ident, out_field_ty: **Type): i64 {
    for let i: u32 = 0; i < t.num_fields(); i += 1 {
        let f = t.field_at(i);
        if ident.eq_value(&name, &f.name) {
            if out_field_ty != null {
                *out_field_ty = f.ty;
            }
            return i as i64;
        }
    }

    return -1;
}

def update_field_ty(t: *Struct, field: *StructField): void {
    t.super.scope.bind_public_ident(&field.name, field.ty);
}

def (t: *Struct) field_at(i: u32): *StructField {
    return t.fields.get_ptr(i as usize) as *StructField;
}

def (t: *Struct) num_fields(): u32 {
    return t.fields.len as u32;
}

def as_struct(t: *Type): *Struct {
    return t.data as *Struct;
}

/////////// enum type ///////////

type EnumValue struct {
    name: ident.Ident,
    value: i32
}

type Enum struct {
    super: UserDefinedType,
    base_ty: *Type, // currently only i32
    values: vmap.Map // vmap.Map<ident.Ident, EnumValue>
}

// this function is used to initialize placeholder enums of tychk
def init_enum(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module,
    base_ty: *Type
): void {
    dbg.assert(base_ty != null, "base_ty was null");

    let s = new Enum {
        super: UserDefinedType {
            name: name,
            mangled_name: mangled_name,
            scope: scope.with_name(name.ref()),
            declared_in: declared_in
        },
        base_ty: base_ty,
        values: vmap.create(sizeof EnumValue)
    };

    t.data = s as *void;
    std.flag_set(&t.flags, FLAG_VALUE_SCOPED);
    fill_width_align(t);
}

def is_enum(t: *Type): bool {
    return t.kind == Kind.Enum;
}

def as_enum(t: *Type): *Enum {
    return t.data as *Enum;
}

def (t: *Enum) num_values(): u32 {
    return t.values.values.len as u32;
}

// returns true, if the value was already in the enum
def push_enum_value(t: *Type, name: ident.Ident, value: i32): bool {
    let e_ty = as_enum(t);
    let key = vmap.key_from_ident(&name);

    // TODO: instead of a fake "len" value, we should just have a len() compile time function
    if vmap.get_ptr(&e_ty.values, key) != null || ident.eq_lit(&name, "len") {
        return true;
    }

    let value = EnumValue { name: name, value: value };
    vmap.insert(&e_ty.values, key, &value as *void);

    let field_type = t;
    // all enum values have the enum itself as their type
    e_ty.super.scope.bind_public_ident(&name, field_type);
    return false;
}

def value_at(t: *Enum, i: u32): *EnumValue {
    return vmap.get_ptr_idx(&t.values, i as usize) as *EnumValue;
}

def enum_value_by_name(t: *Enum, name: ident.Ident): i32 {
    // since there is no Ident for "len", we just cheat a bit
    if ident.eq_lit(&name, "len") {
        return vmap.len(&t.values) as i32;
    }

    let key = vmap.key_from_ident(&name);
    return (vmap.get_ptr(&t.values, key) as *EnumValue).value;
}

/////////// func type ///////////

type Param struct {
    name: ident.Ident,
    ty: *Type
}

def create_param(name: ident.Ident, ty: *Type): Param {
    return Param { name: name, ty: ty };
}

type Func struct {
    is_extern: bool,
    is_varargs: bool,
    is_method: bool,
    receiver_patched: bool,
    declared_in: *mod.Module,
    receiver: Param,
    ret: *Type,
    params: vec.Vec, // <Param>
    name: ident.Ident,
    mangled_name: name.Owned
}

// this function is used to initialize placeholder functions of tychk
def init_func(
    t: *Type,
    name: ident.Ident,
    mangled_name: name.Owned,
    declared_in: *mod.Module,
    is_extern: bool
): void {
    let f = new Func {
        is_extern: is_extern,
        // the way that tychk currently works, is that this is set lazily, while
        // checking the parameters types
        is_varargs: false,
        is_method: false,
        receiver_patched: false,
        declared_in: declared_in,
        receiver: Param { name: ident.empty(), ty: null },
        ret: null,
        params: vec.create(sizeof Param),
        name: name,
        mangled_name: mangled_name
    };
    std.flag_set(&t.flags, FLAG_UNSIZED);

    t.data = f as *void;
}

def (old_method: *Func) as_normal_function(): *Type {
    let new_type = new_type(Kind.Func, null);

    init_func(
        new_type,
        old_method.name,
        old_method.mangled_name.clone(),
        old_method.declared_in,
        old_method.is_extern // TODO: can we declare extern methods?
    );

    let new_func = as_func(new_type);

    let params = vec.with_cap(sizeof Param, old_method.params.len + 1);
    params.push(&old_method.receiver as *void);
    for let i: u32 = 0; i < old_method.num_params(); i += 1 {
        params.push(old_method.param_at(i) as *void);
    }

    new_func.params = params;
    new_func.is_method = false;
    new_func.is_varargs = old_method.is_varargs;

    new_func.ret = old_method.ret;
    return new_type;
}

// it is better to treat the receiver type differently during typechecking, since it has
// different restrictions than normal parameters. However we don't want to check is_method all
// the time during code generation, so we just push the receiver as the first argument during
// ir compilation
def patch_receiver_into_params(t: *Func) {
    if !t.is_method || t.receiver_patched {
        return;
    }

    t.params.push_front(&t.receiver as *void);
    // only do this once
    t.receiver_patched = true;
}

def should_auto_ref_receiver(t: *Func): bool {
    return is_ptr(t.receiver.ty) && as_ptr(t.receiver.ty).count == 1;
}

// TODO(#33): this is inefficient
//  do we actually need to iterate everything all the time? We don't want to
//  iterate over the params, which were already initialized last time
def func_is_initalized(t: *Func): bool {
    if t.ret == null {
        return false;
    }

    for let i: u32 = 0; i < t.num_params(); i += 1 {
        let p = t.param_at(i);
        if p.ty == null {
            return false;
        }
    }

    return true;
}

// returns: idx of param with name or -1
def find_param_idx(t: *Func, name: *ident.Ident): i64 {
    for let i: u32 = 0; i < t.num_params(); i += 1 {
        let p = t.param_at(i);
        if ident.eq_value(&p.name, name) {
            return i as i64;
        }
    }
    return -1;
}

def (t: *Func) num_params(): u32 {
    return t.params.len as u32;
}

def (t: *Func) param_at(i: u32): *Param {
    return t.params.get_ptr(i as usize) as *Param;
}

def is_func(t: *Type): bool {
    return t.kind == Kind.Func;
}

def as_func(t: *Type): *Func {
    return t.data as *Func;
}

def is_callable(t: *Type): bool {
    return is_func(t)
        || (is_ptr(t) && as_ptr(t).count == 1 && is_func(as_ptr(t).inner));
}

def callable_as_func(t: *Type): *Func {
    if is_func(t) {
        return as_func(t);
    }
    return as_func(as_ptr(t).inner);
}

/////////// mod type ///////////

type Mod struct {
    types: scope.Scope
    values: scope.Scope
}

def new_mod(name: name.Ref): *Type {
    let m = new Mod {
        types: scope.with_name(name),
        values: scope.with_name(name)
    };

    let t = new_type(Kind.Mod, m as *void);

    std.flag_set(&t.flags, FLAG_TYPE_SCOPED);
    std.flag_set(&t.flags, FLAG_VALUE_SCOPED);
    std.flag_set(&t.flags, FLAG_UNSIZED);

    return t;
}

def is_mod(t: *Type): bool {
    return t.kind == Kind.Mod;
}

def as_mod(t: *Type): *Mod {
    return t.data as *Mod;
}

/////////// base type ///////////

type Type struct {
    kind: Kind,
    width: i64, // width in bytes
    align: i32,
    flags: i32,
    data: *void // extra data, eg. 'Struct' or 'Func'
}

def new_type(kind: Kind, data: *void): *Type {
    return new create_type(kind, data);
}

def was_touched_by_tychk(t: *Type): bool {
    return std.flag_get(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_touch(t: *Type): void {
    std.flag_set(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_untouch(t: *Type): void {
    std.flag_unset(&t.flags, FLAG_TYCHK_TOUCHED);
}

def create_type(kind: Kind, data: *void): Type {
    return Type {
        kind: kind,
        width: WIDTH_UNKNOWN,
        align: 0,
        flags: 0,
        data: data
    };
}

def is_sized(t: *Type): bool {
    return !std.flag_get(&t.flags, FLAG_UNSIZED);
}

// if the type is not unsized and the with is unknown it wasn't
// constructed correctly
def is_initialized(t: *Type): bool {
    return t != null
        && ((t.width != WIDTH_UNKNOWN && t.align > 0) || std.flag_get(&t.flags, FLAG_UNSIZED));
}

def is_type_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_TYPE_SCOPED);
}

def is_value_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_VALUE_SCOPED);
}

def free_user_defined_type(user_defined: *UserDefinedType) {
    name.free_owned(&user_defined.mangled_name);
    scope.free_s(&user_defined.scope);
}

def (t: *Type) is_declared_in(m: *mod.Module): bool {
    if is_user_defined(t) || is_ptr(t) && is_user_defined(as_ptr(t).inner) {
        return get_user_defined(t).declared_in == m;
    }

    if is_func(t) {
        return as_func(t).declared_in == m;
    }

    return false;
}

def free_ty(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        name.free_owned(&f_ty.mangled_name);
        // the inner types are garbage collected by tychk
        f_ty.params.free();
        delete t.data;
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        free_user_defined_type(&s_ty.super);
        // the inner types are garbage collected by tychk
        s_ty.fields.free();
        delete t.data;
    }

    if is_enum(t) {
        let e_ty = as_enum(t);
        free_user_defined_type(&e_ty.super);
        vmap.free_m(&e_ty.values);
        delete t.data;
    }

    if is_mod(t) {
        let m_ty = as_mod(t);
        scope.free_s(&m_ty.values);
        scope.free_s(&m_ty.types);
        delete t.data;
    }

    if is_ptr(t) {
        delete t.data;
    }

    delete t;
}

def lookup_value_in(t: *Type, name: *ident.Ident): symbol.Data {
    if !is_value_scoped(t) {
        return symbol.empty();
    }

    if is_enum(t) && ident.eq_lit(name, "len") {
        let e_ty = as_enum(t);
        return symbol.create_public(e_ty.base_ty).with_scope(&e_ty.super.scope);
    }

    let value_scope = get_value_scope(t);
    dbg.assert(value_scope != null, "null value scope on value_scoped type");

    return value_scope.get_ident(name);
}

def lookup_type_in(t: *Type, name: *ident.Ident): symbol.Data {
    if !is_type_scoped(t) {
        return symbol.empty();
    }

    let type_scope = get_type_scope(t);
    dbg.assert(type_scope != null, "null type scope on type_scoped type");

    return type_scope.get_ident(name);
}

// looks for an ident in types with FLAG_VALUE_SCOPED
def get_value_scope(t: *Type): *scope.Scope {
    if is_user_defined(t) {
        return &get_user_defined(t).scope;
    }

    if is_mod(t) {
        return &as_mod(t).values;
    }

    if is_ptr(t) {
        return get_value_scope(as_ptr(t).inner);
    }

    return null;
}

def get_type_scope(t: *Type): *scope.Scope {
    if is_mod(t) {
        return &as_mod(t).types;
    }

    return null;
}

def (t: *Type) is_num(): bool {
    return t.is_integer() || t.is_float();
}

def (t: *Type) is_integer(): bool {
    return t.kind >= Kind.I8 && t.kind <= Kind.USize;
}

def (t: *Type) is_unsigned(): bool {
    return t.kind >= Kind.U8 && t.kind <= Kind.USize;
}

def (t: *Type) is_float(): bool {
    return is_f32(t) || is_f64(t);
}

def (t: *Type) width_in_bits(): u64 {
    return t.width as u64 * 8;
}

def (t: *Type) align_in_bits(): u32 {
    return t.align as u32 * 8;
}

def is_comparable(t: *Type): bool {
    return t.is_num()
        || is_ptr(t)
        || is_i8(t)
        || is_enum(t);
}

def can_be_casted(from: *Type, into: *Type): bool {
    return (is_ptr(from) && is_ptr(into))
        || (from.is_num() && into.is_num())
        || (from.is_integer() && is_bool(into))
        || (is_bool(from) && into.is_integer())
        || equals(from, into);
}

/////////// align utils ///////////
// TODO(#36): should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the struct has uninitialized fields
def calc_struct_width_align(s_ty: *Struct, width: *i64, align: *i32): bool {
    let max_align: i32 = 1;
    let width_sum: i64 = 0;

    for let i: u32 = 0; i < s_ty.num_fields(); i += 1 {
        let f = s_ty.field_at(i);
        if f == null || !is_initialized(f.ty) {
            return true;
        }

        if f.ty.align > max_align {
            max_align = f.ty.align;
        }

        // s: string,  width: 8, align: 8, offset: 0,  padding: 0    , width_sum: 8
        // c: i8,    width: 1, align: 1, offset: 8,  padding: 0    , width_sum: 9
        // x: i32      width: 4, align: 4, offset: 12, padding: 4 - 1,

        let padding: i64 = 0;
        let rem = width_sum % (f.ty.align as i64);
        if width_sum > 0 && rem != 0 {
            padding = f.ty.align as i64 - rem;
        }

        f.offset = (width_sum + padding) as u64;

        let real_width = f.ty.width + padding;
        width_sum = width_sum + real_width;
    }

    let rem = width_sum % (max_align as i64);
    if rem != 0 {
        width_sum = width_sum + (max_align as i64 - rem);
    }

    *width = width_sum;
    *align = max_align;

    return false;
}

// TODO(#38): implement either lookup table or full method dispatching for Type
// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if std.flag_get(&t.flags, FLAG_UNSIZED) {
        return false;
    }

    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align: i32 = 0;
    let width: i64 = WIDTH_UNKNOWN;
    let has_unresolved_fields = false;

    if is_struct(t) {
        let s_ty = as_struct(t);
        has_unresolved_fields = calc_struct_width_align(s_ty, &width, &align);
    } else if is_enum(t) {
        let e_ty = as_enum(t);
        fill_width_align(e_ty.base_ty);
        width = e_ty.base_ty.width;
        align = e_ty.base_ty.align;
    }

    if has_unresolved_fields {
        return false;
    }

    t.width = width;
    t.align = align;
    return true;
}

// returns true if the string needs to be freed
def to_string(t: *Type, out: *string): bool {
    return to_string_mangled(t, true, out);
}

// returns true if the string needs to be freed
def to_string_mangled(t: *Type, use_mangled: bool, out: *string): bool {
    if t == null {
        *out = null;
        return false;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        let s_ret = ")";
        let free_ret = to_string(f_ty.ret, &s_ret);

        let params_string = str.create();
        defer params_string.free();

        for let i: u32 = 0; i < f_ty.params.len as u32; i += 1 {
            if i > 0 {
                params_string.push(str.view(2, ", "));
            }

            let p = f_ty.param_at(i);

            let p_ty_s = "";
            let free_p_ty_s = to_string_mangled(p.ty, use_mangled, &p_ty_s);
            let len = std.strlen(p_ty_s);

            params_string.push(str.view(len as usize, p_ty_s));

            if free_p_ty_s {
                delete p_ty_s;
            }
        }

        let s = std.format_str("(%s) -> %s", params_string.cstring(), s_ret);
        if free_ret {
            delete s_ret;
        }

        *out = s;
        return true;
    }

    if is_ptr(t) {
        let p_ty = as_ptr(t);
        let count = p_ty.count;

        let s_inner = "";
        let free_inner = false;

        if p_ty.inner != null && is_i8(p_ty.inner) {
            count = count - 1;
            s_inner = "string";
        } else {
            free_inner = to_string_mangled(p_ty.inner, use_mangled, &s_inner);
        }

        let asterisks = std.malloc(count as usize) as string;
        std.memset(asterisks as *void, '*', count as usize);
        let s = std.format_str("%.*s%s", count, asterisks, s_inner);

        if free_inner {
            delete s_inner;
        }
        delete asterisks;

        *out = s;
        return true;
    }

    if is_user_defined(t) {
        if use_mangled {
            *out = get_user_defined(t).mangled_name.data;
            return false;
        }

        *out = ident.to_string(&get_user_defined(t).original_name);
        return true;
    }

    *out = to_static_string(t);
    return false;
}

def to_static_string(t: *Type): string {
    // since string is just an alias, this would normaly output 'pointer'
    if is_string(t) {
        return "string";
    }

    return type2str(t.kind);
}

def equals(first: *Type, second: *Type): bool {
    if first == second {
        return true;
    }

    if first == null || second == null {
        return false;
    }

    if first.kind != second.kind {
        return false;
    }

    if is_func(first) && is_func(second) {
        let first = as_func(first);
        let second = as_func(second);

        if !equals(first.ret, second.ret) {
            return false;
        }

        if first.params.len != second.params.len {
            return false;
        }

        for let i: u32 = 0; i < first.params.len as u32; i = i + 1 {
            if !equals(first.param_at(i).ty, second.param_at(i).ty) {
                return false;
            }
        }

        return true;
    }

    let was_pointer = false;
    let first_ptr_count: u32 = 0;
    let second_ptr_count: u32 = 0;

    if is_ptr(first) {
        let p_ty = as_ptr(first);
        first_ptr_count = p_ty.count;
        first = p_ty.inner;
        was_pointer = true;
    }
    if is_ptr(second) {
        let p_ty = as_ptr(second);
        second_ptr_count = p_ty.count;
        second = p_ty.inner;
        was_pointer = true;
    }

    // either, at least one operand was a pointer, then we recursively call equals, or neither
    // types were pointers, then we just compare their memory addresses, which should be unique
    return ((!was_pointer && first == second) || (was_pointer && equals(first, second)))
        && first_ptr_count == second_ptr_count;
}
