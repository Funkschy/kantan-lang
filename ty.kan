#include "std.h"
#include "ty_types.h"

import "ptrvec";
import "vec";
import "std";
import "ident";
import "span";
import "scope";

// TODO: this should be imported, but can't because of circular dependencies
// for some reason, this works anyway
// import "mod";

#define WIDTH_UNKNOWN -1

#define FLAG_SCOPED        1
#define FLAG_UNSIZED       2
// this gets set, when tychk visits a type for the first time and gets unset
// when the type is fully resolved
#define FLAG_TYCHK_TOUCHED 4

/////////// i32 type ///////////

type I32 struct {
    t: Type
}

def new_i32(): *Type {
    let t = (new I32 {
        t: create_type(TY_I32)
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_i32(t: *Type): bool {
    return t.kind == TY_I32;
}

def as_i32(t: *Type): *I32 {
    return t as *I32;
}

/////////// pointer type ///////////

type Ptr struct {
    t: Type,
    count: i32,
    inner: *ty.Type
}

def new_ptr(count: i32, inner: *ty.Type): *Type {
    let t = (new Ptr {
        t: create_type(TY_PTR),
        count: count,
        inner: inner
    }) as *Type;

    if inner != null {
        t.flags = inner.flags;
    }

    fill_width_align(t);
    return t;
}

def update_inner(p: *Ptr, inner: *Type): void {
    p.inner = inner;
    p.t.flags = inner.flags;
}

def is_ptr(t: *Type): bool {
    return t.kind == TY_PTR;
}

def as_ptr(t: *Type): *Ptr {
    return t as *Ptr;
}

/////////// string type ///////////

type String struct {
    t: Type
}

def new_string(): *Type {
    let t = (new String {
        t: create_type(TY_STRING)
    }) as *Type;

    fill_width_align(t);
    return t;
}

def is_string(t: *Type): bool {
    return t.kind == TY_STRING;
}

def as_string(t: *Type): *String {
    return t as *String;
}

/////////// struct type ///////////

type StructField struct {
    name: ident.Ident,
    ty: *Type
}

type Struct struct {
    t: Type,
    name: ident.Ident,
    scope: scope.Scope,
    fields: vec.Vec // <StructField>
}

// this function is used to initialize placeholder structs of tychk
def init_struct(t: *Type, name: ident.Ident): void {
    let s = Struct {
        t: *t,
        name: name,
        scope: scope.create(),
        fields: vec.create(sizeof StructField)
    };
    t.width = WIDTH_UNKNOWN;
    std.flag_set(&s.t.flags, FLAG_SCOPED);

    std.memcpy(t as *void, &s as *void, sizeof Struct);
}

def is_struct(t: *Type): bool {
    return t.kind == TY_STRUCT;
}

def as_struct(t: *Type): *Struct {
    return t as *Struct;
}

def push_field(t: *Struct, name: ident.Ident, ty: *Type, si: *span.SpanInterner): void {
    let field = StructField { name: name, ty: ty };
    vec.push(&t.fields, &field as *void);
    scope.bind_in(&t.scope, si, &name, ty);
}

def field_at(t: *Struct, i: i32): *StructField {
    return vec.get_ptr(&t.fields, i) as *StructField;
}

def update_field_ty(t: *Struct, field: *StructField, si: *span.SpanInterner): void {
    scope.bind_in(&t.scope, si, &field.name, field.ty);
}

def num_fields(t: *Struct): i32 {
    return t.fields.len;
}

/////////// func type ///////////

type Param struct {
    name: ident.Ident,
    ty: *Type
}

def create_param(name: ident.Ident, ty: *Type): Param {
    return Param { name: name, ty: ty };
}

type Func struct {
    t: Type,
    ret: *Type,
    params: vec.Vec, // <Param>
    name: ident.Ident
}

// this function is used to initialize placeholder functions of tychk
def init_func(t: *Type, name: ident.Ident): void {
    let f = Func {
        t: *t,
        ret: null,
        params: vec.create(sizeof Param),
        name: name,
    };
    std.flag_set(&t.flags, FLAG_UNSIZED);

    std.memcpy(t as *void, &f as *void, sizeof Func);
}

// TODO: this is inefficient
def func_is_initalized(t: *Func): bool {
    if t.ret == null {
        return false;
    }

    let i = 0;
    while i < t.params.len {
        let p = param_at(t, i);
        if p.ty == null {
            return false;
        }
        i = i + 1;
    }

    return true;
}

def param_at(t: *Func, i: i32): *Param {
    return vec.get_ptr(&t.params, i) as *Param;
}

def is_func(t: *Type): bool {
    return t.kind == TY_FUNC;
}

def as_func(t: *Type): *Func {
    return t as *Func;
}

/////////// mod type ///////////

type Mod struct {
    t: Type,
    scope: scope.Scope
}

def new_mod(): *Type {
    let t = (new Mod {
        t: create_type(TY_MOD),
        scope: scope.create()
    }) as *Type;

    std.flag_set(&t.flags, FLAG_SCOPED);
    std.flag_set(&t.flags, FLAG_UNSIZED);

    return t;
}

def is_mod(t: *Type): bool {
    return t.kind == TY_MOD;
}

def as_mod(t: *Type): *Mod {
    return t as *Mod;
}

/////////// base type ///////////

type Type struct {
    kind: i32,
    width: i32, // width in bytes
    align: i32,
    flags: i32
}

def new_type(kind: i32, size: i32): *Type {
    let mem = std.calloc(size, 1);
    let ty = create_type(kind);

    std.memcpy(mem, &ty as *void, sizeof Type);
    return mem as *Type;
}

def was_touched_by_tychk(t: *Type): bool {
    return std.flag_get(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_touch(t: *Type): void {
    std.flag_set(&t.flags, FLAG_TYCHK_TOUCHED);
}

def tychk_untouch(t: *Type): void {
    std.flag_unset(&t.flags, FLAG_TYCHK_TOUCHED);
}

def create_type(kind: i32): Type {
    return Type {
        kind: kind,
        width: WIDTH_UNKNOWN,
        align: 0,
        flags: 0
    };
}

// if the type is not unsized and the with is unknown it wasn't
// constructed correctly
def is_initialized(t: *Type): bool {
    return t.width != WIDTH_UNKNOWN || std.flag_get(&t.flags, FLAG_UNSIZED);
}

def is_scoped(t: *Type): bool {
    if t == null {
        return false;
    }

    return std.flag_get(&t.flags, FLAG_SCOPED);
}

def type_free(t: *Type): void {
    if t == null {
        return;
    }

    if is_func(t) {
        let f_ty = as_func(t);
        // the inner types are garbage collected by tychk
        vec.free_v(&f_ty.params);
    }

    if is_struct(t) {
        let s_ty = as_struct(t);
        // the inner types are garbage collected by tychk
        vec.free_v(&s_ty.fields);
        scope.free_s(&s_ty.scope);
    }

    if is_mod(t) {
        let m_ty = as_mod(t);
        scope.free_s(&m_ty.scope);
    }

    delete t;
}

// looks for an ident in types with FLAG_SCOPED
def get_scope(t: *Type): *scope.Scope {
    if is_mod(t) {
        return &as_mod(t).scope;
    }

    if is_struct(t) {
        return &as_struct(t).scope;
    }

    if is_ptr(t) {
        return get_scope(as_ptr(t).inner);
    }

    return null;
}

/////////// align utils ///////////
// TODO: should be in separate file, but can't because of circular imports

def width_was_calculated(t: *Type): bool {
    return t.align > 0;
}

// returns true, if the types width/alignment could be calculated
def fill_width_align(t: *Type): bool {
    if width_was_calculated(t) {
        return true;
    }

    // if align is 0 at end of this function, use width as align
    let align = 0;
    let width = WIDTH_UNKNOWN;
    let has_unresolved_fields = false;

    if is_ptr(t){
        width = 8; // TODO: determine pointer width based on target
    } else if is_i32(t) {
        width = 4;
    } else if is_string(t) {
        width = 8; // TODO: determine pointer width based on target
    } else if is_struct(t) {
        let s_ty = as_struct(t);
        let max_align = align;
        let width_sum = 0;

        let i = 0;
        while i < s_ty.fields.len {
            let f = field_at(s_ty, i);
            let field_initialized = f != null;
            if field_initialized {
                field_initialized = f.ty != null;
            }

            if field_initialized {
                let is_not_resolved = was_touched_by_tychk(f.ty);

                if is_not_resolved {
                    has_unresolved_fields = true;
                } else {
                    let a = f.ty.align;
                    if a > max_align {
                        max_align = a;
                    }

                    let w = f.ty.width;
                    width_sum = width_sum + w;
                }
            } else {
                has_unresolved_fields = true;
            }

            i = i + 1;
        }

        width = width_sum;
        align = max_align;
    }

    if has_unresolved_fields {
        return false;
    }

    if width != WIDTH_UNKNOWN {
        t.width = width;
        if align == 0 {
            align = width;
        }
        t.align = align;
        return true;
    }

    return false;
}

def to_string(t: *Type, span_interner: *span.SpanInterner): string {
    if t == null {
        return null;
    }

    if is_i32(t) {
        return std.strdup("i32");
    }

    if is_string(t) {
        return std.strdup("string");
    }

    if is_func(t) {
        // TODO: resolve cyclic dependencies
        let name = "name";
        let s = std.format_str("def %s(...): ...", name);
        return s;
    }

    if is_mod(t) {
        return std.strdup("mod");
    }

    if is_struct(t) {
        return std.strdup("struct definition");
    }

    if is_ptr(t) {
        return std.strdup("ptr");
    }

    return null;
}
