import "ty";
import "ast";
import "vec";
import "mod";
import "map";
import "dbg";
import "span";
import "tyid";
import "name";
import "path";
import "func";
import "error";
import "scope";
import "ident";
import "record";
import "ptrvec";
import "symbol";
import "modsort" as ms;

import "std";
// TODO(#21): only for debug purposes
import "io";

extern def stmt2str(kind: i32): string;

#define OK                  0
#define ERROR              -1

#define REAL_PASS           0
#define DECL_ONLY_PASS      1

#define OFFSET_RETURN_TYPE   -1
#define OFFSET_RECEIVER_TYPE -2

#define ERROR_TY "__error_ty__"

type WaitingKind enum {
    Type = 1, TypePtr, FuncDef
}

// Used as some kind of callback
// When we resolve statements it may happen, that the statement uses type we
// have not yet resolved. In this case a waiting request will be placed for the
// correspoding type in the correspoding module.
// After a type has been resolved, tychk will check if there are pending requests
// for this type and resolve them accordingly.
type WaitingRequest struct {
    kind: WaitingKind,
    offset: i32, // e.g. index of field in Struct type
    to_fill: *ty.Type,
    to_fill_mod: *mod.Module,
    waiting_for: ident.Ident,
    waiting_for_mod: *mod.Module
}

def create_waiting_request(
    tc: *TypeChecker,
    kind: WaitingKind,
    to_fill: *ty.Type,
    to_fill_mod: *mod.Module,
    waiting_for: ident.Ident,
    waiting_for_mod: *mod.Module,
    offset: i32
): WaitingRequest {
    // it is easier to pass things like mymod.Mytype to this function and just
    // remove the 'mymod.' here instead of on the calling site
    patch_waiting_for(tc, &waiting_for, waiting_for_mod);

    return WaitingRequest {
        kind: kind,
        offset: offset,
        to_fill: to_fill,
        to_fill_mod: to_fill_mod,
        waiting_for: waiting_for,
        waiting_for_mod: waiting_for_mod
    };
}

def patch_waiting_for(
    tc: *TypeChecker,
    waiting_for: *ident.Ident,
    waiting_for_mod: *mod.Module
): void {
    if waiting_for_mod == tc.ctx.mod {
        return;
    }

    let len = ident.len(waiting_for);
    let dot_index = ident.index_of(waiting_for, len, '.');
    if dot_index > 0 {
        let ident_mod = get_mod_by_alias(tc.ctx, dot_index, ident.start(waiting_for));
        if ident_mod != waiting_for_mod {
            if ident_mod == null {
                io.printf("ERROR: alias '%.*s' was null\n", dot_index, ident.start(waiting_for));
            }
            // not recoverable and probably unreachable
            std.abort();
        }

        // remove the module path: 'mymod.test' => 'test'
        let old_span = waiting_for.span;
        let start = old_span.start + dot_index + 1;
        let end = old_span.end;

        let new_span = span.create(start, end);
        *waiting_for = ident.from_span(new_span);
    }
}

def req_waiting_for_ident(r: *WaitingRequest): *ident.Ident {
    return &r.waiting_for;
}

type WaitingRequestMap struct {
    init_flag: i32, // used to check if this is zeroed memory
    requests: vec.Vec, // Vec<Vec<WaitingRequest>>
    request_map: map.Map // Map<Type Ident, index into requests>
}

def create_waiting_request_map(): WaitingRequestMap {
    let map = WaitingRequestMap {
        init_flag: 1,
        requests: vec.create(sizeof vec.Vec),
        request_map: map.create()
    };

    return map;
}

def add_request(wrm: *WaitingRequestMap, request: WaitingRequest): void {
    let requests: *vec.Vec = null;

    let wanted_ident = req_waiting_for_ident(&request);
    // ------
    //  let s = ident.to_string(wanted_ident);
    //  let kind_s = "struct";
    //  if request.kind == WAITING_TYPE_PTR {
    //      kind_s = "ptr";
    //  } else if request.kind == WAITING_FUNC_DEF {
    //      kind_s = "func";
    //  }
    //  io.printf("DBG: >>> Adding %s request for '%s'\n ", kind_s, s);
    //  delete s;
    // ------

    let key = map.key_from_ident(wanted_ident);
    let request_idx = map.get(&wrm.request_map, key);
    let idx = -1;

    if request_idx == null || std.ptr_to_int(request_idx) == 0 {
        // create new vector
        idx = wrm.requests.len;
        let v = vec.create(sizeof WaitingRequest);
        wrm.requests.push(&v as *void);

        // TODO(#83): replace with vmap.Map
        // push its idx into the map
        request_idx = std.int_to_ptr(idx);
        // add one, to be able to tell null apart from 0
        map.insert(&wrm.request_map, key, request_idx + 1);
    } else {
        idx = std.ptr_to_int(request_idx) - 1;
    }

    requests = wrm.requests.get_ptr(idx) as *vec.Vec;
    requests.push(&request as *void);
}

def get_waiting(wrm: *WaitingRequestMap, ident: *ident.Ident): *vec.Vec {
    let key = map.key_from_ident(ident);
    let request_idx = map.get_and_remove(&wrm.request_map, key);

    if request_idx == null || std.ptr_to_int(request_idx) == 0 {
        return null;
    }

    let idx = std.ptr_to_int(request_idx) - 1;
    return wrm.requests.get_ptr(idx) as *vec.Vec;
}

def free_wait_map(wrm: *WaitingRequestMap): void {
    for let i = 0; i < wrm.requests.len; i = i + 1 {
        let v = wrm.requests.get_ptr(i) as *vec.Vec;
        v.free();
    }

    wrm.requests.free();
    map.free_m(&wrm.request_map);
}

type TypeError struct {
    text: string,
    span: span.Span
}

def err(tc: *TypeChecker, text: string, span: span.Span): TypeError {
    return TypeError { text: text, span: span };
}

def free_err(err: *TypeError): void {
    delete err.text;
}

type Ctx struct {
    in_loops: i32,
    mod: *mod.Module,
    current_func: *ty.Func, // the function that is currently being resolved (or null)
    imports: map.Map, // <string, *mod.Module>
    values: scope.ScopeStack,
    types: scope.ScopeStack
}

def create_ctx(mod: *mod.Module, global_types: *scope.Scope, global_values: *scope.Scope): *Ctx {
    let values = scope.create_stack();
    scope.push_scope(&values, global_values);
    scope.push_scope(&values, ty.get_value_scope(mod.ty));

    let types = scope.create_stack();
    scope.push_scope(&types, global_types);
    scope.push_scope(&types, ty.get_type_scope(mod.ty));

    return new Ctx {
        in_loops: 0,
        mod: mod,
        current_func: null,
        imports: map.create(),
        values: values,
        types: types
    };
}

def free_ctx(ctx: *Ctx): void {
    scope.free_stack(&ctx.types, 2);
    scope.free_stack(&ctx.values, 2);
    map.free_m(&ctx.imports);
    delete ctx;
}

def get_mod_by_alias(ctx: *Ctx, alias_len: i32, alias: string): *mod.Module {
    return map.get(&ctx.imports, map.create_key(alias_len, alias)) as *mod.Module;
}

type TypeChecker struct {
    decl_only_pass: bool, // the first pass ignores everything but declarations
    mods: *mod.Map,
    sorted_mods: *i32,
    ctx: *Ctx,
    main_func: *ty.Type,
    types: ptrvec.Vec,
    global_types: scope.Scope,
    global_values: scope.Scope,
    errors: vec.Vec, // <TypeError>
    requests: vec.Vec, // Vec<WaitingRequestMap> indexed by mod idx
    contexts: ptrvec.Vec
}

def (tc: *TypeChecker) in_loop(): bool {
    return tc.ctx.in_loops > 0;
}

def (tc: *TypeChecker) enter_loop() {
    tc.ctx.in_loops += 1;
}

def (tc: *TypeChecker) exit_loop() {
    dbg.assert(tc.ctx.in_loops > 0, "leaving non-existing loop");
    tc.ctx.in_loops -= 1;
}

// Basically the stuff, that is not freed after the typechecker is done
type CheckResult struct {
    had_errors: bool,
    types: ptrvec.Vec,
    mods: *mod.Map,
    global_types: scope.Scope,
    main_func: *ty.Type
}

def empty_result(): CheckResult {
    return create_result(false, ptrvec.create(), null, scope.create(), null);
}

def create_result(
    had_errors: bool,
    types: ptrvec.Vec,
    mods: *mod.Map,
    global_types: scope.Scope,
    main_func: *ty.Type
): CheckResult {
    return CheckResult {
        had_errors: had_errors,
        types: types,
        mods: mods,
        globals_types: global_types,
        main_func: main_func
    };
}

def free_result(r: *CheckResult): void {
    let i = 0;
    while i < r.types.len {
        ty.free_ty(r.types.get(i) as *ty.Type);
        i = i + 1;
    }

    r.types.free();
    scope.free_s(&r.global_types);
}

def create_err_result(tc: *TypeChecker): CheckResult {
    return create_result(true, tc.types, tc.mods, tc.global_types, null);
}

def create_check_result(tc: *TypeChecker): CheckResult {
    return create_result(num_errs(tc) > 0, tc.types, tc.mods, tc.global_types, tc.main_func);
}

def create(mods: *mod.Map): TypeChecker {
    let num_mods = mod.num_mods(mods);

    let tc = TypeChecker {
        decl_only_pass: false,
        mods: mods,
        sorted_mods: sorted_mods(mods),
        ctx: null,
        main_func: null,
        types: ptrvec.with_cap(256),
        global_types: scope.create(),
        global_values: scope.create(),
        errors: vec.create(sizeof TypeError),
        requests: vec.with_cap(sizeof WaitingRequestMap, num_mods),
        contexts: ptrvec.with_cap(num_mods)
    };
    tc.requests.init_zero();

    tc.global_types = create_global_types_scope(&tc);
    tc.global_values = create_global_values_scope(&tc, &tc.global_types);
    return tc;
}

def get_ctx(tc: *TypeChecker, idx: i32): *Ctx {
    return tc.contexts.unsafe_get(idx) as *Ctx;
}

def check(tc: *TypeChecker): CheckResult {
    let error = false;

    // first init all modules, since the waiting system expects this
    let n = mod.num_mods(tc.mods);
    let i = 0;
    while i < n {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        error = error || init_mod(tc, m, idx);

        i = i + 1;
    }

    // the decl only pass
    // TODO(#27): dont check stdlib if not needed
    i = 0;
    while i < n {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        if check_mod(tc, m, idx, DECL_ONLY_PASS) == ERROR {
            error = true;
        }

        i = i + 1;
    }

    if tc.errors.len > 0 {
        error = true;
    }

    // check for pending waitingrequests in all mods
    i = 0;
    while i < n {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        let wrm = get_waiting_map(tc, m);
        let iter = map.iter(&wrm.request_map);
        let next = map.iter_next(&iter);

        while next != null {
            let incomplete_ty = m.lookup_type(next.key.len, next.key.value).sym.ty;
            if incomplete_ty != null {
                // DBG START
                // io.printf("----\n");
                // let idx = std.ptr_to_int(next.value) - 1;
                // let waiting_for = vec.get_ptr(&wrm.requests, idx) as *vec.Vec;
                // if waiting_for == null {
                //     std.abort();
                // }

                // let j = 0;
                // while j < waiting_for.len {
                //     let waiting_for_ty = (vec.get_ptr(waiting_for, j) as *WaitingRequest).to_fill;
                //     let s: string = null;
                //     let free_this = ty.to_string(waiting_for_ty, &s);
                //     io.printf("DBG: !!!!!!!!!!! is still waiting: %s\n", s);
                //     if free_this {
                //         delete s;
                //     }
                //     j = j + 1;
                // }
                // DBG END

                dbg.assert(ty.is_struct(incomplete_ty), "incomplete_ty wasn't a struct");

                let s_ty = ty.as_struct(incomplete_ty);
                push_incomplete_ty_error(tc, &s_ty.super.original_name);
                error = true;
            } else {
                let idx = std.ptr_to_int(next.value) - 1;
                let pending = wrm.requests.get_ptr(idx) as *vec.Vec;
                dbg.assert(pending != null, "pending was null");

                let j = 0;
                while j < pending.len {
                    let req = pending.get_ptr(j) as *WaitingRequest;
                    push_not_defined_error(tc, &req.waiting_for, LookupKind.Types.to_string(), null);
                    error = true;
                    j = j + 1;
                }
            }

            next = map.iter_next(&iter);
        }

        i = i + 1;
    }

    // don't execute real pass if there are already errors
    if error {
        return create_err_result(tc);
    }

    // the real pass
    i = 0;
    while i < n {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        check_mod(tc, m, idx, REAL_PASS);

        i = i + 1;
    }

    return create_check_result(tc);
}

def init_mod(tc: *TypeChecker, m: *mod.Module, idx: i32): bool {
    dbg.assert(m.ty == null, "mod type should be null");
    let p = mod.get_path(m);
    // io.printf("DBG: Initializing (%d) %.*s\n", idx, p.len, p.inner);

    let ty = ty.new_mod(m.name.ref());
    m.ty = ty;

    let ctx = create_ctx(m, &tc.global_types, &tc.global_values);
    tc.contexts.set(idx, ctx as *void);
    tc.ctx = ctx;

    return false;
}

def check_mod(tc: *TypeChecker, m: *mod.Module, idx: i32, mode: i32): i32 {
    dbg.assert(m.ty != null, "mod type should not be null");

    let ctx = get_ctx(tc, idx);
    dbg.assert(ctx != null, "ctx should not be null");

    tc.ctx = ctx;
    tc.decl_only_pass = mode == DECL_ONLY_PASS;

    let ret = OK;

    let i = 0;
    while i < mod.num_stmts(m) {
        let result = check_stmt(tc, mod.get_stmt_at(m, i));

        if result != null {
            mod.set_stmt_at(m, i, result);
        } else {
            ret = ERROR;
        }

        i = i + 1;
    }

    return ret;
}

def wait_for(tc: *TypeChecker, req: WaitingRequest): void {
    let idx = req.waiting_for_mod.idx;
    let map = tc.requests.get_ptr(idx) as *WaitingRequestMap;

    if map.init_flag == 0 {
        *map = create_waiting_request_map();
    }

    add_request(map, req);
}

def get_waiting_map(tc: *TypeChecker, mod: *mod.Module): *WaitingRequestMap {
    return tc.requests.get_ptr(mod.idx) as *WaitingRequestMap;
}

def create_global_types_scope(tc: *TypeChecker): scope.Scope {
    // this is included in every module, so the visibility does not matter anyway
    let public = symbol.Visibility.Public;

    // TODO(#32): this should probably be defined in something like a builtin.kan
    let global = scope.create();
    let i8_ty = push_tmp_ty(tc, ty.new_i8());
    global.bind(2, "i8", i8_ty, public);
    global.bind(3, "i16", push_tmp_ty(tc, ty.new_i16()), public);
    global.bind(3, "i32", push_tmp_ty(tc, ty.new_i32()), public);
    global.bind(3, "i64", push_tmp_ty(tc, ty.new_i64()), public);
    global.bind(3, "f32", push_tmp_ty(tc, ty.new_f32()), public);
    global.bind(3, "f64", push_tmp_ty(tc, ty.new_f64()), public);
    global.bind(6, "string", push_tmp_ty(tc, ty.new_ptr(1, i8_ty)), public);

    global.bind(4, "void", push_tmp_ty(tc, ty.new_void()), public);
    global.bind(std.strlen(ERROR_TY), ERROR_TY, push_tmp_ty(tc, ty.new_error()), public);

    let bool_ty = push_tmp_ty(tc, ty.new_bool());
    global.bind(4, "bool", bool_ty, public);

    return global;
}

def create_global_values_scope(tc: *TypeChecker, global_types: *scope.Scope): scope.Scope {
    let global = scope.create();
    let bool_ty = global_types.get(4, "bool").sym.ty;
    global.bind(4, "true", bool_ty, symbol.Visibility.Public);
    global.bind(5, "false", bool_ty, symbol.Visibility.Public);

    return global;
}

def get_global_type(tc: *TypeChecker, len: i32, name: string): *ty.Type {
    // the return value of this is never checked, but since it isn't user supplied, it should
    // be correct anyway
    return tc.global_types.get(len, name).sym.ty;
}

def num_errs(tc: *TypeChecker): i32 {
    return tc.errors.len;
}

def push_err(tc: *TypeChecker, error: TypeError): void {
    tc.errors.push(&error as *void);
}

def push_mk_err(tc: *TypeChecker, text: string, span: span.Span): void {
    let error = err(tc, text, span);
    tc.errors.push(&error as *void);
}

def get_err(tc: *TypeChecker, i: i32): *TypeError {
    return tc.errors.get_ptr(i) as *TypeError;
}

def add_import_alias(tc: *TypeChecker, ident: *ident.Ident, mod: *mod.Module): void {
    map.insert(&tc.ctx.imports, map.key_from_ident(ident), mod as *void);
}

// sorts the mods after the number of imports inside
def sorted_mods(mods: *mod.Map): *i32 {
    let num_mods = mod.num_mods(mods);
    let import_nums = std.malloc(num_mods * sizeof i32) as *i32;

    let i = 0;
    while i < num_mods {
        let m = mod.get_mod(mods, i);
        *(import_nums + i) = mod.num_imports(m);
        i = i + 1;
    }

    let sorted_mods = ms.sort(import_nums, num_mods);
    delete import_nums;

    return sorted_mods;
}

def lookup_value(tc: *TypeChecker, name: *ident.Ident): symbol.Data {
    return scope.lookup(&tc.ctx.values, name);
}

def lookup_type(tc: *TypeChecker, name: *ident.Ident): symbol.Data {
    return scope.lookup(&tc.ctx.types, name);
}

// if the ident has a '.' inside it like 'mymod.test', out_mod will be set to a
// reference to the correspoding module (mymod) this will happen, even if out_mod
// does not contain the actual type (test)
def m_lookup_type(
    tc: *TypeChecker,
    name: *ident.Ident,
    out_mod: **mod.Module
): symbol.Data {
#define SET_OUT_MOD(m) if out_mod != null { *out_mod = (m); } 0

    let len = ident.len(name);
    let dot_index = ident.index_of(name, len, '.');
    if dot_index < 0 {
        // same module
        SET_OUT_MOD(tc.ctx.mod);
        return scope.lookup(&tc.ctx.types, name);
    }

    let m = get_mod_by_alias(tc.ctx, dot_index, ident.start(name));
    if m == null {
        SET_OUT_MOD(null);
        // io.printf("DBG DEBUG %.*s mod not found\n", len, ident.start(name));
        return symbol.empty();
    }

    SET_OUT_MOD(m);

    return m.lookup_type(len - dot_index - 1, ident.start(name) + dot_index + 1);
}

def checked_type_lookup(
    tc: *TypeChecker,
    name: *ident.Ident,
    out_ty: **ty.Type,
    out_mod: **mod.Module
): i32 {
    let data = m_lookup_type(tc, name, out_mod);
    if out_mod == null {
        *out_ty = data.ty_or_null();
        return OK;
    }

    if *out_mod == null {
        // TODO(#35): should just be module name
        push_not_defined_error(tc, name, LookupKind.Types.to_string(), null);
        return ERROR;
    }

    *out_ty = data.ty_or_null();
    return OK;
}

def lookup_tyid(tc: *TypeChecker, name: *tyid.Type): *ty.Type {
    let out: *ty.Type = null;
    let out_mod: *mod.Module = null;
    if checked_type_lookup(tc, &name.ident, &out, &out_mod) == ERROR
        || out == null
        || out_mod == null {

        push_not_defined_error(tc, &name.ident, LookupKind.Types.to_string(), null);
        return null;
    }

    if tyid.is_ptr(name) {
        return push_tmp_ty(tc, ty.new_ptr(name.pointer_count, out));
    }

    return out;
}

def check_func_tyid(
    tc: *TypeChecker,
    t: *ty.Type,
    id: *tyid.Type,
    offset: i32,
    waiting: *bool,
    out: **ty.Type
): bool {
    let ty_mod: *mod.Module = null;

    if checked_type_lookup(tc, &id.ident, out, &ty_mod) == ERROR {
        // module does not exist
        return true;
    }

    let checked = *out;
    if tyid.is_ptr(id) {
        checked = ty.new_ptr(id.pointer_count, checked);
        push_tmp_ty(tc, checked);
    }

    // types mod does exist, but the type itself has not yet been resolved
    if *out == null {
        func_wait_for_type(tc, ty_mod, id.ident, offset, t);
        *waiting = true;
    }

    *out = checked;
    return false;
}

def fill_func_def(
    tc: *TypeChecker,
    f_decl: *func.FuncDef,
    t: *ty.Type
): i32 {
    let f_ty = ty.as_func(t);

    let name = ident.to_string(&f_ty.name);
    // io.printf("DBG: Filling '%s'\n", name);
    delete name;

    let error = false;
    let waiting = true;

    let ret_ty: *ty.Type = null;

    // no return type == implicit void
    if tyid.is_empty(&f_decl.ret_ty) {
        ret_ty = get_global_type(tc, 4, "void");
    } else {
        error = check_func_tyid(
            tc, t, &f_decl.ret_ty, OFFSET_RETURN_TYPE, &waiting, &ret_ty
        );
    }

    let receiver_ty: *ty.Type = null;
    if f_decl.is_method {
        f_ty.is_method = true;

        let recv_waiting = false;
        error = check_func_tyid(
            tc, t, &f_decl.receiver.ty, OFFSET_RECEIVER_TYPE, &recv_waiting, &receiver_ty
        );

        if !(error || recv_waiting) {
            // You can only declare methods on user defined types (not on stuff like i32, f32 ...)
            if !ty.is_user_defined(receiver_ty) {
                let span = tyid.ident_span(&f_decl.receiver.ty);
                push_primitive_receiver_type_error(tc, receiver_ty, span);
                error = true;
            } else {
                ty.bind_method(receiver_ty, f_decl.name, t);
            }
        }

        waiting = waiting || recv_waiting;
    }

    let num_params = func.num_params(f_decl);
    let params = vec.with_cap(sizeof ty.Param, num_params);

    for let i = 0; i < num_params; i += 1 {
        let p = func.get_param_ptr(f_decl, i);

        // TODO(#37): handle varargs
        if func.is_varargs_param(p) {
            f_ty.is_varargs = true;
            continue;
        }

        let p_mod: *mod.Module = null;
        let p_ty_name = p.ty.ident;
        let p_ty: *ty.Type = null;

        if checked_type_lookup(tc, &p_ty_name, &p_ty, &p_mod) == ERROR {
            error = true;
            continue;
        }

        if p_ty == null && p_mod != null {
            func_wait_for_type(tc, p_mod, p_ty_name, i, t);
            waiting = true;
        }

        if tyid.is_ptr(&p.ty) {
            p_ty = ty.new_ptr(p.ty.pointer_count, p_ty);
            push_tmp_ty(tc, p_ty);
        }

        if p_ty != null && !ty.is_sized(p_ty) {
            push_unsized_param_error(tc, p_ty, tyid.ident_span(&p.ty));
            error = true;
        }

        let f_param = ty.create_param(p.name, p_ty);
        params.push(&f_param as *void);
    }

    if !error {
        f_ty.params = params;
        f_ty.ret = ret_ty;
        f_ty.receiver = ty.Param{ name: f_decl.receiver.name, ty: receiver_ty };
    } else {
        params.free();
        return ERROR;
    }

    return OK;
}

def push_tmp_ty(tc: *TypeChecker, ty: *ty.Type): *ty.Type {
    tc.types.push_ptr(ty as *void);
    return ty;
}

def open_scope(tc: *TypeChecker) {
    scope.open_scope(&tc.ctx.types);
    scope.open_scope(&tc.ctx.values);
}

def close_scope(tc: *TypeChecker) {
    scope.close_scope(&tc.ctx.types);
    scope.close_scope(&tc.ctx.values);
}

def bind_type(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_public(&tc.ctx.types, ident, ty);
}

def bind_value_public(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_public(&tc.ctx.values, ident, ty);
}

def bind_value_private(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type) {
    scope.bind_private(&tc.ctx.values, ident, ty);
}

def fill_struct_fields(tc: *TypeChecker, s_decl: *record.StructDecl, t: *ty.Type) {
    let s_ty = ty.as_struct(t);

    // let s = ident.to_string(&s_decl.name);
    // io.printf("----\nDBG: resolving %s\n", s);
    // delete s;

    let error = false;
    let waiting = false;

    let nf = record.num_fields(s_decl);
    s_ty.fields = vec.with_cap(sizeof ty.StructField, nf);
    for let i = 0; i < nf; i += 1 {
        let f = record.empty_field();
        if !record.field_at(s_decl, i, &f) {
            push_internal_error(tc, s_decl.name.span, "could not get field");
            return;
        }

        let mod: *mod.Module = null;
        let field_ty: *ty.Type = null;
        if checked_type_lookup(tc, &f.ty.ident, &field_ty, &mod) == ERROR {
            // push fake field here, so that the offset is not out of bounds
            ty.push_field(s_ty, f.ident, null);
            error = true;
            continue;
        }

        // pointers are ok, because their size is known
        let is_ptr = tyid.is_ptr(&f.ty);
        if field_ty == null {
            wait_for_struct_field(tc, mod, f.ty.ident, &f, i, t);
            if !is_ptr {
                waiting = true;
            }

            continue;
        }

        let is_struct = ty.is_struct(field_ty);
        if ty.is_initialized(field_ty) {
            if is_ptr {
                field_ty = ty.new_ptr(f.ty.pointer_count, field_ty);
                push_tmp_ty(tc, field_ty);
            }

            if !ty.is_sized(field_ty) {
                push_unsized_field_error(tc, field_ty, f.ty.ident.span);
                error = true;
            }

            ty.push_field(s_ty, f.ident, field_ty);
        } else if is_struct {
            // a struct that has not been initialized
            wait_for_struct_field(tc, mod, f.ty.ident, &f, i, t);
            if !is_ptr {
                waiting = true;
            }
        } else {
            // struct types should be the only uninitialized
            push_internal_error(tc, f.ident.span, "reached unreachable code");
            return;
        }
    }

    if !error && !waiting {
        ty.fill_width_align(t);

        // let s = ident.to_string(&s_decl.name);
        // io.printf("DBG: %s has a width of %d, align of %d\n", s, t.width, t.align);
        // delete s;

        update_all_waiting(tc, tc.ctx.mod, t, &s_ty.super.original_name);
        return;
    }
}

def wait_for_type(
    tc: *TypeChecker,
    kind: WaitingKind,
    waiting_for_mod: *mod.Module, // 'waiting_for' will be defined here
    waiting_for: ident.Ident,
    offset: i32,
    to_fill: *ty.Type
) : void {
    let request = create_waiting_request(
        tc,
        kind,
        to_fill,
        tc.ctx.mod,
        waiting_for,
        waiting_for_mod,
        offset
    );

    wait_for(tc, request);
}

def func_wait_for_type(
    tc: *TypeChecker,
    waiting_for_mod: *mod.Module, // 'waiting_for' will be defined here
    waiting_for: ident.Ident,
    offset: i32,
    to_fill: *ty.Type
): void {
    wait_for_type(
        tc,
        WaitingKind.FuncDef,
        waiting_for_mod,
        waiting_for,
        offset,
        to_fill
    );
}

def wait_for_struct_field(
    tc: *TypeChecker,
    mod: *mod.Module,
    waiting_for: ident.Ident,
    field: *record.Field,
    offset: i32,
    s_ty: *ty.Type
): void {
    let field_ty: *ty.Type = null;
    let kind = WaitingKind.Type;

    if tyid.is_ptr(&field.ty) {
        kind = WaitingKind.TypePtr;
        field_ty = ty.new_ptr(field.ty.pointer_count, null);
        push_tmp_ty(tc, field_ty);
    }
    ty.push_field(ty.as_struct(s_ty), field.ident, field_ty);

    dbg.assert(offset < ty.as_struct(s_ty).fields.len, "offset too big");

    let request = create_waiting_request(
        tc,
        kind,
        s_ty,
        tc.ctx.mod,
        waiting_for,
        mod,
        offset
    );

    wait_for(tc, request);
}

def update_all_waiting(
    tc: *TypeChecker,
    mod: *mod.Module,
    resolved_ty: *ty.Type,
    resolved_name: *ident.Ident
): void {
    // only execute this once
    if ty.was_touched_by_tychk(resolved_ty) {
        return;
    }
    ty.tychk_touch(resolved_ty);

    let waiting_map = get_waiting_map(tc, mod);
    let waiting = get_waiting(waiting_map, resolved_name);

    if waiting == null {
        // let name = ident.to_string(resolved_name);
        // io.printf(
        //     "DBG: no other types waiting for %s width: %d, align: %d\n",
        //     name, resolved_ty.width, resolved_ty.align
        // );
        // delete name;
        return;
    }

    // let name = ident.to_string(resolved_name);
    // io.printf("DBG: %d types waiting for %s\n", waiting.len, name);
    // delete name;

    for let i = 0; i < waiting.len; i = i + 1 {
        let req = waiting.get_ptr(i) as *WaitingRequest;
        update_waiting(tc, req, resolved_ty);
    }

    // let s = ident.to_string(resolved_name);
    // io.printf("DBG: ---- %s width: %d, align: %d\n", s, resolved_ty.width, resolved_ty.align);
    // delete s;
}

def update_waiting(tc: *TypeChecker, req: *WaitingRequest, resolved_ty: *ty.Type): void {
    let waiting_ty = req.to_fill;
    let waiting_mod = req.to_fill_mod;

    if req.kind == WaitingKind.Type || req.kind == WaitingKind.TypePtr {
        let waiting_s_ty = ty.as_struct(waiting_ty);
        let waiting_ident = &waiting_s_ty.super.original_name;

        // ----- DBG -----
        // let resolved_name: string = null;
        // if ty.is_struct(resolved_ty) {
        //     resolved_name = ident.to_string(&ty.as_struct(resolved_ty).name);
        // } else {
        //     resolved_name = std.strdup("type");
        // }

        // let waiting_name = ident.to_string(waiting_ident);
        // io.printf(
        //     "DBG: %s was waiting for %s (%d %d)\n", waiting_name, resolved_name,
        //     resolved_ty.width, resolved_ty.align
        // );
        // delete waiting_name;
        // delete resolved_name;
        // -----

        let field = ty.field_at(waiting_s_ty, req.offset);

        if req.kind == WaitingKind.Type {
            field.ty = resolved_ty;
        } else if req.kind == WaitingKind.TypePtr {
            if !ty.is_ptr(field.ty) {
                push_internal_error(tc, waiting_ident.span, "type is not a ptr");
                return;
            }

            ty.update_inner(field.ty, resolved_ty);
        }

        // overwrite old type in struct
        ty.update_field_ty(waiting_s_ty, field);

        // TODO(#43): calling this all the time is very inefficient
        let completely_initialized = ty.fill_width_align(waiting_ty);
        if completely_initialized {
            // recursively update types waiting for waiting_ty
            update_all_waiting(tc, waiting_mod, waiting_ty, waiting_ident);
        }

        return;
    }

    if req.kind == WaitingKind.FuncDef {
        let waiting_f_ty = ty.as_func(waiting_ty);
        let waiting_ident = &waiting_f_ty.name;

        if req.offset < 0 {
            let to_update = &waiting_f_ty.ret;

            if req.offset == OFFSET_RECEIVER_TYPE {
                to_update = &waiting_f_ty.receiver.ty;
            }

            if *to_update != null {
                // if the type is a pointer, there will already be ty.Ptr with
                // an empty inner type here, so we just fill in the resolved
                // inner type into the existing one
                if ty.is_ptr(*to_update) {
                    ty.update_inner(*to_update, resolved_ty);
                    if req.offset == OFFSET_RECEIVER_TYPE {
                        ty.bind_method(*to_update, waiting_f_ty.name, waiting_ty);
                    }
                } else {
                    push_internal_error(tc, waiting_ident.span, "type is not a ptr");
                    return;
                }
            } else {
                *to_update = resolved_ty;
                if req.offset == OFFSET_RECEIVER_TYPE {
                    ty.bind_method(*to_update, waiting_f_ty.name, waiting_ty);
                }
            }
        } else {
            let p = ty.param_at(waiting_f_ty, req.offset);
            // if there was an error during function initialization, there may
            // be no params, but the error should already have been propagated
            if p != null {
                if p.ty != null {
                    if ty.is_ptr(p.ty) {
                        ty.update_inner(p.ty, resolved_ty);
                    } else {
                        push_internal_error(tc, waiting_ident.span, "type is not a ptr");
                        return;
                    }
                } else {
                    p.ty = resolved_ty;
                }
            }
        }

        // if ty.func_is_initalized(waiting_f_ty) {
        //     let s = ident.to_string(&waiting_f_ty.name);
        //     io.printf("DBG: %s is fully initialized\n", s);
        //     delete s;
        // }
        return;
    }

    dbg.assert(false, "reached unreachable code");
}

def get_import_alias(tc: *TypeChecker, imp: *ast.ImportStmt): ident.Ident {
    if ast.import_has_alias(imp) {
        return imp.alias;
    }

    let old_span = imp.mod.span;
    let p = path.empty();
    if path.from_str_len(ident.start(&imp.mod), ident.len(&imp.mod), &p).is_not_ok() {
        return ident.empty();
    }

    let lsp = path.last_separator_ptr(&p);
    if lsp == null {
        // there is no separator
        return imp.mod;
    }
    lsp = lsp + 1; // skip the actual separator

    let offset = lsp - ident.start(&imp.mod);
    let start = old_span.start + offset;
    let end = start + p.len - offset;

    let new_span = span.create(start, end);
    return ident.from_span(new_span);
}

def check_import(
    tc: *TypeChecker,
    i_s: *ast.ImportStmt,
    out_alias: *ident.Ident,
    out_ty: **ty.Type
): bool {
    let error: string = null;
    let imported_mod = mod.try_get_mod_from_import(
        tc.mods,
        tc.ctx.mod,
        i_s,
        &error
    );

    // no such module
    if imported_mod == null {
        // TODO(#45): for some reason this error is sometimes duplicated
        //  to recreate, just import a non existing file
        push_mk_err(tc, error, i_s.mod.span);
        return false;
    }

    let alias = get_import_alias(tc, i_s);
    if ident.start(&alias) == null {
        push_internal_error(tc, i_s.mod.span, "import alias was empty");
        return false;
    }
    add_import_alias(tc, &alias, imported_mod);

    let mod_ty = imported_mod.ty;
    dbg.assert(mod_ty != null, "mod_ty should not be null");

    *out_alias = alias;
    *out_ty = mod_ty;

    return true;
}

def check_struct_decl(tc: *TypeChecker, sd: *record.StructDecl): *ty.Type {
    let ty = declare_struct(tc, sd);
    if ty == null {
        // TODO(#46): output an actual error message here, instead of just failing silently
        return null;
    }

    fill_struct_fields(tc, sd, ty);
    return ty;
}

// TODO(#103): remove duplicated code
def declare_struct(tc: *TypeChecker, sd: *record.StructDecl): *ty.Type {
    let prev = lookup_type(tc, &sd.name);
    if prev.present() {
        push_duplicate_def_error(tc, &sd.name);
        return null;
    }

    let definition = ty.new_type(ty.Kind.Struct, null);
    push_tmp_ty(tc, definition);

    let owned_name = mangle_type_name(tc, &sd.name);
    ty.init_struct(definition, sd.name, owned_name, tc.ctx.mod);
    return definition;
}

// This is just temporary until compile time code execution is working, so it's not part of std.kan
extern def strtol(start: string, end: *string, base: i32): i32;

def check_enum_decl(tc: *TypeChecker, decl_stmt: *ast.EnumDeclStmt): *ty.Type {
    let ed = &decl_stmt.decl;
    let decl = declare_enum(tc, ed);
    if decl == null {
        return null;
    }

    let e_ty = ty.as_enum(decl);
    let start_value = 0;

    if decl_stmt.start_value != null {
        let init = check_expr(tc, decl_stmt.start_value);
        if init == null {
            return null;
        }

        // TODO: allow enums of i64, i16...
        // currently only i32, no other integer types
        if !ty.is_i32(init.ty) {
            push_invalid_enum_start_value_error(tc, e_ty, init);
            return null;
        }

        if !ast.is_int_expr(decl_stmt.start_value) {
            push_internal_error(
                tc,
                decl_stmt.start_value.span,
                "The compiler cannot handle arbitrary enum start value expressions yet"
            );
        }

        let value_span = decl_stmt.start_value.span;
        let literal_len = span.len(value_span);
        let value_end = value_span.end;
        // this does no error checks, since the lexer/parser should ensure the correctness.
        start_value = strtol(value_span.start, &value_end, 10);
    }

    for let i = 0; i < ed.values.len; i = i + 1 {
        let name: ident.Ident = undefined;
        ed.values.get(i, &name as *void);
        if ty.push_enum_value(decl, name, start_value + i) {
            push_duplicate_enum_value_error(tc, e_ty, &name);
            return null;
        }
    }

    update_all_waiting(tc, tc.ctx.mod, decl, &e_ty.super.original_name);
    return decl;
}

def declare_enum(tc: *TypeChecker, ed: *record.EnumDecl): *ty.Type {
    // since enum names are values and types at the same time, we have to check for name
    // collisions with values and types aswell
    let prev = lookup_type(tc, &ed.name);
    if !prev.present() {
        prev = lookup_value(tc, &ed.name);
    }
    if prev.present() {
        push_duplicate_def_error(tc, &ed.name);
        return null;
    }

    let definition = ty.new_type(ty.Kind.Enum, null);
    push_tmp_ty(tc, definition);

    let owned_name = mangle_type_name(tc, &ed.name);
    // currently, all enums are just i32 values
    let base_type = get_global_type(tc, 3, "i32");
    ty.init_enum(definition, ed.name, owned_name, tc.ctx.mod, base_type);
    return definition;
}

def check_func_decl(tc: *TypeChecker, fd: *func.FuncDef): *ty.Type {
    let ty = declare_func(tc, fd);
    if ty == null {
        return null;
    }

    if fill_func_def(tc, fd, ty) == ERROR {
        return null;
    }

    return ty;
}

def declare_func(tc: *TypeChecker, fd: *func.FuncDef): *ty.Type {
    if !fd.is_method && lookup_value(tc, &fd.name).present() {
        push_duplicate_def_error(tc, &fd.name);
        return null;
    }

    let definition = ty.new_type(ty.Kind.Func, null);
    push_tmp_ty(tc, definition);

    let mangled_name = mangle_func_name(tc, fd);
    ty.init_func(definition, fd.name, mangled_name, tc.ctx.mod, fd.is_extern);

    if ident.eq_lit(&fd.name, "main") {
        if tc.main_func != null {
            // TODO(#94): custom error for duplicated main function
            //  with reference to original
            push_duplicate_def_error(tc, &fd.name);
            return null;
        }

        tc.main_func = definition;
        let f_ty = ty.as_func(definition);

        // "demangle" main name
        name.free_owned(&f_ty.mangled_name);
        f_ty.mangled_name = name.make_copied(4, "main");
    }

    return definition;
}

def check_func_body(tc: *TypeChecker, f_s: *ast.FuncDeclStmt): *ast.BlockStmt {
    let f_name = &f_s.decl.name;
    let f_ty = f_s.decl.func_ty;

    if f_ty == null {
        push_not_defined_error(tc, f_name, LookupKind.Values.to_string(), null);
        return null;
    }

    if !ty.is_func(f_ty) {
        push_internal_error(tc, f_name.span, "type is not a function");
        return null;
    }

    let f_ty = ty.as_func(f_ty);
    if !ty.func_is_initalized(f_ty) {
        // --- DBG ---
        //  let name_s = ident.to_string(f_name);
        //  io.printf("DBG: %s is not fully initialized\n", name_s);
        //  delete name_s;
        // --- DBG ---

        // in this case, an error will be pushed later
        return null;
    }

    // let name_s = ident.to_string(f_name);
    // io.printf(">> DBG: Checking %s body\n", name_s);
    // delete name_s;

    if f_ty.is_extern {
        return null;
    }

    let last_func = tc.ctx.current_func;
    tc.ctx.current_func = f_ty;
    open_scope(tc);

    if f_ty.is_method {
        bind_value_public(tc, &f_ty.receiver.name, f_ty.receiver.ty);
    }

    // bind params
    let i = 0;
    while i < f_ty.params.len {
        let p = ty.param_at(f_ty, i);
        bind_value_public(tc, &p.name, p.ty);
        i = i + 1;
    }

    if f_s.block == null {
        push_internal_error(tc, f_s.decl.name.span, "func body is null");
        close_scope(tc);
        tc.ctx.current_func = last_func;
        return null;
    }

    // check function body
    let body = check_stmt(tc, f_s.block as *ast.Stmt);
    if body == null {
        close_scope(tc);
        return null;
    }
    f_s.block = body as *ast.BlockStmt;

    if !ty.is_void(f_ty.ret) {
        if tc.check_for_return_stmt(f_s.block) == ERROR {
            push_missing_return_error(tc, f_s.decl.name.span);
            close_scope(tc);
            tc.ctx.current_func = last_func;
            return null;
        }
    }

    close_scope(tc);
    tc.ctx.current_func = last_func;

    return f_s.block;
}

// Checks if the last stmt of a block is guaranteed to have a return statement
// Pseudo code:
// - last stmt is return -> ok
// - last stmt is if
//     - if has unconditional else
//         - if contains return && else contains return -> ok
//         - branches contains more ifs -> goto begin
//         - error
//     - error
// - error
def (tc: *TypeChecker) check_for_return_stmt(block: *ast.BlockStmt): i32 {
    if block.stmts.len <= 0 {
        return ERROR;
    }

    let last_stmt = ast.stmt_at(block, block.stmts.len - 1);
    if ast.is_return_stmt(last_stmt) {
        return OK;
    } else if ast.is_if_stmt(last_stmt) {
        let if_stmt = ast.as_if_stmt(last_stmt);
        let else_stmt = if_stmt.else_stmt;
        let run = true;
        while run && else_stmt != null {
            if ast.is_if_stmt(else_stmt) {
                // if else (...) {...}
                else_stmt = ast.as_if_stmt(else_stmt).else_stmt;
            } else {
                // else {...}
                run = false;
            }
        }

        // no unconditional else statement
        if else_stmt == null {
            return ERROR;
        }
        let else_stmt = ast.as_block_stmt(else_stmt);

        let if_has_return = tc.check_for_return_stmt(if_stmt.block);
        let else_has_return = tc.check_for_return_stmt(else_stmt);

        if if_has_return == OK && else_has_return == OK {
            let span = span.create(block.s.span.end, block.s.span.end);

            // just add a null value here. This is unreachable, but we currently don't have a
            // statement for that
            let value = ast.new_null_expr(span);
            value.ty = tc.ctx.current_func.ret;

            block.push(ast.new_return_stmt(span, value));
            return OK;
        }
    }

    return ERROR;
}

// returns the statement which should replace the old one
// if a new statement is created, this function will free the old one
def check_stmt(tc: *TypeChecker, s: *ast.Stmt): *ast.Stmt {
    // STMT_IMPORT
    if ast.is_import_stmt(s) {
        let i_s = ast.as_import_stmt(s);

        let alias: ident.Ident = ident.empty();
        let ty: *ty.Type = null;

        if !check_import(tc, i_s, &alias, &ty) {
            return null;
        }

        // since types and/or values could be imported, imports live in both namespaces
        bind_type(tc, &alias, ty);
        bind_value_private(tc, &alias, ty);
        return s;
    }

    // STMT_STRUCT_DECL
    if ast.is_struct_decl_stmt(s) {
        let sd = &ast.as_struct_decl_stmt(s).decl;

        if !tc.decl_only_pass {
            return s;
        }

        let ty = check_struct_decl(tc, sd);
        if ty == null {
            return null;
        }

        bind_type(tc, &sd.name, ty);
        sd.struct_ty = ty;

        return s;
    }

    // STMT_ENUM_DECL
    if ast.is_enum_decl_stmt(s) {
        let decl_stmt = ast.as_enum_decl_stmt(s);
        let ed = &decl_stmt.decl;

        if !tc.decl_only_pass {
            return s;
        }

        let ty = check_enum_decl(tc, decl_stmt);
        if ty == null {
            return null;
        }

        // the name of an enum can refer to both, the Enum scope (value) or the enum Type
        bind_type(tc, &ed.name, ty);
        bind_value_public(tc, &ed.name, ty);
        ed.enum_ty = ty;

        return s;
    }

    // STMT_FUNC_DECL
    if ast.is_func_decl_stmt(s) {
        let f_s = ast.as_func_decl_stmt(s);
        let fd = &f_s.decl;

        if tc.decl_only_pass {
            let ty = check_func_decl(tc, fd);

            if ty == null {
                return null;
            }

            fd.func_ty = ty;
            if !fd.is_method {
                bind_value_public(tc, &fd.name, ty);
            }

            return s;
        }

        // at this point, all the types inside the function signature have to be resolved,
        // so it is safe to access the receiver type
        if fd.is_method {
            let receiver_ty = ty.as_func(fd.func_ty).receiver.ty;
            if receiver_ty == null {
                return null;
            }

            if ty.get_user_defined(receiver_ty).declared_in != tc.ctx.mod {
                push_receiver_different_module_error(tc, tyid.ident_span(&fd.receiver.ty));
                return null;
            }
        }

        // only resolve the block in the actual pass
        let block = check_func_body(tc, f_s);
        if block == null && !f_s.decl.is_extern {
            return null;
        }

        f_s.block = block;
        return s;
    }

    // STMT_LET
    if ast.is_let_stmt(s) {
        let l_s = ast.as_let_stmt(s);
        let value: *ast.Expr = null;

        // this is only executed for global let statements, since we don't check
        // the function bodies in the decl_only_pass
        if tc.decl_only_pass {
            // placeholder to bind the name
            let temp_ty = get_global_type(tc, std.strlen(ERROR_TY), ERROR_TY);
            // we need to bind the name here, so we can give an error, when someone
            // tries to write a function with the same name
            bind_value_private(tc, &l_s.ident, temp_ty);
            return s;
        }

        let expected_ty: *ty.Type = null;
        if ast.has_type_decl(l_s) {
            expected_ty = lookup_tyid(tc, &l_s.ty);
            if expected_ty == null {
                return null;
            }

            value = check_expr_expect(tc, l_s.value, expected_ty, null);
        } else {
            value = check_expr(tc, l_s.value);
        }

        // TODO(#104): do we need these 2 bind_value calls? shouldn't the value already be ERROR?

        if value == null {
            // bind the error type here, to get rid of follow up errors
            let temp_ty = get_global_type(tc, std.strlen(ERROR_TY), ERROR_TY);
            bind_value_private(tc, &l_s.ident, temp_ty);
            return null;
        }

        if expected_ty != null {
            if !ty.equals(value.ty, expected_ty) {
                push_wrong_let_type_error(tc, expected_ty, value.ty, s.span);
                // bind the error type here, to get rid of follow up errors
                let temp_ty = get_global_type(tc, std.strlen(ERROR_TY), ERROR_TY);
                bind_value_private(tc, &l_s.ident, temp_ty);
                return null;
            }
        }

        if !ty.is_sized(value.ty) {
            push_type_not_assignable_error(tc, value);
            return null;
        }

        // TODO(#71): if a let stmt is in global scope, it should only allow compile time
        //  expressions as initialization

        let bind_f = &bind_value_public;

        let is_global = scope.num_scopes(&tc.ctx.values) < 3;
        if is_global {
            // we currently have strong constraints for global vars
            // this will change when compile time code evaluation is introduced
            if !(ast.is_string_expr(value) || ast.is_int_expr(value)) {
                push_non_const_expr_error(tc, value.span);
                return null;
            }

            bind_f = &bind_value_private;
        }

        l_s.value = value;
        bind_f(tc, &l_s.ident, l_s.value.ty);
        return s;
    }

    // the statements below this should only be resolved in the real pass
    if tc.decl_only_pass {
        return s;
    }

    // STMT_BLOCK
    if ast.is_block_stmt(s) {
        let b_s = ast.as_block_stmt(s);

        let error = false;
        open_scope(tc);

        let i = 0;
        while i < b_s.stmts.len {
            let stmt = ast.stmt_at(b_s, i);

            let checked = check_stmt(tc, stmt);
            if checked == null {
                error = true;
            } else {
                ast.set_stmt_at(b_s, i, checked);
            }

            i = i + 1;
        }

        close_scope(tc);

        if error {
            return null;
        }

        return s;
    }

    // STMT_EXPR
    if ast.is_expr_stmt(s) {
        let e_s = ast.as_expr_stmt(s);
        let expr = check_expr(tc, e_s.expr);

        if expr == null {
            return null;
        }

        if !ty.is_sized(expr.ty) && !ast.is_call_expr(expr) {
            push_invalid_expr_error(tc, expr);
            return null;
        }

        e_s.expr = expr;
        return s;
    }

    // STMT_DELETE
    if ast.is_delete_stmt(s) {
        let d_s = ast.as_delete_stmt(s);
        let expr = check_expr(tc, d_s.expr);

        if expr == null {
            return null;
        }

        if !ty.is_ptr(expr.ty) {
            push_delete_non_ptr_error(tc, expr);
            return null;
        }

        d_s.expr = expr;
        return s;
    }

    // STMT_IF
    if ast.is_if_stmt(s) {
        let i_s = ast.as_if_stmt(s);
        let condition = check_expr(tc, i_s.condition);

        if condition == null {
            return null;
        }

        let bool_ty = get_global_type(tc, 4, "bool");
        if !ty.equals(bool_ty, condition.ty) {
            push_invalid_condition_error(tc, condition);
            return null;
        }
        i_s.condition = condition;

        let block = check_stmt(tc, i_s.block as *ast.Stmt);
        if block == null {
            return null;
        }
        i_s.block = block as *ast.BlockStmt;

        if (i_s.else_stmt != null) {
            let else_stmt = check_stmt(tc, i_s.else_stmt);
            if else_stmt == null {
                return null;
            }
            i_s.else_stmt = else_stmt;
        }

        return s;
    }

    // STMT_WHILE
    if ast.is_while_stmt(s) {
        let w_s = ast.as_while_stmt(s);
        let condition = check_expr(tc, w_s.condition);

        if condition == null {
            return null;
        }

        let bool_ty = get_global_type(tc, 4, "bool");
        if !ty.equals(bool_ty, condition.ty) {
            push_invalid_condition_error(tc, condition);
            return null;
        }
        w_s.condition = condition;

        tc.enter_loop();

        let block = check_stmt(tc, w_s.block as *ast.Stmt);
        if block == null {
            return null;
        }
        w_s.block = block as *ast.BlockStmt;

        tc.exit_loop();

        return s;
    }

    // STMT_FOR
    if ast.is_for_stmt(s) {
        let f_s = ast.as_for_stmt(s);

        let init: *ast.Stmt = null;
        if f_s.initializer != null {
            init = check_stmt(tc, f_s.initializer);
            if init == null {
                return null;
            }
            f_s.initializer = null;
        }

        let condition = check_expr(tc, f_s.condition);
        if condition == null {
            return null;
        }

        let bool_ty = get_global_type(tc, 4, "bool");
        if !ty.equals(bool_ty, condition.ty) {
            push_invalid_condition_error(tc, condition);
            return null;
        }
        f_s.condition = null;

        let increment: *ast.Stmt = null;
        if f_s.increment != null {
            increment = check_stmt(tc, f_s.increment);
            if increment == null {
                return null;
            }
            f_s.increment = null;
        }

        tc.enter_loop();

        let block = check_stmt(tc, f_s.block as *ast.Stmt) as *ast.BlockStmt;
        if block == null {
            return null;
        }
        f_s.block = null;

        tc.exit_loop();

        // transform for statement into while stmt
        // this for loop compiles to...
        // for let i = 0; i < 3; i = i + 1 {
        //     ...
        // }
        //
        // ...this block
        // {
        //     let i = 0;
        //     while i < 3 {
        //         {
        //             ...
        //         }
        //         END_BLOCK: {
        //             i = i + 1;
        //         }
        //     }
        // }

        let w_s = ast.new_while_stmt(s.span, condition, block);

        if increment != null {
            let inc_block = ast.new_block_stmt(increment.span, ptrvec.with_cap(1));
            let inc_block = inc_block as *ast.BlockStmt;

            ast.push_stmt(inc_block, increment);
            ast.as_while_stmt(w_s).end_block = inc_block;
        }

        let statements = ptrvec.with_cap(2);
        if init != null {
            statements.push_ptr(init as *void);
        }
        statements.push_ptr(w_s as *void);

        let original_span = s.span;
        ast.stmt_free(s);
        return ast.new_block_stmt(original_span, statements);
    }

    // STMT_RETURN
    if ast.is_return_stmt(s) {
        let r_s = ast.as_return_stmt(s);
        if r_s.expr == null {
            return s;
        }

        let expr = check_expr_expect(tc, r_s.expr, tc.ctx.current_func.ret, null);
        if expr == null {
            return null;
        }

        if !ty.equals(tc.ctx.current_func.ret, expr.ty) {
            push_wrong_return_type_error(tc, expr);
            return null;
        }

        r_s.expr = expr;
        return s;
    }

    // STMT_CONTINUE
    if ast.is_continue_stmt(s) {
        if !tc.in_loop() {
            push_outside_loop_error(tc, s.span, "continue");
            return null;
        }

        return s;
    }

    // STMT_BREAK
    if ast.is_break_stmt(s) {
        if !tc.in_loop() {
            push_outside_loop_error(tc, s.span, "break");
            return null;
        }

        return s;
    }

    return null;
}

type LookupKind enum {
    Types, Values, Both
}

def (kind: LookupKind) to_string(): string {
    if kind == LookupKind.Types {
        return "type";
    }
    if kind == LookupKind.Types {
        return "value";
    }
    return "value or type";
}

// used for resolving access and ident expressions
type LookupData struct {
    kind: LookupKind,
    scope: *scope.Scope,
    was_type: bool
}

def create_lookup_data(kind: LookupKind, scope: *scope.Scope): LookupData {
    return LookupData {
        kind: kind, scope: scope, was_type: false
    };
}

def (d: *LookupData) copy(): LookupData {
    if d == null {
        return create_lookup_data(LookupKind.Values, null);
    }
    return *d;
}

def (d: *LookupData) to_string(): string {
    if d == null || d.kind == LookupKind.Values {
        return "value";
    }
    if d.kind == LookupKind.Types {
        return "type";
    }

    return "value of type";
}

def (d: *LookupData) lookup_ident(tc: *TypeChecker, name: *ident.Ident): symbol.Data {
    if d == null {
        return lookup_value(tc, name);
    }

    if d.scope != null {
        return d.scope.get_ident(name);
    }

    if d.kind == LookupKind.Types {
        d.was_type = true;
        return lookup_type(tc, name);
    }

    let value = lookup_value(tc, name);
    if d.kind == LookupKind.Values {
        return value;
    }

    if !value.present() {
        d.was_type = true;
        value = lookup_type(tc, name);
    }

    return value;
}

def (d: *LookupData) lookup_ident_in(t: *ty.Type, name: *ident.Ident): symbol.Data {
    if d == null {
        return ty.lookup_value_in(t, name);
    }

    if d.kind == LookupKind.Types {
        d.was_type = true;
        return ty.lookup_type_in(t, name);
    }

    let value = ty.lookup_value_in(t, name);
    if d.kind == LookupKind.Values {
        return value;
    }

    if !value.present() {
        d.was_type = true;
        value = ty.lookup_type_in(t, name);
    }

    return value;
}

def (d: *LookupData) was_type_decl(): bool {
    return d != null && d.was_type;
}

def (d: *LookupData) is_type_accessible(t: *ty.Type): bool {
    if d == null {
        return ty.is_value_scoped(t);
    }

    let kind = d.kind;
    let is_value_lookup = kind == LookupKind.Values || kind == LookupKind.Both;
    let is_type_lookup = kind == LookupKind.Types || kind == LookupKind.Both;

    let value_scoped = is_value_lookup && ty.is_value_scoped(t);
    let type_scoped = is_type_lookup && ty.is_type_scoped(t);
    return value_scoped || type_scoped;
}

def check_expr(tc: *TypeChecker, e: *ast.Expr): *ast.Expr {
    return check_expr_expect(tc, e, null, null);
}

// if data == null, LookupKind.Values is assumed
def check_expr_expect(
    tc: *TypeChecker,
    e: *ast.Expr,
    expected: *ty.Type,
    data: *LookupData
): *ast.Expr {
    // EXPR_INT || EXPR_CHAR
    if ast.is_int_expr(e) || ast.is_char_expr(e) {
        // TODO: check size of literal to determine correct integer width
        if expected != null {
            if ty.is_i8(expected) {
                e.ty = get_global_type(tc, 2, "i8");
                return e;
            }
            if ty.is_i16(expected) {
                e.ty = get_global_type(tc, 3, "i16");
                return e;
            }
            if ty.is_i32(expected) {
                e.ty = get_global_type(tc, 3, "i32");
                return e;
            }
            if ty.is_i64(expected) {
                e.ty = get_global_type(tc, 3, "i64");
                return e;
            }
        }

        if ast.is_char_expr(e) {
            e.ty = get_global_type(tc, 2, "i8");
            return e;
        }

        e.ty = get_global_type(tc, 3, "i32");
        return e;
    }

    // EXPR_FLOAT
    if ast.is_float_expr(e) {
        if expected != null && ty.is_f64(expected) {
            e.ty = get_global_type(tc, 3, "f64");
            return e;
        }

        e.ty = get_global_type(tc, 3, "f32");
        return e;
    }

    // EXPR_NULL
    if ast.is_null_expr(e) {
        if expected != null {
            if ty.is_ptr(expected) {
                e.ty = expected;
                return e;
            }
        }
        push_could_not_infer_error(tc, e.span);
        return null;
    }

    // EXPR_UNDEFINED
    if ast.is_undefined_expr(e) {
        // undefined can take any value, as long as we know the type
        if expected != null {
            e.ty = expected;
            return e;
        }
        push_could_not_infer_error(tc, e.span);
        return null;
    }

    // EXPR_STRING
    if ast.is_string_expr(e) {
        e.ty = get_global_type(tc, 6, "string");
        return e;
    }

    // EXPR_IDENT
    if ast.is_ident_expr(e) {
        let ident = &ast.as_ident_expr(e).ident;
        e.ty = data.lookup_ident(tc, ident).ty_or_null();

        if e.ty == null {
            push_not_defined_error(tc, ident, data.to_string(), null);
            return null;
        }

        if ty.is_error(e.ty) {
            // when a binding definition fails, we just bind a special error
            // type to the name and return null here without pushing an actual error.
            // This will prevent 'follow up' errors
            return null;
        }

        return e;
    }

    // EXPR_ACCESS
    if ast.is_access_expr(e) {
        let a_e = ast.as_access_expr(e);

        let left = check_expr_expect(tc, a_e.left, expected, data);
        if left == null {
            return null;
        }

        a_e.left = left;
        let left_ty = a_e.left.ty;

        // TODO(#86): add a special message for pointers to pointers
        //  "Type 'pointer' cannot be accessed with '.' operator" does not
        //  make sense, when the actual pointer to a struct can be accessed with '.'

        if !data.is_type_accessible(left_ty) {
            // TODO(#52): the span here is the span of the entire left access, which
            //  is probably not what we want...
            push_not_accessible_with_error(tc, a_e.left);
            return null;
        }

        let name = &a_e.right.ident;
        let right = data.lookup_ident_in(left_ty, name);
        if !right.present() {
            push_not_defined_error(tc, &a_e.right.ident, data.to_string(), right.scope);
            return null;
        }

        if right.is_private() {
            push_access_private_symbol_error(tc, &a_e.right.ident, right.scope);
            return null;
        }

        e.ty = right.ty_or_null();
        return e;
    }

    // EXPR_BINARY
    if ast.is_binary_expr(e) {
        let b_e = ast.as_binary_expr(e);
        let left: *ast.Expr = null;
        let right: *ast.Expr = null;

        if ast.is_null_expr(b_e.left) {
            right = check_expr_expect(tc, b_e.right, expected, data);
            if right != null {
                left = check_expr_expect(tc, b_e.left, right.ty, data);
            }
        } else {
            left = check_expr_expect(tc, b_e.left, expected, data);
            if left != null {
                right = check_expr_expect(tc, b_e.right, left.ty, data);
            }
        }

        if left == null || right == null {
            return null;
        }

        let ty = check_binary_expr(
            tc, b_e.kind, b_e.op_span, left.ty, right.ty, e.span
        );

        if ty == null {
            return null;
        }

        b_e.left = left;
        b_e.right = right;
        e.ty = ty;
        return e;
    }

    // EXPR_ASSIGN
    if ast.is_assign_expr(e) {
        let a_e = ast.as_assign_expr(e);
        let left = check_expr(tc, a_e.left);

        if left == null {
            return null;
        }

        if !ast.is_assignable(left) {
            push_expr_not_assignable_error(tc, left);
            return null;
        }

        let right = check_expr_expect(tc, a_e.right, left.ty, data);
        if right == null {
            return null;
        }

        if !ty.equals(left.ty, right.ty) {
            push_bin_invalid_types_error(tc, left.ty, right.ty, e.span);
            return null;
        }

        if !ty.is_sized(right.ty) {
            push_type_not_assignable_error(tc, right);
            return null;
        }

        if a_e.assign_type != ast.AssignType.Normal {
            // TODO: remove this, when casting between enums and their base type is implemented
            let kind = *(&a_e.assign_type as *ast.BinaryKind);

            let new_rhs = ast.new_binary_expr(
                right.span, kind, a_e.assign_span, left, right
            );

            ast.as_binary_expr(new_rhs).free_left = false;
            new_rhs.ty = right.ty;
            right = new_rhs;
        }

        a_e.left = left;
        a_e.right = right;
        e.ty = right.ty;
        return e;
    }

    // EXPR_UNARY
    if ast.is_unary_expr(e) {
        let u_e = ast.as_unary_expr(e);

        let lookup_data = data.copy();
        lookup_data.kind = LookupKind.Both; // needed for method pointers

        let expr = check_expr_expect(tc, u_e.right, expected, &lookup_data);
        if expr == null {
            return null;
        }

        let result_ty = check_unary_expr(tc, u_e.kind, expr, e.span, &lookup_data);
        if result_ty == null {
            return null;
        }

        u_e.right = expr;
        e.ty = result_ty;
        return e;
    }

    // EXPR_NEW
    if ast.is_new_expr(e) {
        let n_e = ast.as_new_expr(e);
        let inner = check_expr(tc, n_e.expr);

        if inner == null {
            return null;
        }

        let ptr = ty.new_ptr(1, inner.ty);
        push_tmp_ty(tc, ptr);

        n_e.expr = inner;
        e.ty = ptr;
        return e;
    }

    // EXPR_SIZEOF
    if ast.is_sizeof_expr(e) {
        let s_e = ast.as_sizeof_expr(e);

        let actual_ty = lookup_tyid(tc, &s_e.ty);
        if actual_ty == null {
            return null;
        }

        if !ty.is_sized(actual_ty) {
            push_unsized_sizeof_error(tc, actual_ty, e.span);
            return null;
        }

        s_e.actual_ty = actual_ty;
        e.ty = get_global_type(tc, 3, "i32");
        return e;
    }

    // EXPR_AS
    if ast.is_as_expr(e) {
        let a_e = ast.as_as_expr(e);

        let dest_ty = lookup_tyid(tc, &a_e.ty);
        if dest_ty == null {
            return null;
        }

        let expr = check_expr_expect(tc, a_e.expr, dest_ty, data);
        if expr == null {
            return null;
        }

        if !ty.can_be_casted(expr.ty, dest_ty) {
            push_invalid_cast_error(tc, expr.ty, dest_ty, e.span);
            return null;
        }

        a_e.expr = expr;
        e.ty = dest_ty;
        return e;
    }

    // EXPR_CALL
    if ast.is_call_expr(e) {
        let c_e = ast.as_call_expr(e);

        let callee = check_expr(tc, c_e.callee);
        if callee == null {
            return null;
        }

        let f_ty = callee.ty;
        if !ty.is_callable(f_ty) {
            push_not_callable_error(tc, e.span, f_ty);
            return null;
        }

        let func = ty.callable_as_func(f_ty);

        if func.is_method {
            dbg.assert(ast.is_access_expr(callee), "method callee wasn't an access expr");
            let access = ast.as_access_expr(callee);
            let recv_expr = access.left; // receiver should be lhs of the callee access

            let checked_recv = check_expr_expect(tc, recv_expr, func.receiver.ty, data);
            if checked_recv == null {
                return null;
            }

            let expected = func.receiver.ty;

            // a receiver cannot be a pointer to a pointer, so this check is sufficient
            if ty.is_ptr(expected) && !ty.is_ptr(checked_recv.ty) {
                // we allow auto upgrading a non pointer to a simple pointer, nothing else
                expected = ty.as_ptr(expected).inner;
            }

            if !ty.equals(expected, checked_recv.ty) {
                push_wrong_arg_type_error(
                    tc, func.receiver.ty, checked_recv.ty, recv_expr.span
                );
                return null;
            }
        }

        let expected_num_args = func.params.len;
        let actual_num_args = ast.num_args(&c_e.args);
        if expected_num_args != actual_num_args {
            if actual_num_args < expected_num_args {
                push_wrong_num_args_error(tc, expected_num_args, actual_num_args, callee.span);
                return null;
            }

            if actual_num_args > expected_num_args && !func.is_varargs {
                push_wrong_num_args_error(tc, expected_num_args, actual_num_args, callee.span);
                return null;
            }
        }

        for let i = 0; i < actual_num_args; i += 1 {
            let arg = ast.get_arg_at(&c_e.args, i);

            if !func.is_varargs {
                let param = ty.param_at(func, i);

                let checked_arg = check_expr_expect(tc, arg, param.ty, null);
                if checked_arg == null {
                    return null;
                }

                if !ty.equals(param.ty, checked_arg.ty) {
                    push_wrong_arg_type_error(
                        tc, param.ty, checked_arg.ty, checked_arg.span
                    );
                    return null;
                }

                ast.set_arg_at(&c_e.args, i, checked_arg);
            } else {
                let checked_arg = check_expr(tc, arg);
                if checked_arg == null {
                    return null;
                }
                ast.set_arg_at(&c_e.args, i, checked_arg);

            }
        }

        c_e.callee = callee;
        e.ty = func.ret;
        return e;
    }

    // EXPR_INIT
    if ast.is_init_expr(e) {
        let i_e = ast.as_init_expr(e);
        let data = create_lookup_data(LookupKind.Types, null);
        let left = check_expr_expect(tc, i_e.struct_ty, expected, &data);
        if left == null {
            return null;
        }

         if !ty.is_struct(left.ty) {
            push_init_non_struct_error(tc, left.ty, e.span);
            return null;
        }

        // TODO(#76): check names of fields and reorder if necessary

        let struct_ty = ty.as_struct(left.ty);
        let inits = &i_e.inits;

        let expected_num_args = ty.num_fields(struct_ty);
        let actual_num_args = ast.num_inits(inits);
        if expected_num_args != actual_num_args {
            push_wrong_num_args_error(tc, expected_num_args, actual_num_args, e.span);
            return null;
        }

        let i = 0;
        while i < expected_num_args {
            let param = ty.field_at(struct_ty, i);
            let arg = ast.init_expr_at(inits, i);

            let checked_arg = check_expr_expect(tc, arg, param.ty, null);
            if checked_arg == null {
                return null;
            }

            if !ty.equals(param.ty, checked_arg.ty) {
                push_wrong_arg_type_error(tc, param.ty, checked_arg.ty, checked_arg.span);
                return null;
            }

            ast.set_init_expr_at(inits, i, checked_arg);
            i = i + 1;
        }

        // TODO(#54): those names are really confusing
        i_e.struct_ty = left;
        e.ty = left.ty;
        return e;
    }

    return null;
}

def check_binary_expr(
    tc: *TypeChecker,
    kind: ast.BinaryKind,
    op_span: span.Span,
    first: *ty.Type,
    second: *ty.Type,
    span: span.Span
): *ty.Type {
#define RET_INVALID_TYS() push_bin_invalid_types_error(tc, first, second, op_span); \
            return null

    dbg.assert_fmt(
        kind >= ast.BinaryKind.Add && kind <= ast.BinaryKind.RShift,
        "Invalid binary expression: %d\n", kind
    );

    if first == null || second == null {
        push_internal_error(tc, span, "types were null");
        return null;
    }

    if ty.equals(first, second) {
        if kind == ast.BinaryKind.Eq || kind == ast.BinaryKind.NE
            || kind == ast.BinaryKind.ST || kind == ast.BinaryKind.SE
            || kind == ast.BinaryKind.GT || kind == ast.BinaryKind.GE
        {
            if ty.is_bool(first) {
                return first;
            }

            if ty.is_comparable(first) {
                return get_global_type(tc, 4, "bool");
            }

            RET_INVALID_TYS();
        }

        if kind == ast.BinaryKind.LogOr || kind == ast.BinaryKind.LogAnd {
            if ty.is_bool(first) {
                return first;
            }

            RET_INVALID_TYS();
        }

        if kind == ast.BinaryKind.LShift || kind == ast.BinaryKind.RShift {
            if first.is_integer() {
                return first;
            }

            RET_INVALID_TYS();
        }

        // TODO(#58): should we allow float comparisons with '=='?
        //  0.1 == 0.2 == 0.3 is false after all
        //  should we just expose a compare function in the stdlib?

        if first.is_num() {
            // everything except || and && is fine
            return first;
        }

        if ty.is_ptr(first) {
            // pointer subtraction is the only allowed operation
            if kind == ast.BinaryKind.Sub {
                return get_global_type(tc, 3, "i32");
            }

            let text = error.err2str(error.CompileError.BinPtrInvalid);
            push_mk_err(tc, text, op_span);
            return null;
        }

        RET_INVALID_TYS();
    }

    if kind == ast.BinaryKind.Add {
        // both ptr + int and int + ptr are ok
        if ty.is_ptr(first) && second.is_integer() {
            return first;
        }

        if ty.is_ptr(second) && first.is_integer() {
            return second;
        }
    } else if kind == ast.BinaryKind.Sub {
        // only ptr - int is allowed, not the other way
        if ty.is_ptr(first) && second.is_integer() {
            return first;
        }
    }

    RET_INVALID_TYS();
}

def check_unary_expr(
    tc: *TypeChecker,
    kind: ast.UnaryKind,
    expr: *ast.Expr,
    span: span.Span,
    lookup_data: *LookupData
): *ty.Type {
    dbg.assert_fmt(
        kind >= ast.UnaryKind.Ref && kind <= ast.UnaryKind.NegNum,
        "Invalid unary expression: %d\n", kind
    );

    if expr.ty == null {
        push_internal_error(tc, span, "Unary expr type was null");
        return null;
    }

    if kind == ast.UnaryKind.Ref {
        if !ast.is_ident_expr(expr) && !ast.is_access_expr(expr)
            || ast.is_access_expr(expr) && ty.is_enum(ast.as_access_expr(expr).left.ty) {
                let text = error.err2str(error.CompileError.UnaryRefRValue);
                push_mk_err(tc, text, span);
                return null;
            }

        let is_method_ptr = ty.is_func(expr.ty) && ty.as_func(expr.ty).is_method;
        if lookup_data.was_type_decl() && is_method_ptr {
            let new_func_type = ty.as_func(expr.ty).as_normal_function();
            push_tmp_ty(tc, new_func_type);
            return push_tmp_ty(tc, ty.new_ptr(1, new_func_type));
        }

        if is_method_ptr {
            push_method_ptr_from_instance_error(tc, ty.as_func(expr.ty).receiver.ty, span);
            return null;
        }

        if lookup_data.was_type_decl() {
            push_cannot_take_address_of_error(tc, span);
            return null;
        }

        let e_ty: *ty.Type = null;
        if ty.is_ptr(expr.ty) {
            let p_ty = ty.as_ptr(expr.ty);
            e_ty = ty.new_ptr(p_ty.count + 1, p_ty.inner);
        } else {
            e_ty = ty.new_ptr(1, expr.ty);
        }

        push_tmp_ty(tc, e_ty);
        return e_ty;
    }

    if lookup_data.was_type_decl() {
        push_illegal_unary_expr(tc, span);
        return null;
    }

    if kind == ast.UnaryKind.Deref {
        if !ty.is_ptr(expr.ty) {
            let s_ty = ty.to_static_string(expr.ty);
            let text = error.err2str(error.CompileError.UnaryDerefNonPtr, s_ty);
            push_mk_err(tc, text, span);
            return null;
        }

        let e_ty: *ty.Type = null;
        let p_ty = ty.as_ptr(expr.ty);
        if p_ty.count <= 1 {
            e_ty = p_ty.inner;
        } else {
            let ptr = ty.new_ptr(p_ty.count - 1, p_ty.inner);
            push_tmp_ty(tc, ptr);
            e_ty = ptr;
        }

        if !ty.is_sized(e_ty) {
            push_deref_unsized_error(tc, e_ty, span);
            return null;
        }

        return e_ty;
    }

    // TODO(#55): rewrite with function pointers
    if kind == ast.UnaryKind.NegBool {
        if !ty.is_bool(expr.ty) {
            let s_ty = ty.to_static_string(expr.ty);
            let text = error.err2str(error.CompileError.UnaryOpNotDefined, "!", s_ty);
            push_mk_err(tc, text, span);
            return null;
        }

        return expr.ty;
    }

    if kind == ast.UnaryKind.NegNum {
        if !expr.ty.is_num() {
            let s_ty = ty.to_static_string(expr.ty);
            let text = error.err2str(error.CompileError.UnaryOpNotDefined, "-", s_ty);
            push_mk_err(tc, text, span);
            return null;
        }

        return expr.ty;
    }

    return null;
}

def mangle_func_name(tc: *TypeChecker, fd: *func.FuncDef): name.Owned {
    dbg.assert(fd != null, "funcdef was null");

    if fd.is_extern {
        // the names must be owned, so just copy data here
        // there aren't many extern functions anyway
        let len = ident.len(&fd.name);
        return name.make_copied(len, ident.start(&fd.name));
    }

    if fd.is_method {
        let recv_ty_name = &fd.receiver.ty.ident;
        let len = 0;
        let with_receiver = std.l_format_str(
            &len,
            "%.*s.%.*s",
            ident.len(recv_ty_name), ident.start(recv_ty_name),
            ident.len(&fd.name), ident.start(&fd.name)
        );

        let mangled = name.s_mangle(tc.mods.proj_root, len, with_receiver, tc.ctx.mod);
        delete with_receiver;
        return mangled;
    }

    return name.mangle_ident(tc.mods.proj_root, &fd.name, tc.ctx.mod);
}

def mangle_type_name(tc: *TypeChecker, i: *ident.Ident): name.Owned {
    dbg.assert(i != null, "ident was null");
    return name.mangle_ident(tc.mods.proj_root, i, tc.ctx.mod);
}

def free_tc(tc: *TypeChecker): void {
    delete tc.sorted_mods;

    let i = 0;
    while i < tc.errors.len {
        free_err(get_err(tc, i));
        i = i + 1;
    }
    tc.errors.free();

    i = 0;
    while i < tc.requests.len {
        free_wait_map(tc.requests.get_ptr(i) as *WaitingRequestMap);
        i = i + 1;
    }
    tc.requests.free();

    i = 0;
    while i < tc.contexts.len {
        free_ctx(get_ctx(tc, i));
        i = i + 1;
    }
    tc.contexts.free();

    scope.free_s(&tc.global_values);
}

def (tc: *TypeChecker) ty_to_string(t: *ty.Type, out: *string): bool {
    return ty.to_string_mangled(t, !t.is_declared_in(tc.ctx.mod), out);
}

def push_internal_error(tc: *TypeChecker, span: span.Span, text: string): void {
    let text = error.err2str(error.CompileError.Internal, text);
    push_mk_err(tc, text, span);
}

def push_ident_error(tc: *TypeChecker, code: error.CompileError, i: *ident.Ident): void {
    let len = ident.len(i);
    let text = error.err2str(code, len, ident.start(i));

    push_mk_err(tc, text, i.span);
}

def push_incomplete_ty_error(tc: *TypeChecker, name: *ident.Ident) {
    push_ident_error(tc, error.CompileError.IncompleteType, name);
}

def push_duplicate_def_error(tc: *TypeChecker, name: *ident.Ident) {
    push_ident_error(tc, error.CompileError.DuplicateDefintion, name);
}

def push_access_private_symbol_error(tc: *TypeChecker, name: *ident.Ident, from: *scope.Scope) {
    let scope_name = from.name();
    let text = error.err2str(
        error.CompileError.AccessingPrivateSymbol,
        name.len(), name.start(),
        scope_name.len, scope_name.data
    );

    push_mk_err(tc, text, name.span);
}

def push_not_defined_error(tc: *TypeChecker, name: *ident.Ident, kind_s: string, from: *scope.Scope) {
    let len = ident.len(name);
    let scope_name = from.name();
    let text = error.err2str(
        error.CompileError.NotDefined,
        kind_s,
        len, ident.start(name),
        scope_name.len, scope_name.data
    );

    push_mk_err(tc, text, name.span);
}

def push_not_accessible_with_error(tc: *TypeChecker, e: *ast.Expr) {
    let ty_s = ty.to_static_string(e.ty);
    let error = error.err2str(error.CompileError.NotAccessibleWithOp, ty_s, ".");

    push_mk_err(tc, error, e.span);
}

def push_not_callable_error(tc: *TypeChecker, span: span.Span, actual_ty: *ty.Type): void {
    let text = error.err2str(error.CompileError.CallingNonFunction, ty.to_static_string(actual_ty));
    push_mk_err(tc, text, span);
}

def push_wrong_num_args_error(tc: *TypeChecker, expected: i32, actual: i32, span: span.Span) {
    let text = error.err2str(error.CompileError.WrongNumberOfArgs, expected, actual);
    push_mk_err(tc, text, span);
}

def push_invalid_expr_error(tc: *TypeChecker, e: *ast.Expr) {
    let text = error.err2str(error.CompileError.InvalidExpression);
    push_mk_err(tc, text, e.span);
}

def push_receiver_different_module_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.ReceiverFromOtherMod);
    push_mk_err(tc, text, span);
}

def push_cannot_take_address_of_error(tc: *TypeChecker, span: span.Span): void {
    let text = error.err2str(error.CompileError.CannotTakeAddrOf);
    push_mk_err(tc, text, span);
}

def push_illegal_unary_expr(tc: *TypeChecker, span: span.Span): void {
    let text = error.err2str(error.CompileError.IllegalExprForUnary);
    push_mk_err(tc, text, span);
}

def push_duplicate_enum_value_error(tc: *TypeChecker, e: *ty.Enum, value_name: *ident.Ident) {
    let len = ident.len(value_name);
    let text = error.err2str(
        error.CompileError.DuplicateEnumValue,
        len, ident.start(value_name),
        e.super.mangled_name.len, e.super.mangled_name.data
    );
    push_mk_err(tc, text, value_name.span);
}

def push_invalid_enum_start_value_error(tc: *TypeChecker, e: *ty.Enum, start_value: *ast.Expr) {
    let s_start_ty = "";
    let free_s_start_ty = tc.ty_to_string(start_value.ty, &s_start_ty);

    let text = error.err2str(
        error.CompileError.InvalidEnumStartValue,
        s_start_ty,
        e.super.mangled_name.len, e.super.mangled_name.data
    );

    if free_s_start_ty {
        delete s_start_ty;
    }

    push_mk_err(tc, text, start_value.span);
}

def push_bin_invalid_types_error(
    tc: *TypeChecker,
    first: *ty.Type,
    second: *ty.Type,
    span: span.Span
): void {
    let s_first = "";
    let free_s_first = tc.ty_to_string(first, &s_first);
    let s_second = "";
    let free_s_second = tc.ty_to_string(second, &s_second);

    let text = error.err2str(error.CompileError.BinInvalidTypes, s_first, s_second);

    if free_s_first {
        delete s_first;
    }

    if free_s_second {
        delete s_second;
    }

    push_mk_err(tc, text, span);
}

def push_wrong_arg_type_error(
    tc: *TypeChecker,
    expected: *ty.Type,
    actual: *ty.Type,
    span: span.Span
): void {
    push_wrong_type_error(tc, error.CompileError.WrongArgType, expected, actual, span);
}

def push_wrong_let_type_error(
    tc: *TypeChecker,
    expected: *ty.Type,
    actual: *ty.Type,
    span: span.Span
): void {
    push_wrong_type_error(tc, error.CompileError.LetDifferentTypes, expected, actual, span);
}

def push_wrong_type_error(
    tc: *TypeChecker,
    err_kind: error.CompileError,
    expected: *ty.Type,
    actual: *ty.Type,
    span: span.Span
): void {
    let expected_ty_s: string = null;
    let free_expected_ty_s = tc.ty_to_string(expected, &expected_ty_s);
    let actual_ty_s: string = null;
    let free_actual_ty_s = tc.ty_to_string(actual, &actual_ty_s);

    if actual_ty_s == null {
        actual_ty_s = "unknown type";
        free_actual_ty_s = false;
    }

    if expected_ty_s == null {
        expected_ty_s = "unknown type";
        free_expected_ty_s = false;
    }

    let text = error.err2str(err_kind, expected_ty_s, actual_ty_s);
    if free_expected_ty_s {
        delete expected_ty_s;
    }
    if free_actual_ty_s {
        delete actual_ty_s;
    }

    push_mk_err(tc, text, span);
}


def push_wrong_return_type_error(tc: *TypeChecker, expr: *ast.Expr) {
    let ret_ty_s = "";
    let free_ret_ty_s = tc.ty_to_string(tc.ctx.current_func.ret, &ret_ty_s);
    let ty_s = "";
    let free_ty_s = tc.ty_to_string(expr.ty, &ty_s);

    let text = error.err2str(error.CompileError.WrongReturnType, ret_ty_s, ty_s);
    if free_ty_s {
        delete ty_s;
    }
    if free_ret_ty_s {
        delete ret_ty_s;
    }

    push_mk_err(tc, text, expr.span);
}

def push_missing_return_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.MissingReturn);
    push_mk_err(tc, text, span);
}

def push_init_non_struct_error(tc: *TypeChecker, actual_ty: *ty.Type, span: span.Span) {
    let ty_s = ty.to_static_string(actual_ty);
    let text = error.err2str(error.CompileError.InitNonStructType, ty_s);
    push_mk_err(tc, text, span);
}

def push_could_not_infer_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.CouldNotInferType);
    push_mk_err(tc, text, span);
}

def push_non_const_expr_error(tc: *TypeChecker, span: span.Span) {
    let text = error.err2str(error.CompileError.NonConstExpressionInConstContext);
    push_mk_err(tc, text, span);
}

def push_outside_loop_error(tc: *TypeChecker, span: span.Span, keyword: string) {
    let text = error.err2str(error.CompileError.BreakOrContinueOutsideLoop, keyword);
    push_mk_err(tc, text, span);
}

def push_invalid_cast_error(
    tc: *TypeChecker,
    src: *ty.Type,
    dest: *ty.Type,
    span: span.Span
): void {
    let src_ty_s = "";
    let free_src_ty_s = tc.ty_to_string(src, &src_ty_s);
    let dest_ty_s = "";
    let free_dest_ty_s = tc.ty_to_string(dest, &dest_ty_s);

    let text = error.err2str(error.CompileError.InvalidCast, src_ty_s, dest_ty_s);
    if free_dest_ty_s {
        delete dest_ty_s;
    }
    if free_src_ty_s {
        delete src_ty_s;
    }

    push_mk_err(tc, text, span);
}

def push_simple_error(tc: *TypeChecker, kind: error.CompileError, t: *ty.Type, s: span.Span) {
    let ty_s = "";
    let free_ty_s = tc.ty_to_string(t, &ty_s);
    let text = error.err2str(kind, ty_s);
    if free_ty_s {
        delete ty_s;
    }
    push_mk_err(tc, text, s);
}

def push_expr_type_error(tc: *TypeChecker, kind: error.CompileError, e: *ast.Expr) {
    push_simple_error(tc, kind, e.ty, e.span);
}

def push_unsized_field_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.UnsizedStructField, t, s);
}

def push_unsized_param_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.UnsizedParameter, t, s);
}

def push_unsized_sizeof_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.UnsizedSizeof, t, s);
}

def push_deref_unsized_error(tc: *TypeChecker, t: *ty.Type, s: span.Span) {
    push_simple_error(tc, error.CompileError.DerefOfUnsizedType, t, s);
}

def push_primitive_receiver_type_error(tc: *TypeChecker, recv: *ty.Type, span: span.Span) {
    push_simple_error(tc, error.CompileError.PrimitiveReceiverType, recv, span);
}

def push_method_ptr_from_instance_error(tc: *TypeChecker, instanceof: *ty.Type, span: span.Span) {
    // TODO: implement proper hint system
    // TODO: use import alias for mangling
    push_simple_error(tc, error.CompileError.MethodPtrFromInstance, instanceof, span);
}

def push_invalid_condition_error(tc: *TypeChecker, e: *ast.Expr) {
    push_expr_type_error(tc, error.CompileError.InvalidTypeInCondition, e);
}

def push_type_not_assignable_error(tc: *TypeChecker, e: *ast.Expr) {
    push_expr_type_error(tc, error.CompileError.TypeNotAssignable, e);
}

def push_expr_not_assignable_error(tc: *TypeChecker, e: *ast.Expr) {
    push_expr_type_error(tc, error.CompileError.ExprNotAssignable, e);
}

def push_delete_non_ptr_error(tc: *TypeChecker, e: *ast.Expr) {
    let ty_s = "";
    let free_ty_s = tc.ty_to_string(e.ty, &ty_s);
    let text = error.err2str(error.CompileError.DeleteNonPtr, ty_s);
    if free_ty_s {
        delete ty_s;
    }
    push_mk_err(tc, text, e.span);
}
