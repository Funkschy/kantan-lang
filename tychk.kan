import "ast";
import "ptrvec";
import "span";
import "mod";
import "map";
import "scope";
import "path";

// TODO: only temp solution
import "std";
import "io";
import "ident";

extern def isort(arr: *i32, len: i32): *i32;

type Ctx struct {
    mod: *mod.Module,
    import_map: map.Map, // Map of *PathBuf
    scopes: scope.ScopeStack
}

def empty_ctx(): Ctx {
    return Ctx { mod: null, import_map: map.create(), scopes: scope.empty_stack() };
}

def get_abs_import_path(
    current: *mod.Module,
    imp: *ast.ImportStmt,
    span_interner: *span.SpanInterner,
    dest: *path.PathBuf
): i32 {
    let len = span.get(span_interner, imp.mod.ident_span).len;
    let imp_path = path.create(imp.mod.ident, len);
    let dir = path.parent(&current.path);

    return path.merge_abs_rel_suffix(&dir, &imp_path, ".kan", dest);
}

def create_ctx(mods: *mod.Map, mod: *mod.Module, span_interner: *span.SpanInterner): Ctx {
    let num_imports = mod.num_imports(mod);
    let import_map = map.with_cap(num_imports);

    let i = 0;
    while i < num_imports {
        let imp = mod.get_import_at(mod, i);
        let key = map.key_from_ident(span_interner, &imp.mod);

        let abs = path.buf_from(path.empty());
        let error = get_abs_import_path(mod, imp, span_interner, &abs);

        if error != 0 {
            // TODO: file does not exist error
            let p = path.parent(&mod.path);
            let mod_s = path.to_string(&p);
            let imp_s = ident.to_string(&imp.mod, span_interner);

            io.printf("%s/%s.kan: %s\n", mod_s, imp_s, std.strerror(error));

            delete imp_s;
            delete mod_s;

            std.abort();
        }

        let imported_mod = mod.get_mod_by_path(mods, &abs.inner);

        if imported_mod == null {
            let s = path.to_string(&abs.inner);
            io.printf("ERROR: %s is not being compiled\n", s);
            delete s;

            // TODO: module does not exist error
            path.free_pb(&abs);
            std.abort();
        }
        path.free_pb(&abs);

        map.insert(&import_map, key, imported_mod as *void);
        i = i + 1;
    }

    return Ctx {
        mod: mod,
        import_map: import_map
    };
}

def free_ctx(ctx: *Ctx): void {
    map.free_m(&ctx.import_map);
}

type TypeChecker struct {
    span_interner: *span.SpanInterner,
    mods: *mod.Map,
    sorted_mods: *i32,
    ctx: Ctx
}

def create(span_interner: *span.SpanInterner, mods: *mod.Map): TypeChecker {
    return TypeChecker {
        span_interner: span_interner,
        mods: mods,
        sorted_mods: sorted_mods(mods),
        ctx: empty_ctx()
    };
}

def sorted_mods(mods: *mod.Map): *i32 {
    let num_mods = mod.num_mods(mods);
    let import_nums = std.malloc(num_mods * sizeof i32) as *i32;

    let i = 0;
    while i < num_mods {
        let m = mod.get_mod(mods, i);
        *(import_nums + i) = mod.num_imports(m);
        i = i + 1;
    }

    let sorted_mods = isort(import_nums, num_mods);
    delete import_nums;

    return sorted_mods;
}

def check(tc: *TypeChecker): void {
    let i = 0;
    while i < mod.num_mods(tc.mods) {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        check_mod(tc, m);

        i = i + 1;
    }
}

def check_mod(tc: *TypeChecker, mod: *mod.Module): void {
     // free previous context
    free_ctx(&tc.ctx);
    tc.ctx = create_ctx(tc.mods, mod, tc.span_interner);

    let s = path.to_string(&mod.path);
    io.printf("%s %d\n", s, mod.num_imports(mod));
    delete s;
}

def check_expr(tc: *TypeChecker, e: *ast.Expr): *ast.Expr {
    return e;
}

def free_tc(tc: *TypeChecker): void {
    free_ctx(&tc.ctx);
    delete tc.sorted_mods;
}
