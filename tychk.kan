#include "ty_types.h"
#include "std.h"

import "ast";
import "ptrvec";
import "vec";
import "span";
import "mod";
import "map";
import "scope";
import "path";
import "ident";
import "record";
import "func";

import "std";
// TODO: only temp solution
import "io";

extern def isort(arr: *i32, len: i32): *i32;

#define WAITING_TYPE       1
#define WAITING_TYPE_PTR   2
#define WAITING_FUNC_DEF   3

#define OFFSET_RETURN_TYPE -1

// Used as some kind of callback
// When we resolve statements it may happen, that the statement uses type we
// have not yet resolved. In this case a waiting request will be placed for the
// correspoding type in the correspoding module.
// After a type has been resolved, tychk will check if there are pending requests
// for this type and resolve them accordingly.
type WaitingRequest struct {
    kind: i32,
    offset: i32, // e.g. index of field in Struct type
    to_fill: *ty.Type,
    to_fill_mod: *mod.Module,
    waiting_for: ident.Ident,
    waiting_for_mod: *mod.Module
}

def create_waiting_request(
    tc: *TypeChecker,
    kind: i32,
    to_fill: *ty.Type,
    to_fill_mod: *mod.Module,
    waiting_for: ident.Ident,
    waiting_for_mod: *mod.Module,
    offset: i32
): WaitingRequest {
    // it is easier to pass things like mymod.Mytype to this function and just
    // remove the 'mymod.' here instead of on the calling site
    patch_waiting_for(tc, &waiting_for, waiting_for_mod);

    return WaitingRequest {
        kind: kind,
        offset: offset,
        to_fill: to_fill,
        to_fill_mod: to_fill_mod,
        waiting_for: waiting_for,
        waiting_for_mod: waiting_for_mod
    };
}

def patch_waiting_for(
    tc: *TypeChecker,
    waiting_for: *ident.Ident,
    waiting_for_mod: *mod.Module
): void {
    // this means the type is in the same module, so the ident should not have
    // a module name at the start
    if waiting_for_mod == null {
        return;
    }

    let len = ident.len(waiting_for, tc.span_interner);
    let dot_index = ident.index_of(waiting_for, len, '.');
    if dot_index > 0 {
        let ident_mod = get_mod_by_alias(&tc.ctx, dot_index, waiting_for.ident);
        if ident_mod != waiting_for_mod {
            // not recoverable and probably unreachable
            std.abort();
        }

        // remove the module path: 'mymod.test' => 'test'
        let span = span.get(tc.span_interner, waiting_for.ident_span);
        let start = span.start + dot_index + 1;
        let end = span.start + span.len;

        let new_span = span.create(tc.span_interner, start, end, span.ctx);
        let new_ident = waiting_for.ident + dot_index + 1;

        *waiting_for = ident.from_str(new_span, new_ident);
    }
}

def req_waiting_for_ident(r: *WaitingRequest): *ident.Ident {
    return &r.waiting_for;
}

type WaitingRequestMap struct {
    init_flag: i32, // used to check if this is zeroed memory
    requests: vec.Vec, // Vec<Vec<WaitingRequest>>
    request_map: map.Map // Map<Type Ident, index into requests>
}

def create_waiting_request_map(): WaitingRequestMap {
    let map = WaitingRequestMap {
        init_flag: 1,
        requests: vec.create(sizeof vec.Vec),
        request_map: map.create()
    };

    return map;
}

def add_request(wrm: *WaitingRequestMap, si: *span.SpanInterner, request: WaitingRequest): void {
    let requests: *vec.Vec = null;

    let ident = req_waiting_for_ident(&request);
    // ------
        let s = ident.to_string(ident, si);
        let kind_s = "struct";
        if request.kind == WAITING_TYPE_PTR {
            kind_s = "ptr";
        } else if request.kind == WAITING_FUNC_DEF {
            kind_s = "func";
        }
        io.printf("DBG: >>> Adding %s request for '%s'\n", kind_s, s);
        delete s;
    // ------

    let key = map.key_from_ident(si, ident);
    let request_idx = map.get(&wrm.request_map, key);
    let idx = -1;

    if std.ptr_to_int(request_idx) == 0 {
        // create new vector
        idx = wrm.requests.len;
        let v = vec.create(sizeof WaitingRequest);
        vec.push(&wrm.requests, &v as *void);

        // push its idx into the map
        request_idx = std.int_to_ptr(idx);
        // add one, to be able to tell null apart from 0
        map.insert(&wrm.request_map, key, request_idx + 1);
    } else {
        idx = std.ptr_to_int(request_idx) - 1;
    }

    requests = vec.get_ptr(&wrm.requests, idx) as *vec.Vec;
    vec.push(requests, &request as *void);
}

def get_waiting(wrm: *WaitingRequestMap, si: *span.SpanInterner, ident: *ident.Ident): *vec.Vec {
    let key = map.key_from_ident(si, ident);
    let request_idx = map.get_and_remove(&wrm.request_map, key);

    if request_idx == null {
        return null;
    }

    let idx = std.ptr_to_int(request_idx) - 1;
    return vec.get_ptr(&wrm.requests, idx) as *vec.Vec;
}

def free_wait_map(wrm: *WaitingRequestMap): void {
    let i = 0;
    while i < wrm.requests.len {
        let v = vec.get_ptr(&wrm.requests, i) as *vec.Vec;
        vec.free_v(v);
        i = i + 1;
    }

    vec.free_v(&wrm.requests);
    map.free_m(&wrm.request_map);
}

type TypeError struct {
    text: string,
    span: span.Span
}

def err(tc: *TypeChecker, text: string, span: span.Span): TypeError {
    return TypeError { text: text, span: span };
}

def free_err(err: *TypeError): void {
    delete err.text;
}

type Ctx struct {
    mod: *mod.Module,
    imports: map.Map, // <string, *mod.Module>
    scopes: scope.ScopeStack
}

def empty_ctx(): Ctx {
    return Ctx {
        mod: null,
        imports: map.create(),
        scopes: scope.empty_stack()
    };
}

def create_ctx(mod: *mod.Module, si: *span.SpanInterner, global: *scope.Scope): Ctx {
    let scopes = scope.create_stack(si);
    scope.push_scope(&scopes, global);
    scope.push_scope(&scopes, &mod.ty.scope);

    return Ctx {
        mod: mod,
        imports: map.create(),
        scopes: scopes
    };
}

def free_ctx(ctx: *Ctx): void {
    scope.free_stack(&ctx.scopes);
    map.free_m(&ctx.imports);
}

def get_mod_by_alias(ctx: *Ctx, alias_len: i32, alias: string): *mod.Module {
    return map.get(&ctx.imports, map.create_key(alias_len, alias)) as *mod.Module;
}

type TypeChecker struct {
    span_interner: *span.SpanInterner,
    mods: *mod.Map,
    sorted_mods: *i32,
    // types that get created during type checking and need to be freed afterwards
    temp_types: ptrvec.Vec,
    ctx: Ctx,
    globals: scope.Scope,
    errors: vec.Vec, // <TypeError>
    requests: vec.Vec // Vec<WaitingRequestMap> indexed by mod idx
}

def create(span_interner: *span.SpanInterner, mods: *mod.Map): TypeChecker {
    let tc = TypeChecker {
        span_interner: span_interner,
        mods: mods,
        sorted_mods: sorted_mods(mods, span_interner),
        temp_types: ptrvec.with_cap(256),
        ctx: empty_ctx(),
        globals: scope.create(),
        errors: vec.create(sizeof TypeError),
        requests: vec.with_cap(sizeof WaitingRequestMap, mod.num_mods(mods))
    };
    vec.init_zero(&tc.requests);

    tc.globals = create_global_scope(&tc);
    return tc;
}

def wait_for(tc: *TypeChecker, req: WaitingRequest): void {
    let idx = req.waiting_for_mod.idx;
    let map = vec.get_ptr(&tc.requests, idx) as *WaitingRequestMap;

    if map.init_flag == 0 {
        *map = create_waiting_request_map();
    }

    add_request(map, tc.span_interner, req);
}

def get_waiting_map(tc: *TypeChecker, mod: *mod.Module): *WaitingRequestMap {
    return vec.get_ptr(&tc.requests, mod.idx) as *WaitingRequestMap;
}

def create_global_scope(tc: *TypeChecker): scope.Scope {
    // TODO: this should be defined in builtin.kan
    let scope = scope.create();
    scope.s_bind_in(&scope, 3, "i32", push_tmp_ty(tc, ty.new_i32()));
    scope.s_bind_in(&scope, 6, "string", push_tmp_ty(tc, ty.new_string()));
    return scope;
}

def num_errs(tc: *TypeChecker): i32 {
    return tc.errors.len;
}

def push_err(tc: *TypeChecker, error: TypeError): void {
    vec.push(&tc.errors, &error as *void);
}

def push_mk_err(tc: *TypeChecker, text: string, span: span.Span): void {
    let error = err(tc, text, span);
    vec.push(&tc.errors, &error as *void);
}

def get_err(tc: *TypeChecker, i: i32): *TypeError {
    return vec.get_ptr(&tc.errors, i) as *TypeError;
}

def add_import_alias(tc: *TypeChecker, ident: *ident.Ident, mod: *mod.Module): void {
    map.insert(&tc.ctx.imports, map.key_from_ident(tc.span_interner, ident), mod as *void);
}

// sorts the mods after the number of imports inside
def sorted_mods(mods: *mod.Map, si: *span.SpanInterner): *i32 {
    let num_mods = mod.num_mods(mods);
    let import_nums = std.malloc(num_mods * sizeof i32) as *i32;

    let i = 0;
    while i < num_mods {
        let m = mod.get_mod(mods, i);
        *(import_nums + i) = mod.num_imports(m);
        i = i + 1;
    }

    let sorted_mods = isort(import_nums, num_mods);
    delete import_nums;

    return sorted_mods;
}

def set_mod_type(tc: *TypeChecker, m: *mod.Module): bool {
    let ty = ty.new_mod() as *ty.Mod;
    m.ty = ty;

    // free previous context
    tc.ctx = create_ctx(m, tc.span_interner, &tc.globals);
    let error = false;

    let i = 0;
    let n = mod.num_imports(m);
    while i < n {
        let i_s = mod.get_import_at(m, i);

        let alias: ident.Ident = ident.empty();
        let ty: *ty.Mod = null;

        if check_import(tc, i_s, &alias, &ty) {
            bind(tc, &alias, ty as *ty.Type);
        } else {
            error = true;
        }

        i = i + 1;
    }

    i = 0;
    n = mod.num_structs(m);
    while i < n {
        let sd = &mod.get_struct_at(m, i).decl;
        let ty = check_struct_decl(tc, sd);

        if ty != null {
            bind(tc, &sd.name, ty as *ty.Type);
        } else {
            error = true;
        }

        i = i + 1;
    }

    i = 0;
    n = mod.num_functions(m);
    while i < n {
        let fd = &mod.get_function_at(m, i).decl;
        let ty = check_func_decl(tc, fd);

        if ty != null {
            bind(tc, &fd.name, ty as *ty.Type);
        } else {
            error = true;
        }

        i = i + 1;
    }

    return error;
}

def lookup(tc: *TypeChecker, ident: *ident.Ident): *ty.Type {
    return m_lookup_local(tc, ident, null);
}

// if the ident has a '.' inside it like 'mymod.test', out_mod will be set to a
// reference to the correspoding module (mymod) this will happen, even if out_mod
// does not contain the actual type (test)
def m_lookup_local(tc: *TypeChecker, ident: *ident.Ident, out_mod: **mod.Module): *ty.Type {
    let len = ident.len(ident, tc.span_interner);
    let dot_index = ident.index_of(ident, len, '.');
    if dot_index < 0 {
        // same module
        return scope.lookup(&tc.ctx.scopes, ident);
    }

    let mod = get_mod_by_alias(&tc.ctx, dot_index, ident.ident);
    if mod == null {
        io.printf("DBG DEBUG %.*s mod not found\n", len, ident.ident);
        return null;
    }

    if out_mod != null {
        *out_mod= mod;
    }

    let ty = mod.s_lookup(mod, len - dot_index - 1, ident.ident + dot_index + 1);
    if ty == null {
        io.printf("DBG DEBUG %.*s type not found\n", len, ident.ident);
        return null;
    }

    return ty;
}

def check(tc: *TypeChecker): void {
    let i = 0;
    let n = mod.num_mods(tc.mods);
    // TODO: dont check stdlib if not needed
    while i < n {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        check_mod(tc, m);

        i = i + 1;
    }

    i = 0;
    while i < n {
        let idx = *(tc.sorted_mods + i);
        let m = mod.get_mod(tc.mods, idx);

        let wrm = get_waiting_map(tc, m);
        // TODO: iterate over idents. There should be 0 left, else error

        i = i + 1;
    }
}

def init_mod(tc: *TypeChecker, mod: *mod.Module): bool {
    // this module has already been visited
    if mod.ty != null {
        return false;
    }

    io.printf("Checking %.*s\n", mod.path.len, mod.path.inner);

    free_ctx(&tc.ctx);
    return set_mod_type(tc, mod);
}

def check_mod(tc: *TypeChecker, mod: *mod.Module): *ty.Mod {
    let error = init_mod(tc, mod);

    if error {
        // don't resolve in error case, module is poisoned
        return mod.ty;
    }

    let i = 0;
    while i < mod.num_stmts(mod) {
        let result = check_stmt(tc, mod.get_stmt_at(mod, i));

        if result != null {
            mod.set_stmt_at(mod, i, result);
        }

        i = i + 1;
    }

    return mod.ty;
}

def fill_func_def(
    tc: *TypeChecker,
    f_decl: *func.FuncDef,
    f_ty: *ty.Func
): void {
    let name = ident.to_string(&f_ty.name, tc.span_interner);
    io.printf("DBG: Defining '%s'\n", name);
    delete name;

    let error = false;
    let waiting = true;

    let ret_ty_ident = f_decl.ret_ty.ident;
    let ret_ty_mod: *mod.Module = null;
    let ret_ty = m_lookup_local(tc, &ret_ty_ident, &ret_ty_mod);

    if ret_ty == null {
        func_wait_for_type(tc, ret_ty_mod, ret_ty_ident, OFFSET_RETURN_TYPE, f_ty);
        waiting = true;
    }

    let num_params = func.num_params(f_decl);
    let params = vec.with_cap(sizeof ty.Param, num_params);

    let i = 0;
    while i < num_params {
        let p = func.get_param_ptr(f_decl, i);

        // TODO: handle varargs
        if !param.is_varargs(p) {
            let p_mod: *mod.Module = null;
            let p_ty_name = p.ty.ident;
            let p_ty = m_lookup_local(tc, &p_ty_name, &p_mod);

            if p_ty == null {
                func_wait_for_type(tc, p_mod, p_ty_name, i, f_ty);
                waiting = true;
            }

            let f_param = ty.create_param(p.name, p_ty);
            vec.push(&params, &f_param as *void);
        }

        i = i + 1;
    }

    if !error {
        f_ty.params = params;
        f_ty.ret = ret_ty;
    } else {
        vec.free_v(&params);
    }
}

def func_wait_for_type(
    tc: *TypeChecker,
    waiting_for_mod: *mod.Module, // 'waiting_for' will be defined here
    waiting_for: ident.Ident,
    offset: i32,
    to_fill: *ty.Func
): void {
    wait_for_type(
        tc,
        WAITING_FUNC_DEF,
        waiting_for_mod,
        waiting_for,
        offset,
        to_fill as *ty.Type
    );
}

def push_tmp_ty(tc: *TypeChecker, ty: *ty.Type): *ty.Type {
    ptrvec.push_ptr(&tc.temp_types, ty as *void);
    return ty;
}

def bind(tc: *TypeChecker, ident: *ident.Ident, ty: *ty.Type): void {
    scope.bind(&tc.ctx.scopes, ident, ty);
}

def fill_struct_fields(
    tc: *TypeChecker,
    s_decl: *record.StructDecl,
    s_ty: *ty.Struct
): void {
    // TODO: handle self fields
    ty.tychk_touch(s_ty as *ty.Type);

    let s = ident.to_string(&s_decl.name, tc.span_interner);
    io.printf("----\nDBG: resolving %s\n", s);
    delete s;

    let error = false;
    let waiting = false;

    let nf = record.num_fields(s_decl);
    let i = 0;
    while i < nf {
        let f = record.empty_field();
        if !record.field_at(s_decl, i, &f) {
            push_internal_error(tc, s_decl.name.ident_span, "could not get field");
            return;
        }

        let s = tyid.to_string(&f.ty, tc.span_interner);
        io.printf("DBG: field_ty %s\n", s);
        delete s;

        let mod: *mod.Module = null;
        let field_ty = m_lookup_local(tc, &f.ty.ident, &mod);

        // pointers are ok, because their size is known
        let is_ptr = tyid.is_ptr(&f.ty);

        if field_ty != null {
            if ty.is_initialized(field_ty) {
                if is_ptr {
                    field_ty = ty.new_ptr(f.ty.pointer_count, field_ty);
                    push_tmp_ty(tc, field_ty);
                }

                ty.push_field(s_ty, f.ident, field_ty);
            } else {
                if ty.is_struct(field_ty) {
                    wait_for_struct_field(tc, mod, f.ty.ident, &f, i, s_ty);
                    if !is_ptr {
                        waiting = true;
                    }
                } else {
                    push_internal_error(tc, f.ident.ident_span, "reached unreachable code");
                    return;
                }
            }
        } else {
            wait_for_struct_field(tc, mod, f.ty.ident, &f, i, s_ty);
            if !is_ptr {
                waiting = true;
            }
        }

        i = i + 1;
    }

    let s = ident.to_string(&s_decl.name, tc.span_interner);

    if !error && !waiting {
        let ty = s_ty as *ty.Type;
        ty.fill_width_align(ty);

        io.printf("DBG: %s has a width of %d, align of %d\n", s, ty.width, ty.align);
        delete s;

        update_all_waiting(tc, tc.ctx.mod, ty, &s_ty.name);
        return;
    }

    delete s;
}

def wait_for_type(
    tc: *TypeChecker,
    kind: i32,
    waiting_for_mod: *mod.Module, // 'waiting_for' will be defined here
    waiting_for: ident.Ident,
    offset: i32,
    to_fill: *ty.Type
) : void {
    // current module
    if waiting_for_mod == null {
        waiting_for_mod = tc.ctx.mod;
    }

    let request = create_waiting_request(
        tc,
        kind,
        to_fill,
        tc.ctx.mod,
        waiting_for,
        waiting_for_mod,
        offset
    );

    wait_for(tc, request);
}

def wait_for_struct_field(
    tc: *TypeChecker,
    mod: *mod.Module,
    waiting_for: ident.Ident,
    field: *record.Field,
    offset: i32,
    s_ty: *ty.Struct
): void {
    // current module
    if mod == null {
        mod = tc.ctx.mod;
    }

    let field_ty: *ty.Type = null;
    let kind = WAITING_TYPE;

    if tyid.is_ptr(&field.ty) {
        kind = WAITING_TYPE_PTR;
        field_ty = ty.new_ptr(field.ty.pointer_count, null);
        push_tmp_ty(tc, field_ty);
    }
    ty.push_field(s_ty, field.ident, field_ty);

    let request = create_waiting_request(
        tc,
        kind,
        s_ty as *ty.Type,
        tc.ctx.mod,
        waiting_for,
        mod,
        offset
    );

    wait_for(tc, request);
}

def update_all_waiting(
    tc: *TypeChecker,
    mod: *mod.Module,
    resolved_ty: *ty.Type,
    ident: *ident.Ident
): void {
    // only execute this once
    if !ty.was_touched_by_tychk(resolved_ty) {
        return;
    }
    ty.tychk_untouch(resolved_ty);

    let waiting_map = get_waiting_map(tc, mod);
    let waiting = get_waiting(waiting_map, tc.span_interner, ident);

    if waiting == null {
        let name = ident.to_string(ident, tc.span_interner);
        io.printf(
            "DBG: no other types waiting for %s width: %d, align: %d\n",
            name, resolved_ty.width, resolved_ty.align
        );
        delete name;
        return;
    }

    let name = ident.to_string(ident, tc.span_interner);
    io.printf("DBG: %d types waiting for %s\n", waiting.len, name);
    delete name;

    let i = 0;
    while i < waiting.len {
        let req = vec.get_ptr(waiting, i) as *WaitingRequest;
        update_waiting(tc, req, resolved_ty);

        i = i + 1;
    }

    let s = ident.to_string(ident, tc.span_interner);
    io.printf("DBG: ---- %s width: %d, align: %d\n", s, resolved_ty.width, resolved_ty.align);
    delete s;
}

def update_waiting(tc: *TypeChecker, req: *WaitingRequest, resolved_ty: *ty.Type): void {
    let waiting_ty = req.to_fill;
    let waiting_mod = req.to_fill_mod;

    if req.kind == WAITING_TYPE || req.kind == WAITING_TYPE_PTR {
        let waiting_s_ty = ty.as_struct(waiting_ty);
        let waiting_ident = &waiting_s_ty.name;

        // ----- DBG -----
        let resolved_name: string = null;
        if ty.is_struct(resolved_ty) {
            resolved_name = ident.to_string(&ty.as_struct(resolved_ty).name, tc.span_interner);
        } else {
            resolved_name = std.strdup("type");
        }

        let waiting_name = ident.to_string(waiting_ident, tc.span_interner);
        io.printf(
            "DBG: %s was waiting for %s\n", waiting_name, resolved_name
        );
        delete waiting_name;
        delete resolved_name;
        // -----

        let field = ty.field_at(waiting_s_ty, req.offset);

        if req.kind == WAITING_TYPE {
            field.ty = resolved_ty;
        } else if req.kind == WAITING_TYPE_PTR {
            if !ty.is_ptr(field.ty) {
                push_internal_error(tc, waiting_ident.ident_span, "type is not a ptr");
                return;
            }

            ty.as_ptr(field.ty).inner = resolved_ty;
        }

        // TODO: calling this all the time is very inefficient
        let completely_initialized = ty.fill_width_align(waiting_ty);
        if completely_initialized {
            // recursively update types waiting for waiting_ty
            update_all_waiting(tc, waiting_mod, waiting_ty, waiting_ident);
        }

        return;
    }

    if req.kind == WAITING_FUNC_DEF {
        let waiting_f_ty = ty.as_func(waiting_ty);

        if req.offset == OFFSET_RETURN_TYPE {
            waiting_f_ty.ret = resolved_ty;
        } else {
            let p = ty.param_at(waiting_f_ty, req.offset);
            p.ty = resolved_ty;
        }

        if ty.func_is_initalized(waiting_f_ty) {
            let s = ident.to_string(&waiting_f_ty.name, tc.span_interner);
            io.printf("DBG: %s is fully initialized\n", s);
            delete s;
        }
    }
}

def get_import_alias(tc: *TypeChecker, imp: *ast.ImportStmt): ident.Ident {
    // when we support "import as" constructs, this will become more interesting
    let span = span.get(tc.span_interner, imp.mod.ident_span);
    let p = path.empty();
    if path.from_str_len(imp.mod.ident, span.len, &p) != 0 {
        return ident.empty();
    }

    let lsp = path.last_separator_ptr(&p);
    if lsp == null {
        // there is no separator
        return imp.mod;
    }
    lsp = lsp + 1; // skip the actual separator

    let offset = lsp - imp.mod.ident;
    let start = span.start + offset;
    let end = start + p.len - offset;

    let new_span = span.create(tc.span_interner, start, end, span.ctx);
    return ident.from_str(new_span, lsp);
}

def in_global_scope(tc: *TypeChecker): bool {
    return scope.num_scopes(&tc.ctx.scopes) <= 2;
}

def check_import(
    tc: *TypeChecker,
    i_s: *ast.ImportStmt,
    out_alias: *ident.Ident,
    out_ty: **ty.Mod
): bool {
    let error: string = null;
    let imported_mod = mod.try_get_mod_from_import(
        tc.mods,
        tc.ctx.mod,
        tc.span_interner,
        i_s,
        &error
    );

    // no such module
    if imported_mod == null {
        push_mk_err(tc, error, i_s.mod.ident_span);
        return false;
    }

    let alias = get_import_alias(tc, i_s);
    if alias.ident == null {
        push_internal_error(tc, i_s.mod.ident_span, "import alias was empty");
        return false;
    }
    add_import_alias(tc, &alias, imported_mod);

    let mod_ty = imported_mod.ty;
    // the imported module has not yet been resolved
    if mod_ty == null {
        // safe current context
        let ctx = tc.ctx;
        tc.ctx = empty_ctx();
        init_mod(tc, imported_mod);
        free_ctx(&tc.ctx);
        // and restore it after resolving the module
        tc.ctx = ctx;
    }

    *out_alias = alias;
    *out_ty = mod_ty;

    return true;
}


def check_struct_decl(tc: *TypeChecker, sd: *record.StructDecl): *ty.Struct {
    let prev = lookup(tc, &sd.name);
    if prev != null {
        push_duplicate_def_error(tc, &sd.name);
        return null;
    }

    let definition = ty.new_type(TY_STRUCT, sizeof ty.Struct);
    push_tmp_ty(tc, definition);
    ty.init_struct(definition, sd.name);

    let ty = ty.as_struct(definition);
    fill_struct_fields(tc, sd, ty);
    return ty;
}

def check_func_decl(tc: *TypeChecker, fd: *func.FuncDef): *ty.Func {
    let prev = lookup(tc, &fd.name);
    if prev != null {
        push_duplicate_def_error(tc, &fd.name);
        return null;
    }

    let definition = ty.new_type(TY_FUNC, sizeof ty.Func);
    push_tmp_ty(tc, definition);
    ty.init_func(definition, fd.name);

    let ty = ty.as_func(definition);
    fill_func_def(tc, fd, ty);
    return ty;
}

def check_func_body(tc: *TypeChecker, f_s: *ast.FuncDeclStmt): *ast.BlockStmt {
    let f_name = &f_s.decl.name;
    let f_ty = lookup(tc, f_name);

    if f_ty == null {
        push_not_defined_error(tc, f_name);
        return null;
    }

    if !ty.is_func(f_ty) {
        push_internal_error(tc, f_name.ident_span, "type is not a function");
        return null;
    }

    let f_ty = ty.as_func(f_ty);
    if !ty.func_is_initalized(f_ty) {
        // --- DBG ---
            let name_s = ident.to_string(f_name, tc.span_interner);
            io.printf("DBG: %s is not fully initialized\n", name_s);
            delete name_s;
        // --- DBG ---

        std.abort();
        // in this case, an error will be pushed later
        return null;
    }

    return f_s.block;
}

// returns the statement which should replace the old one
// if a new statement is created, this function will free the old one
def check_stmt(tc: *TypeChecker, s: *ast.Stmt): *ast.Stmt {
    // STMT_BLOCK
    // STMT_IF
    // STMT_WHILE
    // STMT_DELETE
    // STMT_RETURN

    // STMT_IMPORT
    if ast.is_import_stmt(s) {
        if in_global_scope(tc) {
            return s;
        }

        // TODO: currently not allowed error
        std.abort();

        let i_s = ast.as_import_stmt(s);

        let alias: ident.Ident = ident.empty();
        let ty: *ty.Mod = null;

        if check_import(tc, i_s, &alias, &ty) {
            bind(tc, &alias, ty as *ty.Type);
        } else {
            std.abort();
            return null;
        }

        return s;
    }

    // STMT_STRUCT_DECL
    if ast.is_struct_decl_stmt(s) {
        if in_global_scope(tc) {
            return s;
        }

        // TODO: currently not allowed error
        std.abort();

        let sd = &ast.as_struct_decl_stmt(s).decl;
        let ty = check_struct_decl(tc, sd);

        if ty != null {
            bind(tc, &sd.name, ty as *ty.Type);
        } else {
            std.abort();
            return null;
        }

        return s;
    }

    // STMT_FUNC_DECL
    if ast.is_func_decl_stmt(s) {
        let f_s = ast.as_func_decl_stmt(s);
        if in_global_scope(tc) {
            let block = check_func_body(tc, f_s);
            if block == null {
                return null;
            }
            f_s.block = block;
            return s;
        }

        // TODO: currently not allowed error
        std.abort();

        let fd = &f_s.decl;
        let ty = check_func_decl(tc, fd);

        if ty != null {
            bind(tc, &fd.name, ty as *ty.Type);
        } else {
            std.abort();
            return null;
        }

        let block = check_func_body(tc, f_s);
        if block == null {
            return null;
        }
        f_s.block = block;
        return s;
    }

    // STMT_LET
    if ast.is_let_stmt(s) {
        let l_s = ast.as_let_stmt(s);
        let value = check_expr(tc, l_s.value);
        if value == null {
            return null;
        }
        l_s.value = value;
        bind(tc, &l_s.ident, l_s.value.ty);
        return s;
    }

    // STMT_EXPR
    if ast.is_expr_stmt(s) {
        let e_s = ast.as_expr_stmt(s);
        let expr = check_expr(tc, e_s.expr);
        if expr == null {
            return null;
        }
        e_s.expr = expr;
        return s;
    }

    return null;
}

def check_expr(tc: *TypeChecker, e: *ast.Expr): *ast.Expr {
    // EXPR_CHAR
    // EXPR_BINARY
    // EXPR_UNARY
    // EXPR_ASSIGN
    // EXPR_CALL
    // EXPR_INIT
    // EXPR_AS
    // EXPR_NEW

    // TODO: debug remove
    // let s = ast.expr_to_string(e, tc.span_interner);
    // io.printf("%s\n", s);
    // delete s;

    // EXPR_INT
    if ast.is_int_expr(e) {
        e.ty = scope.s_get_in(&tc.globals, 3, "i32");
        return e;
    }

    // EXPR_STRING
    if ast.is_string_expr(e) {
        e.ty = scope.s_get_in(&tc.globals, 6, "string");
        return e;
    }

    // EXPR_IDENT
    if ast.is_ident_expr(e) {
        let ident = &ast.as_ident_expr(e).ident;
        e.ty = lookup(tc, ident);

        if e.ty == null {
            push_not_defined_error(tc, ident);
            return null;
        }

        return e;
    }

    // EXPR_ACCESS
    if ast.is_access_expr(e) {
        let a_e = ast.as_access_expr(e);

        if !ast.is_ident_expr(a_e.left) {
            push_invalid_access_error(tc, a_e.left);
            return null;
        }

        let left = check_expr(tc, a_e.left);
        if left == null {
            return null;
        }

        a_e.left = left;

        // Type cannot be accessed with '.'
        if !ty.is_scoped(a_e.left.ty) || ty.is_struct(a_e.left.ty) {
            // struct types are the types of the definition and not an actual
            // instance (basically class vs object of that class). There is currently
            // no mechanism to access the fields of a struct definition, which could
            // change in the future
            push_not_accessible_with_error(tc, a_e.left);
            return null;
        }

        let scope = ty.get_scope(a_e.left.ty);
        if scope == null {
            push_internal_error(tc, a_e.left.span, "no scope for type found");
            return null;
        }

        // bring scope into current context
        scope.push_scope(&tc.ctx.scopes, scope);

        let right = check_expr(tc, a_e.right);
        if right == null {
            // TODO: could there be more than one?
            scope.close_scope_no_free(&tc.ctx.scopes);
            return null;
        }

        // TODO: could there be more than one?
        scope.close_scope_no_free(&tc.ctx.scopes);

        a_e.right = right;

        return e;
    }

    return e;
}

def free_tc(tc: *TypeChecker): void {
    free_ctx(&tc.ctx);

    let i = 0;
    while i < tc.temp_types.len {
        ty.type_free(ptrvec.get(&tc.temp_types, i) as *ty.Type);
        i = i + 1;
    }

    ptrvec.free_v(&tc.temp_types);
    delete tc.sorted_mods;

    i = 0;
    while i < tc.errors.len {
        free_err(get_err(tc, i));
        i = i + 1;
    }
    vec.free_v(&tc.errors);

    scope.free_s(&tc.globals);


    i = 0;
    while i < tc.requests.len {
        free_wait_map(vec.get_ptr(&tc.requests, i) as *WaitingRequestMap);
        i = i + 1;
    }
    vec.free_v(&tc.requests);
}

#include "error_code.h"

def push_internal_error(tc: *TypeChecker, span: span.Span, text: string): void {
    let text = std.err2str(ERROR_INTERNAL, text);
    push_mk_err(tc, text, span);
}

def push_simple_error(tc: *TypeChecker, code: i32, ident: *ident.Ident): void {
    let span = ident.ident_span;
    let len = span.get(tc.span_interner, span).len;
    let text = std.err2str(code, len, ident.ident);

    push_mk_err(tc, text, span);
}

def push_duplicate_def_error(tc: *TypeChecker, name: *ident.Ident): void {
    push_simple_error(tc, ERROR_DUPLICATE_DEFINTION, name);
}

def push_not_defined_error(tc: *TypeChecker, name: *ident.Ident): void {
    push_simple_error(tc, ERROR_NOT_DEFINED, name);
}

def push_invalid_access_error(tc: *TypeChecker, e: *ast.Expr): void {
    let ty_s = ast.expr2str(e.tag);
    let error = std.err2str(ERROR_INVALID_ACCESS_TYPE, ty_s);

    push_mk_err(tc, error, e.span);
}

def push_not_accessible_with_error(tc: *TypeChecker, e: *ast.Expr): void {
    let ty_s = ty.to_string(e.ty, tc.span_interner);
    let error = std.err2str(ERROR_NOT_ACCESSIBLE_WITH_OP, ty_s, ".");
    delete ty_s;

    push_mk_err(tc, error, e.span);
}
