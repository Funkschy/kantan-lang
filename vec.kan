import "std";
import "dbg";

type Vec struct {
    len: i32,
    cap: i32,
    elem_size: i32,
    elements: *void
}

def create(elem_size: i32): Vec {
    return Vec { len: 0, cap: 0, elem_size: elem_size, elements: null };
}

def with_cap(elem_size: i32, cap: i32): Vec {
    if cap == 0 {
        return create(elem_size);
    }
    return Vec { len: 0, cap: cap, elem_size: elem_size, elements: std.malloc(cap * elem_size)};
}

def (v: *Vec) push(elem: *void) {
    if v.len + 1 > v.cap {
        v.resize();
    }

    std.memcpy(v.elements + v.len * v.elem_size, elem, v.elem_size);
    v.len = v.len + 1;
}

def (v: *Vec) push_front(elem: *void) {
    if v.len + 1 > v.cap {
        v.resize();
    }

    if v.len > 0 {
        std.memmove(v.elements + 1 * v.elem_size, v.elements, v.elem_size * v.len);
    }

    std.memcpy(v.elements, elem, v.elem_size);
    v.len = v.len + 1;
}

def (v: *Vec) init_zero(): void {
    v.len = v.cap;
    std.memset(v.elements, 0, v.elem_size * v.cap);
}

def (v: *Vec) set(i: i32, elem: *void): void {
    dbg.assert(i >= 0 && i < v.cap, "out of bounds set");

    std.memcpy(v.elements + i * v.elem_size, elem, v.elem_size);
    // assume all values in between to be initialized
    if i >= v.len {
        v.len = i + 1;
    }
}

def (v: *Vec) get(i: i32, ptr: *void): bool {
    if i >= 0 && i < v.len {
        std.memcpy(ptr, v.elements + i * v.elem_size, v.elem_size);
        return true;
    }

    return false;
}

def (v: *Vec) get_ptr(i: i32): *void {
    if i >= 0 && i < v.len {
        return v.elements + i * v.elem_size;
    }

    return null;
}

def (v: *Vec) resize(): void {
    if v.elements == null {
        v.cap = 2;
        v.elements = std.malloc(v.cap * v.elem_size);
    } else {
        v.cap = v.cap * 2;
        v.elements = std.realloc(v.elements, v.cap * v.elem_size);
    }
}

def (v: *Vec) free(): void {
    delete v.elements;
}
